// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/dotenv/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.4.5",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      "lint-readme": "standard-markdown",
      pretest: "npm run lint && npm run dts-check",
      test: "tap tests/*.js --100 -Rspec",
      "test:coverage": "tap --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    funding: "https://dotenvx.com",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@definitelytyped/dtslint": "^0.0.133",
      "@types/node": "^18.11.3",
      decache: "^4.6.1",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-markdown": "^7.1.0",
      "standard-version": "^9.5.0",
      tap: "^16.3.0",
      tar: "^6.1.11",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var parse = function(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, "\n");
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, "\n");
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  };
  var _parseVault = function(options) {
    const vaultPath = _vaultPath(options);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error) {
        if (i + 1 >= length) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  };
  var _log = function(message) {
    console.log(`[dotenv@${version}][INFO] ${message}`);
  };
  var _warn = function(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
  };
  var _debug = function(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  };
  var _dotenvKey = function(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  };
  var _instructions = function(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error) {
      if (error.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  };
  var _vaultPath = function(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  };
  var _resolveHome = function(envPath) {
    return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
  };
  var _configVault = function(options) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  };
  var configDotenv = function(options) {
    const dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug = Boolean(options && options.debug);
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        optionPaths = [_resolveHome(options.path)];
      } else {
        optionPaths = [];
        for (const filepath of options.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path2 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${path2} ${e.message}`);
        }
        lastError = e;
      }
    }
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options);
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  };
  var config2 = function(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  };
  var decrypt = function(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
      const isRange = error instanceof RangeError;
      const invalidKeyLength = error.message === "Invalid key length";
      const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error;
      }
    }
  };
  var populate = function(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  };
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var os = import.meta.require("os");
  var crypto2 = import.meta.require("crypto");
  var packageJson = require_package();
  var version = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config: config2,
    decrypt,
    parse,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// node_modules/dotenv/lib/env-options.js
var require_env_options = __commonJS((exports, module) => {
  var options = {};
  if (process.env.DOTENV_CONFIG_ENCODING != null) {
    options.encoding = process.env.DOTENV_CONFIG_ENCODING;
  }
  if (process.env.DOTENV_CONFIG_PATH != null) {
    options.path = process.env.DOTENV_CONFIG_PATH;
  }
  if (process.env.DOTENV_CONFIG_DEBUG != null) {
    options.debug = process.env.DOTENV_CONFIG_DEBUG;
  }
  if (process.env.DOTENV_CONFIG_OVERRIDE != null) {
    options.override = process.env.DOTENV_CONFIG_OVERRIDE;
  }
  if (process.env.DOTENV_CONFIG_DOTENV_KEY != null) {
    options.DOTENV_KEY = process.env.DOTENV_CONFIG_DOTENV_KEY;
  }
  module.exports = options;
});

// node_modules/dotenv/lib/cli-options.js
var require_cli_options = __commonJS((exports, module) => {
  var re = /^dotenv_config_(encoding|path|debug|override|DOTENV_KEY)=(.+)$/;
  module.exports = function optionMatcher(args) {
    return args.reduce(function(acc, cur) {
      const matches = cur.match(re);
      if (matches) {
        acc[matches[1]] = matches[2];
      }
      return acc;
    }, {});
  };
});

// node_modules/dotenv/config.js
var require_config = __commonJS(() => {
  (function() {
    require_main().config(Object.assign({}, require_env_options(), require_cli_options()(process.argv)));
  })();
});

// node_modules/logform/format.js
var require_format = __commonJS((exports, module) => {
  class InvalidFormatError extends Error {
    constructor(formatFn) {
      super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}\n`);
      Error.captureStackTrace(this, InvalidFormatError);
    }
  }
  module.exports = (formatFn) => {
    if (formatFn.length > 2) {
      throw new InvalidFormatError(formatFn);
    }
    function Format(options = {}) {
      this.options = options;
    }
    Format.prototype.transform = formatFn;
    function createFormatWrap(opts) {
      return new Format(opts);
    }
    createFormatWrap.Format = Format;
    return createFormatWrap;
  };
});

// node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS((exports, module) => {
  var styles = {};
  module["exports"] = styles;
  var codes = {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    grey: [90, 39],
    brightRed: [91, 39],
    brightGreen: [92, 39],
    brightYellow: [93, 39],
    brightBlue: [94, 39],
    brightMagenta: [95, 39],
    brightCyan: [96, 39],
    brightWhite: [97, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgBrightRed: [101, 49],
    bgBrightGreen: [102, 49],
    bgBrightYellow: [103, 49],
    bgBrightBlue: [104, 49],
    bgBrightMagenta: [105, 49],
    bgBrightCyan: [106, 49],
    bgBrightWhite: [107, 49],
    blackBG: [40, 49],
    redBG: [41, 49],
    greenBG: [42, 49],
    yellowBG: [43, 49],
    blueBG: [44, 49],
    magentaBG: [45, 49],
    cyanBG: [46, 49],
    whiteBG: [47, 49]
  };
  Object.keys(codes).forEach(function(key) {
    var val = codes[key];
    var style = styles[key] = [];
    style.open = "\x1B[" + val[0] + "m";
    style.close = "\x1B[" + val[1] + "m";
  });
});

// node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = function(flag, argv) {
    argv = argv || process.argv || [];
    var terminatorPos = argv.indexOf("--");
    var prefix = /^-{1,2}/.test(flag) ? "" : "--";
    var pos = argv.indexOf(prefix + flag);
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS((exports, module) => {
  var translateLevel = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor = function(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    var min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      var osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
        return sign in env;
      }) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("TERM_PROGRAM" in env) {
      var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Hyper":
          return 3;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    if (env.TERM === "dumb") {
      return min;
    }
    return min;
  };
  var getSupportLevel = function(stream) {
    var level = supportsColor(stream);
    return translateLevel(level);
  };
  var os = import.meta.require("os");
  var hasFlag = require_has_flag();
  var env = process.env;
  var forceColor = undefined;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env) {
    forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS((exports, module) => {
  module["exports"] = function runTheTrap(text, options) {
    var result = "";
    text = text || "Run the trap, drop the bass";
    text = text.split("");
    var trap = {
      a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
      b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
      c: ["\xA9", "\u023B", "\u03FE"],
      d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
      e: [
        "\xCB",
        "\u0115",
        "\u018E",
        "\u0258",
        "\u03A3",
        "\u03BE",
        "\u04BC",
        "\u0A6C"
      ],
      f: ["\u04FA"],
      g: ["\u0262"],
      h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
      i: ["\u0F0F"],
      j: ["\u0134"],
      k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
      l: ["\u0139"],
      m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
      n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
      o: [
        "\xD8",
        "\xF5",
        "\xF8",
        "\u01FE",
        "\u0298",
        "\u047A",
        "\u05DD",
        "\u06DD",
        "\u0E4F"
      ],
      p: ["\u01F7", "\u048E"],
      q: ["\u09CD"],
      r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
      s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
      t: ["\u0141", "\u0166", "\u0373"],
      u: ["\u01B1", "\u054D"],
      v: ["\u05D8"],
      w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
      x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
      y: ["\xA5", "\u04B0", "\u04CB"],
      z: ["\u01B5", "\u0240"]
    };
    text.forEach(function(c) {
      c = c.toLowerCase();
      var chars = trap[c] || [" "];
      var rand = Math.floor(Math.random() * chars.length);
      if (typeof trap[c] !== "undefined") {
        result += trap[c][rand];
      } else {
        result += c;
      }
    });
    return result;
  };
});

// node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS((exports, module) => {
  module["exports"] = function zalgo(text, options) {
    text = text || "   he is here   ";
    var soul = {
      up: [
        "\u030D",
        "\u030E",
        "\u0304",
        "\u0305",
        "\u033F",
        "\u0311",
        "\u0306",
        "\u0310",
        "\u0352",
        "\u0357",
        "\u0351",
        "\u0307",
        "\u0308",
        "\u030A",
        "\u0342",
        "\u0313",
        "\u0308",
        "\u034A",
        "\u034B",
        "\u034C",
        "\u0303",
        "\u0302",
        "\u030C",
        "\u0350",
        "\u0300",
        "\u0301",
        "\u030B",
        "\u030F",
        "\u0312",
        "\u0313",
        "\u0314",
        "\u033D",
        "\u0309",
        "\u0363",
        "\u0364",
        "\u0365",
        "\u0366",
        "\u0367",
        "\u0368",
        "\u0369",
        "\u036A",
        "\u036B",
        "\u036C",
        "\u036D",
        "\u036E",
        "\u036F",
        "\u033E",
        "\u035B",
        "\u0346",
        "\u031A"
      ],
      down: [
        "\u0316",
        "\u0317",
        "\u0318",
        "\u0319",
        "\u031C",
        "\u031D",
        "\u031E",
        "\u031F",
        "\u0320",
        "\u0324",
        "\u0325",
        "\u0326",
        "\u0329",
        "\u032A",
        "\u032B",
        "\u032C",
        "\u032D",
        "\u032E",
        "\u032F",
        "\u0330",
        "\u0331",
        "\u0332",
        "\u0333",
        "\u0339",
        "\u033A",
        "\u033B",
        "\u033C",
        "\u0345",
        "\u0347",
        "\u0348",
        "\u0349",
        "\u034D",
        "\u034E",
        "\u0353",
        "\u0354",
        "\u0355",
        "\u0356",
        "\u0359",
        "\u035A",
        "\u0323"
      ],
      mid: [
        "\u0315",
        "\u031B",
        "\u0300",
        "\u0301",
        "\u0358",
        "\u0321",
        "\u0322",
        "\u0327",
        "\u0328",
        "\u0334",
        "\u0335",
        "\u0336",
        "\u035C",
        "\u035D",
        "\u035E",
        "\u035F",
        "\u0360",
        "\u0362",
        "\u0338",
        "\u0337",
        "\u0361",
        " \u0489"
      ]
    };
    var all = [].concat(soul.up, soul.down, soul.mid);
    function randomNumber(range) {
      var r = Math.floor(Math.random() * range);
      return r;
    }
    function isChar(character) {
      var bool = false;
      all.filter(function(i) {
        bool = i === character;
      });
      return bool;
    }
    function heComes(text2, options2) {
      var result = "";
      var counts;
      var l;
      options2 = options2 || {};
      options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
      options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
      options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
      options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
      text2 = text2.split("");
      for (l in text2) {
        if (isChar(l)) {
          continue;
        }
        result = result + text2[l];
        counts = { up: 0, down: 0, mid: 0 };
        switch (options2.size) {
          case "mini":
            counts.up = randomNumber(8);
            counts.mid = randomNumber(2);
            counts.down = randomNumber(8);
            break;
          case "maxi":
            counts.up = randomNumber(16) + 3;
            counts.mid = randomNumber(4) + 1;
            counts.down = randomNumber(64) + 3;
            break;
          default:
            counts.up = randomNumber(8) + 1;
            counts.mid = randomNumber(6) / 2;
            counts.down = randomNumber(8) + 1;
            break;
        }
        var arr = ["up", "mid", "down"];
        for (var d in arr) {
          var index = arr[d];
          for (var i = 0;i <= counts[index]; i++) {
            if (options2[index]) {
              result = result + soul[index][randomNumber(soul[index].length)];
            }
          }
        }
      }
      return result;
    }
    return heComes(text, options);
  };
});

// node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i, exploded) {
      if (letter === " ")
        return letter;
      switch (i % 3) {
        case 0:
          return colors.red(letter);
        case 1:
          return colors.white(letter);
        case 2:
          return colors.blue(letter);
      }
    };
  };
});

// node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    return function(letter, i, exploded) {
      return i % 2 === 0 ? letter : colors.inverse(letter);
    };
  };
});

// node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
    return function(letter, i, exploded) {
      if (letter === " ") {
        return letter;
      } else {
        return colors[rainbowColors[i++ % rainbowColors.length]](letter);
      }
    };
  };
});

// node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS((exports, module) => {
  module["exports"] = function(colors) {
    var available = [
      "underline",
      "inverse",
      "grey",
      "yellow",
      "red",
      "green",
      "blue",
      "white",
      "cyan",
      "magenta",
      "brightYellow",
      "brightRed",
      "brightGreen",
      "brightBlue",
      "brightWhite",
      "brightCyan",
      "brightMagenta"
    ];
    return function(letter, i, exploded) {
      return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
    };
  };
});

// node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS((exports, module) => {
  var build = function(_styles) {
    var builder = function builder() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder.__proto__ = proto;
    return builder;
  };
  var applyStyle = function() {
    var args = Array.prototype.slice.call(arguments);
    var str = args.map(function(arg) {
      if (arg != null && arg.constructor === String) {
        return arg;
      } else {
        return util.inspect(arg);
      }
    }).join(" ");
    if (!colors.enabled || !str) {
      return str;
    }
    var newLinesPresent = str.indexOf("\n") != -1;
    var nestedStyles = this._styles;
    var i = nestedStyles.length;
    while (i--) {
      var code = ansiStyles[nestedStyles[i]];
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      if (newLinesPresent) {
        str = str.replace(newLineRegex, function(match) {
          return code.close + match + code.open;
        });
      }
    }
    return str;
  };
  var init = function() {
    var ret = {};
    Object.keys(styles).forEach(function(name) {
      ret[name] = {
        get: function() {
          return build([name]);
        }
      };
    });
    return ret;
  };
  var colors = {};
  module["exports"] = colors;
  colors.themes = {};
  var util = import.meta.require("util");
  var ansiStyles = colors.styles = require_styles();
  var defineProps = Object.defineProperties;
  var newLineRegex = new RegExp(/[\r\n]+/g);
  colors.supportsColor = require_supports_colors().supportsColor;
  if (typeof colors.enabled === "undefined") {
    colors.enabled = colors.supportsColor() !== false;
  }
  colors.enable = function() {
    colors.enabled = true;
  };
  colors.disable = function() {
    colors.enabled = false;
  };
  colors.stripColors = colors.strip = function(str) {
    return ("" + str).replace(/\x1B\[\d+m/g, "");
  };
  var stylize = colors.stylize = function stylize(str, style) {
    if (!colors.enabled) {
      return str + "";
    }
    var styleMap = ansiStyles[style];
    if (!styleMap && style in colors) {
      return colors[style](str);
    }
    return styleMap.open + str + styleMap.close;
  };
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  var escapeStringRegexp = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
  var styles = function() {
    var ret = {};
    ansiStyles.grey = ansiStyles.gray;
    Object.keys(ansiStyles).forEach(function(key) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      ret[key] = {
        get: function() {
          return build(this._styles.concat(key));
        }
      };
    });
    return ret;
  }();
  var proto = defineProps(function colors() {
  }, styles);
  colors.setTheme = function(theme) {
    if (typeof theme === "string") {
      console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller\'s) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + \'/../themes/generic-logging.js\'); The new syntax looks like colors.setTheme(require(__dirname + \'/../themes/generic-logging.js\'));");
      return;
    }
    for (var style in theme) {
      (function(style2) {
        colors[style2] = function(str) {
          if (typeof theme[style2] === "object") {
            var out = str;
            for (var i in theme[style2]) {
              out = colors[theme[style2][i]](out);
            }
            return out;
          }
          return colors[theme[style2]](str);
        };
      })(style);
    }
  };
  var sequencer = function sequencer(map2, str) {
    var exploded = str.split("");
    exploded = exploded.map(map2);
    return exploded.join("");
  };
  colors.trap = require_trap();
  colors.zalgo = require_zalgo();
  colors.maps = {};
  colors.maps.america = require_america()(colors);
  colors.maps.zebra = require_zebra()(colors);
  colors.maps.rainbow = require_rainbow()(colors);
  colors.maps.random = require_random()(colors);
  for (map in colors.maps) {
    (function(map2) {
      colors[map2] = function(str) {
        return sequencer(colors.maps[map2], str);
      };
    })(map);
  }
  var map;
  defineProps(colors, init());
});

// node_modules/@colors/colors/safe.js
var require_safe = __commonJS((exports, module) => {
  var colors = require_colors();
  module["exports"] = colors;
});

// node_modules/triple-beam/config/cli.js
var require_cli = __commonJS((exports) => {
  exports.levels = {
    error: 0,
    warn: 1,
    help: 2,
    data: 3,
    info: 4,
    debug: 5,
    prompt: 6,
    verbose: 7,
    input: 8,
    silly: 9
  };
  exports.colors = {
    error: "red",
    warn: "yellow",
    help: "cyan",
    data: "grey",
    info: "green",
    debug: "blue",
    prompt: "grey",
    verbose: "cyan",
    input: "grey",
    silly: "magenta"
  };
});

// node_modules/triple-beam/config/npm.js
var require_npm = __commonJS((exports) => {
  exports.levels = {
    error: 0,
    warn: 1,
    info: 2,
    http: 3,
    verbose: 4,
    debug: 5,
    silly: 6
  };
  exports.colors = {
    error: "red",
    warn: "yellow",
    info: "green",
    http: "green",
    verbose: "cyan",
    debug: "blue",
    silly: "magenta"
  };
});

// node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS((exports) => {
  exports.levels = {
    emerg: 0,
    alert: 1,
    crit: 2,
    error: 3,
    warning: 4,
    notice: 5,
    info: 6,
    debug: 7
  };
  exports.colors = {
    emerg: "red",
    alert: "yellow",
    crit: "red",
    error: "red",
    warning: "red",
    notice: "yellow",
    info: "green",
    debug: "blue"
  };
});

// node_modules/triple-beam/config/index.js
var require_config2 = __commonJS((exports) => {
  Object.defineProperty(exports, "cli", {
    value: require_cli()
  });
  Object.defineProperty(exports, "npm", {
    value: require_npm()
  });
  Object.defineProperty(exports, "syslog", {
    value: require_syslog()
  });
});

// node_modules/triple-beam/index.js
var require_triple_beam = __commonJS((exports) => {
  Object.defineProperty(exports, "LEVEL", {
    value: Symbol.for("level")
  });
  Object.defineProperty(exports, "MESSAGE", {
    value: Symbol.for("message")
  });
  Object.defineProperty(exports, "SPLAT", {
    value: Symbol.for("splat")
  });
  Object.defineProperty(exports, "configs", {
    value: require_config2()
  });
});

// node_modules/logform/colorize.js
var require_colorize = __commonJS((exports, module) => {
  var colors = require_safe();
  var { LEVEL, MESSAGE } = require_triple_beam();
  colors.enabled = true;
  var hasSpace = /\s+/;

  class Colorizer {
    constructor(opts = {}) {
      if (opts.colors) {
        this.addColors(opts.colors);
      }
      this.options = opts;
    }
    static addColors(clrs) {
      const nextColors = Object.keys(clrs).reduce((acc, level) => {
        acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
        return acc;
      }, {});
      Colorizer.allColors = Object.assign({}, Colorizer.allColors || {}, nextColors);
      return Colorizer.allColors;
    }
    addColors(clrs) {
      return Colorizer.addColors(clrs);
    }
    colorize(lookup, level, message) {
      if (typeof message === "undefined") {
        message = level;
      }
      if (!Array.isArray(Colorizer.allColors[lookup])) {
        return colors[Colorizer.allColors[lookup]](message);
      }
      for (let i = 0, len = Colorizer.allColors[lookup].length;i < len; i++) {
        message = colors[Colorizer.allColors[lookup][i]](message);
      }
      return message;
    }
    transform(info, opts) {
      if (opts.all && typeof info[MESSAGE] === "string") {
        info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
      }
      if (opts.level || opts.all || !opts.message) {
        info.level = this.colorize(info[LEVEL], info.level);
      }
      if (opts.all || opts.message) {
        info.message = this.colorize(info[LEVEL], info.level, info.message);
      }
      return info;
    }
  }
  module.exports = (opts) => new Colorizer(opts);
  module.exports.Colorizer = module.exports.Format = Colorizer;
});

// node_modules/logform/levels.js
var require_levels = __commonJS((exports, module) => {
  var { Colorizer } = require_colorize();
  module.exports = (config2) => {
    Colorizer.addColors(config2.colors || config2);
    return config2;
  };
});

// node_modules/logform/align.js
var require_align = __commonJS((exports, module) => {
  var format = require_format();
  module.exports = format((info) => {
    info.message = `\t${info.message}`;
    return info;
  });
});

// node_modules/logform/errors.js
var require_errors = __commonJS((exports, module) => {
  var format = require_format();
  var { LEVEL, MESSAGE } = require_triple_beam();
  module.exports = format((einfo, { stack, cause }) => {
    if (einfo instanceof Error) {
      const info = Object.assign({}, einfo, {
        level: einfo.level,
        [LEVEL]: einfo[LEVEL] || einfo.level,
        message: einfo.message,
        [MESSAGE]: einfo[MESSAGE] || einfo.message
      });
      if (stack)
        info.stack = einfo.stack;
      if (cause)
        info.cause = einfo.cause;
      return info;
    }
    if (!(einfo.message instanceof Error))
      return einfo;
    const err = einfo.message;
    Object.assign(einfo, err);
    einfo.message = err.message;
    einfo[MESSAGE] = err.message;
    if (stack)
      einfo.stack = err.stack;
    if (cause)
      einfo.cause = err.cause;
    return einfo;
  });
});

// node_modules/logform/pad-levels.js
var require_pad_levels = __commonJS((exports, module) => {
  var { configs, LEVEL, MESSAGE } = require_triple_beam();

  class Padder {
    constructor(opts = { levels: configs.npm.levels }) {
      this.paddings = Padder.paddingForLevels(opts.levels, opts.filler);
      this.options = opts;
    }
    static getLongestLevel(levels) {
      const lvls = Object.keys(levels).map((level) => level.length);
      return Math.max(...lvls);
    }
    static paddingForLevel(level, filler, maxLength) {
      const targetLen = maxLength + 1 - level.length;
      const rep = Math.floor(targetLen / filler.length);
      const padding = `${filler}${filler.repeat(rep)}`;
      return padding.slice(0, targetLen);
    }
    static paddingForLevels(levels, filler = " ") {
      const maxLength = Padder.getLongestLevel(levels);
      return Object.keys(levels).reduce((acc, level) => {
        acc[level] = Padder.paddingForLevel(level, filler, maxLength);
        return acc;
      }, {});
    }
    transform(info, opts) {
      info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
      if (info[MESSAGE]) {
        info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
      }
      return info;
    }
  }
  module.exports = (opts) => new Padder(opts);
  module.exports.Padder = module.exports.Format = Padder;
});

// node_modules/logform/cli.js
var require_cli2 = __commonJS((exports, module) => {
  var { Colorizer } = require_colorize();
  var { Padder } = require_pad_levels();
  var { configs, MESSAGE } = require_triple_beam();

  class CliFormat {
    constructor(opts = {}) {
      if (!opts.levels) {
        opts.levels = configs.cli.levels;
      }
      this.colorizer = new Colorizer(opts);
      this.padder = new Padder(opts);
      this.options = opts;
    }
    transform(info, opts) {
      this.colorizer.transform(this.padder.transform(info, opts), opts);
      info[MESSAGE] = `${info.level}:${info.message}`;
      return info;
    }
  }
  module.exports = (opts) => new CliFormat(opts);
  module.exports.Format = CliFormat;
});

// node_modules/logform/combine.js
var require_combine = __commonJS((exports, module) => {
  var cascade = function(formats) {
    if (!formats.every(isValidFormat)) {
      return;
    }
    return (info) => {
      let obj = info;
      for (let i = 0;i < formats.length; i++) {
        obj = formats[i].transform(obj, formats[i].options);
        if (!obj) {
          return false;
        }
      }
      return obj;
    };
  };
  var isValidFormat = function(fmt) {
    if (typeof fmt.transform !== "function") {
      throw new Error([
        "No transform function found on format. Did you create a format instance?",
        "const myFormat = format(formatFn);",
        "const instance = myFormat();"
      ].join("\n"));
    }
    return true;
  };
  var format = require_format();
  module.exports = (...formats) => {
    const combinedFormat = format(cascade(formats));
    const instance = combinedFormat();
    instance.Format = combinedFormat.Format;
    return instance;
  };
  module.exports.cascade = cascade;
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS((exports, module) => {
  var strEscape = function(str) {
    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
      return `"${str}"`;
    }
    return JSON.stringify(str);
  };
  var insertSort = function(array) {
    if (array.length > 200) {
      return array.sort();
    }
    for (let i = 1;i < array.length; i++) {
      const currentValue = array[i];
      let position = i;
      while (position !== 0 && array[position - 1] > currentValue) {
        array[position] = array[position - 1];
        position--;
      }
      array[position] = currentValue;
    }
    return array;
  };
  var isTypedArrayWithEntries = function(value) {
    return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;
  };
  var stringifyTypedArray = function(array, separator, maximumBreadth) {
    if (array.length < maximumBreadth) {
      maximumBreadth = array.length;
    }
    const whitespace = separator === "," ? "" : " ";
    let res = `"0":${whitespace}${array[0]}`;
    for (let i = 1;i < maximumBreadth; i++) {
      res += `${separator}"${i}":${whitespace}${array[i]}`;
    }
    return res;
  };
  var getCircularValueOption = function(options) {
    if (hasOwnProperty.call(options, "circularValue")) {
      const circularValue = options.circularValue;
      if (typeof circularValue === "string") {
        return `"${circularValue}"`;
      }
      if (circularValue == null) {
        return circularValue;
      }
      if (circularValue === Error || circularValue === TypeError) {
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          }
        };
      }
      throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
  };
  var getBooleanOption = function(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
      value = options[key];
      if (typeof value !== "boolean") {
        throw new TypeError(`The "${key}" argument must be of type boolean`);
      }
    }
    return value === undefined ? true : value;
  };
  var getPositiveIntegerOption = function(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
      value = options[key];
      if (typeof value !== "number") {
        throw new TypeError(`The "${key}" argument must be of type number`);
      }
      if (!Number.isInteger(value)) {
        throw new TypeError(`The "${key}" argument must be an integer`);
      }
      if (value < 1) {
        throw new RangeError(`The "${key}" argument must be >= 1`);
      }
    }
    return value === undefined ? Infinity : value;
  };
  var getItemCount = function(number) {
    if (number === 1) {
      return "1 item";
    }
    return `${number} items`;
  };
  var getUniqueReplacerSet = function(replacerArray) {
    const replacerSet = new Set;
    for (const value of replacerArray) {
      if (typeof value === "string" || typeof value === "number") {
        replacerSet.add(String(value));
      }
    }
    return replacerSet;
  };
  var getStrictOption = function(options) {
    if (hasOwnProperty.call(options, "strict")) {
      const value = options.strict;
      if (typeof value !== "boolean") {
        throw new TypeError('The "strict" argument must be of type boolean');
      }
      if (value) {
        return (value2) => {
          let message = `Object can not safely be stringified. Received type ${typeof value2}`;
          if (typeof value2 !== "function")
            message += ` (${value2.toString()})`;
          throw new Error(message);
        };
      }
    }
  };
  var configure = function(options) {
    options = { ...options };
    const fail = getStrictOption(options);
    if (fail) {
      if (options.bigint === undefined) {
        options.bigint = false;
      }
      if (!("circularValue" in options)) {
        options.circularValue = Error;
      }
    }
    const circularValue = getCircularValueOption(options);
    const bigint = getBooleanOption(options, "bigint");
    const deterministic = getBooleanOption(options, "deterministic");
    const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
    const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
      let value = parent[key];
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      value = replacer.call(parent, key, value);
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          let join2 = ",";
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join2 = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join2;
            }
            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let whitespace = "";
          let separator = "";
          if (spacer !== "") {
            indentation += spacer;
            join2 = `,\n${indentation}`;
            whitespace = " ";
          }
          const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (deterministic && !isTypedArrayWithEntries(value)) {
            keys = insertSort(keys);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join2;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
            separator = join2;
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          let res = "";
          let join2 = ",";
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join2 = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join2;
            }
            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          stack.push(value);
          let whitespace = "";
          if (spacer !== "") {
            indentation += spacer;
            join2 = `,\n${indentation}`;
            whitespace = " ";
          }
          let separator = "";
          for (const key2 of replacer) {
            const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join2;
            }
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyIndent(key, value, stack, spacer, indentation) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifyIndent(key, value, stack, spacer, indentation);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            indentation += spacer;
            let res2 = `\n${indentation}`;
            const join3 = `,\n${indentation}`;
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp2 !== undefined ? tmp2 : "null";
              res2 += join3;
            }
            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
            res2 += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res2 += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            res2 += `\n${originalIndentation}`;
            stack.pop();
            return `[${res2}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          indentation += spacer;
          const join2 = `,\n${indentation}`;
          let res = "";
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, join2, maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = join2;
          }
          if (deterministic) {
            keys = insertSort(keys);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}: ${tmp}`;
              separator = join2;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
            separator = join2;
          }
          if (separator !== "") {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifySimple(key, value, stack) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifySimple(key, value, stack);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifySimple(String(i), value[i], stack);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += ",";
            }
            const tmp = stringifySimple(String(i), value[i], stack);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `,"... ${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, ",", maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = ",";
          }
          if (deterministic) {
            keys = insertSort(keys);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifySimple(key2, value[key2], stack);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${tmp}`;
              separator = ",";
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringify2(value, replacer, space) {
      if (arguments.length > 1) {
        let spacer = "";
        if (typeof space === "number") {
          spacer = " ".repeat(Math.min(space, 10));
        } else if (typeof space === "string") {
          spacer = space.slice(0, 10);
        }
        if (replacer != null) {
          if (typeof replacer === "function") {
            return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
          }
          if (Array.isArray(replacer)) {
            return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
          }
        }
        if (spacer.length !== 0) {
          return stringifyIndent("", value, [], spacer, "");
        }
      }
      return stringifySimple("", value, []);
    }
    return stringify2;
  };
  var { hasOwnProperty } = Object.prototype;
  var stringify = configure();
  stringify.configure = configure;
  stringify.stringify = stringify;
  stringify.default = stringify;
  exports.stringify = stringify;
  exports.configure = configure;
  module.exports = stringify;
  var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
  var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
});

// node_modules/logform/json.js
var require_json = __commonJS((exports, module) => {
  var replacer = function(key, value) {
    if (typeof value === "bigint")
      return value.toString();
    return value;
  };
  var format = require_format();
  var { MESSAGE } = require_triple_beam();
  var stringify = require_safe_stable_stringify();
  module.exports = format((info, opts) => {
    const jsonStringify = stringify.configure(opts);
    info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
    return info;
  });
});

// node_modules/logform/label.js
var require_label = __commonJS((exports, module) => {
  var format = require_format();
  module.exports = format((info, opts) => {
    if (opts.message) {
      info.message = `[${opts.label}] ${info.message}`;
      return info;
    }
    info.label = opts.label;
    return info;
  });
});

// node_modules/logform/logstash.js
var require_logstash = __commonJS((exports, module) => {
  var format = require_format();
  var { MESSAGE } = require_triple_beam();
  var jsonStringify = require_safe_stable_stringify();
  module.exports = format((info) => {
    const logstash = {};
    if (info.message) {
      logstash["@message"] = info.message;
      delete info.message;
    }
    if (info.timestamp) {
      logstash["@timestamp"] = info.timestamp;
      delete info.timestamp;
    }
    logstash["@fields"] = info;
    info[MESSAGE] = jsonStringify(logstash);
    return info;
  });
});

// node_modules/logform/metadata.js
var require_metadata = __commonJS((exports, module) => {
  var fillExcept = function(info, fillExceptKeys, metadataKey) {
    const savedKeys = fillExceptKeys.reduce((acc, key) => {
      acc[key] = info[key];
      delete info[key];
      return acc;
    }, {});
    const metadata = Object.keys(info).reduce((acc, key) => {
      acc[key] = info[key];
      delete info[key];
      return acc;
    }, {});
    Object.assign(info, savedKeys, {
      [metadataKey]: metadata
    });
    return info;
  };
  var fillWith = function(info, fillWithKeys, metadataKey) {
    info[metadataKey] = fillWithKeys.reduce((acc, key) => {
      acc[key] = info[key];
      delete info[key];
      return acc;
    }, {});
    return info;
  };
  var format = require_format();
  module.exports = format((info, opts = {}) => {
    let metadataKey = "metadata";
    if (opts.key) {
      metadataKey = opts.key;
    }
    let fillExceptKeys = [];
    if (!opts.fillExcept && !opts.fillWith) {
      fillExceptKeys.push("level");
      fillExceptKeys.push("message");
    }
    if (opts.fillExcept) {
      fillExceptKeys = opts.fillExcept;
    }
    if (fillExceptKeys.length > 0) {
      return fillExcept(info, fillExceptKeys, metadataKey);
    }
    if (opts.fillWith) {
      return fillWith(info, opts.fillWith, metadataKey);
    }
    return info;
  });
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var parse = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  };
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// node_modules/logform/ms.js
var require_ms2 = __commonJS((exports, module) => {
  var format = require_format();
  var ms = require_ms();
  module.exports = format((info) => {
    const curr = +new Date;
    exports.diff = curr - (exports.prevTime || curr);
    exports.prevTime = curr;
    info.ms = `+${ms(exports.diff)}`;
    return info;
  });
});

// node_modules/logform/pretty-print.js
var require_pretty_print = __commonJS((exports, module) => {
  var inspect = import.meta.require("util").inspect;
  var format = require_format();
  var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
  module.exports = format((info, opts = {}) => {
    const stripped = Object.assign({}, info);
    delete stripped[LEVEL];
    delete stripped[MESSAGE];
    delete stripped[SPLAT];
    info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
    return info;
  });
});

// node_modules/logform/printf.js
var require_printf = __commonJS((exports, module) => {
  var { MESSAGE } = require_triple_beam();

  class Printf {
    constructor(templateFn) {
      this.template = templateFn;
    }
    transform(info) {
      info[MESSAGE] = this.template(info);
      return info;
    }
  }
  module.exports = (opts) => new Printf(opts);
  module.exports.Printf = module.exports.Format = Printf;
});

// node_modules/logform/simple.js
var require_simple = __commonJS((exports, module) => {
  var format = require_format();
  var { MESSAGE } = require_triple_beam();
  var jsonStringify = require_safe_stable_stringify();
  module.exports = format((info) => {
    const stringifiedRest = jsonStringify(Object.assign({}, info, {
      level: undefined,
      message: undefined,
      splat: undefined
    }));
    const padding = info.padding && info.padding[info.level] || "";
    if (stringifiedRest !== "{}") {
      info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
    } else {
      info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
    }
    return info;
  });
});

// node_modules/logform/splat.js
var require_splat = __commonJS((exports, module) => {
  var util = import.meta.require("util");
  var { SPLAT } = require_triple_beam();
  var formatRegExp = /%[scdjifoO%]/g;
  var escapedPercent = /%%/g;

  class Splatter {
    constructor(opts) {
      this.options = opts;
    }
    _splat(info, tokens) {
      const msg = info.message;
      const splat = info[SPLAT] || info.splat || [];
      const percents = msg.match(escapedPercent);
      const escapes = percents && percents.length || 0;
      const expectedSplat = tokens.length - escapes;
      const extraSplat = expectedSplat - splat.length;
      const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
      const metalen = metas.length;
      if (metalen) {
        for (let i = 0;i < metalen; i++) {
          Object.assign(info, metas[i]);
        }
      }
      info.message = util.format(msg, ...splat);
      return info;
    }
    transform(info) {
      const msg = info.message;
      const splat = info[SPLAT] || info.splat;
      if (!splat || !splat.length) {
        return info;
      }
      const tokens = msg && msg.match && msg.match(formatRegExp);
      if (!tokens && (splat || splat.length)) {
        const metas = splat.length > 1 ? splat.splice(0) : splat;
        const metalen = metas.length;
        if (metalen) {
          for (let i = 0;i < metalen; i++) {
            Object.assign(info, metas[i]);
          }
        }
        return info;
      }
      if (tokens) {
        return this._splat(info, tokens);
      }
      return info;
    }
  }
  module.exports = (opts) => new Splatter(opts);
});

// node_modules/fecha/lib/fecha.umd.js
var require_fecha_umd = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.fecha = {});
  })(exports, function(exports2) {
    var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
    var twoDigitsOptional = "\\d\\d?";
    var twoDigits = "\\d\\d";
    var threeDigits = "\\d{3}";
    var fourDigits = "\\d{4}";
    var word = "[^\\s]+";
    var literal = /\[([^]*?)\]/gm;
    function shorten(arr, sLen) {
      var newArr = [];
      for (var i = 0, len = arr.length;i < len; i++) {
        newArr.push(arr[i].substr(0, sLen));
      }
      return newArr;
    }
    var monthUpdate = function(arrName) {
      return function(v, i18n) {
        var lowerCaseArr = i18n[arrName].map(function(v2) {
          return v2.toLowerCase();
        });
        var index = lowerCaseArr.indexOf(v.toLowerCase());
        if (index > -1) {
          return index;
        }
        return null;
      };
    };
    function assign(origObj) {
      var args = [];
      for (var _i = 1;_i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      for (var _a = 0, args_1 = args;_a < args_1.length; _a++) {
        var obj = args_1[_a];
        for (var key in obj) {
          origObj[key] = obj[key];
        }
      }
      return origObj;
    }
    var dayNames = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ];
    var monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthNamesShort = shorten(monthNames, 3);
    var dayNamesShort = shorten(dayNames, 3);
    var defaultI18n = {
      dayNamesShort,
      dayNames,
      monthNamesShort,
      monthNames,
      amPm: ["am", "pm"],
      DoFn: function(dayOfMonth) {
        return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
      }
    };
    var globalI18n = assign({}, defaultI18n);
    var setGlobalDateI18n = function(i18n) {
      return globalI18n = assign(globalI18n, i18n);
    };
    var regexEscape = function(str) {
      return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
    };
    var pad = function(val, len) {
      if (len === undefined) {
        len = 2;
      }
      val = String(val);
      while (val.length < len) {
        val = "0" + val;
      }
      return val;
    };
    var formatFlags = {
      D: function(dateObj) {
        return String(dateObj.getDate());
      },
      DD: function(dateObj) {
        return pad(dateObj.getDate());
      },
      Do: function(dateObj, i18n) {
        return i18n.DoFn(dateObj.getDate());
      },
      d: function(dateObj) {
        return String(dateObj.getDay());
      },
      dd: function(dateObj) {
        return pad(dateObj.getDay());
      },
      ddd: function(dateObj, i18n) {
        return i18n.dayNamesShort[dateObj.getDay()];
      },
      dddd: function(dateObj, i18n) {
        return i18n.dayNames[dateObj.getDay()];
      },
      M: function(dateObj) {
        return String(dateObj.getMonth() + 1);
      },
      MM: function(dateObj) {
        return pad(dateObj.getMonth() + 1);
      },
      MMM: function(dateObj, i18n) {
        return i18n.monthNamesShort[dateObj.getMonth()];
      },
      MMMM: function(dateObj, i18n) {
        return i18n.monthNames[dateObj.getMonth()];
      },
      YY: function(dateObj) {
        return pad(String(dateObj.getFullYear()), 4).substr(2);
      },
      YYYY: function(dateObj) {
        return pad(dateObj.getFullYear(), 4);
      },
      h: function(dateObj) {
        return String(dateObj.getHours() % 12 || 12);
      },
      hh: function(dateObj) {
        return pad(dateObj.getHours() % 12 || 12);
      },
      H: function(dateObj) {
        return String(dateObj.getHours());
      },
      HH: function(dateObj) {
        return pad(dateObj.getHours());
      },
      m: function(dateObj) {
        return String(dateObj.getMinutes());
      },
      mm: function(dateObj) {
        return pad(dateObj.getMinutes());
      },
      s: function(dateObj) {
        return String(dateObj.getSeconds());
      },
      ss: function(dateObj) {
        return pad(dateObj.getSeconds());
      },
      S: function(dateObj) {
        return String(Math.round(dateObj.getMilliseconds() / 100));
      },
      SS: function(dateObj) {
        return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
      },
      SSS: function(dateObj) {
        return pad(dateObj.getMilliseconds(), 3);
      },
      a: function(dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
      },
      A: function(dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
      },
      ZZ: function(dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
      },
      Z: function(dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
      }
    };
    var monthParse = function(v) {
      return +v - 1;
    };
    var emptyDigits = [null, twoDigitsOptional];
    var emptyWord = [null, word];
    var amPm = [
      "isPm",
      word,
      function(v, i18n) {
        var val = v.toLowerCase();
        if (val === i18n.amPm[0]) {
          return 0;
        } else if (val === i18n.amPm[1]) {
          return 1;
        }
        return null;
      }
    ];
    var timezoneOffset = [
      "timezoneOffset",
      "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
      function(v) {
        var parts = (v + "").match(/([+-]|\d\d)/gi);
        if (parts) {
          var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
          return parts[0] === "+" ? minutes : -minutes;
        }
        return 0;
      }
    ];
    var parseFlags = {
      D: ["day", twoDigitsOptional],
      DD: ["day", twoDigits],
      Do: ["day", twoDigitsOptional + word, function(v) {
        return parseInt(v, 10);
      }],
      M: ["month", twoDigitsOptional, monthParse],
      MM: ["month", twoDigits, monthParse],
      YY: [
        "year",
        twoDigits,
        function(v) {
          var now = new Date;
          var cent = +("" + now.getFullYear()).substr(0, 2);
          return +("" + (+v > 68 ? cent - 1 : cent) + v);
        }
      ],
      h: ["hour", twoDigitsOptional, undefined, "isPm"],
      hh: ["hour", twoDigits, undefined, "isPm"],
      H: ["hour", twoDigitsOptional],
      HH: ["hour", twoDigits],
      m: ["minute", twoDigitsOptional],
      mm: ["minute", twoDigits],
      s: ["second", twoDigitsOptional],
      ss: ["second", twoDigits],
      YYYY: ["year", fourDigits],
      S: ["millisecond", "\\d", function(v) {
        return +v * 100;
      }],
      SS: ["millisecond", twoDigits, function(v) {
        return +v * 10;
      }],
      SSS: ["millisecond", threeDigits],
      d: emptyDigits,
      dd: emptyDigits,
      ddd: emptyWord,
      dddd: emptyWord,
      MMM: ["month", word, monthUpdate("monthNamesShort")],
      MMMM: ["month", word, monthUpdate("monthNames")],
      a: amPm,
      A: amPm,
      ZZ: timezoneOffset,
      Z: timezoneOffset
    };
    var globalMasks = {
      default: "ddd MMM DD YYYY HH:mm:ss",
      shortDate: "M/D/YY",
      mediumDate: "MMM D, YYYY",
      longDate: "MMMM D, YYYY",
      fullDate: "dddd, MMMM D, YYYY",
      isoDate: "YYYY-MM-DD",
      isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
      shortTime: "HH:mm",
      mediumTime: "HH:mm:ss",
      longTime: "HH:mm:ss.SSS"
    };
    var setGlobalDateMasks = function(masks) {
      return assign(globalMasks, masks);
    };
    var format = function(dateObj, mask, i18n) {
      if (mask === undefined) {
        mask = globalMasks["default"];
      }
      if (i18n === undefined) {
        i18n = {};
      }
      if (typeof dateObj === "number") {
        dateObj = new Date(dateObj);
      }
      if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
        throw new Error("Invalid Date pass to format");
      }
      mask = globalMasks[mask] || mask;
      var literals = [];
      mask = mask.replace(literal, function($0, $1) {
        literals.push($1);
        return "@@@";
      });
      var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
      mask = mask.replace(token, function($0) {
        return formatFlags[$0](dateObj, combinedI18nSettings);
      });
      return mask.replace(/@@@/g, function() {
        return literals.shift();
      });
    };
    function parse(dateStr, format2, i18n) {
      if (i18n === undefined) {
        i18n = {};
      }
      if (typeof format2 !== "string") {
        throw new Error("Invalid format in fecha parse");
      }
      format2 = globalMasks[format2] || format2;
      if (dateStr.length > 1000) {
        return null;
      }
      var today = new Date;
      var dateInfo = {
        year: today.getFullYear(),
        month: 0,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0,
        isPm: null,
        timezoneOffset: null
      };
      var parseInfo = [];
      var literals = [];
      var newFormat = format2.replace(literal, function($0, $1) {
        literals.push(regexEscape($1));
        return "@@@";
      });
      var specifiedFields = {};
      var requiredFields = {};
      newFormat = regexEscape(newFormat).replace(token, function($0) {
        var info = parseFlags[$0];
        var field2 = info[0], regex = info[1], requiredField = info[3];
        if (specifiedFields[field2]) {
          throw new Error("Invalid format. " + field2 + " specified twice in format");
        }
        specifiedFields[field2] = true;
        if (requiredField) {
          requiredFields[requiredField] = true;
        }
        parseInfo.push(info);
        return "(" + regex + ")";
      });
      Object.keys(requiredFields).forEach(function(field2) {
        if (!specifiedFields[field2]) {
          throw new Error("Invalid format. " + field2 + " is required in specified format");
        }
      });
      newFormat = newFormat.replace(/@@@/g, function() {
        return literals.shift();
      });
      var matches = dateStr.match(new RegExp(newFormat, "i"));
      if (!matches) {
        return null;
      }
      var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
      for (var i = 1;i < matches.length; i++) {
        var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
        var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
        if (value == null) {
          return null;
        }
        dateInfo[field] = value;
      }
      if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
        dateInfo.hour = +dateInfo.hour + 12;
      } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
        dateInfo.hour = 0;
      }
      var dateTZ;
      if (dateInfo.timezoneOffset == null) {
        dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
        var validateFields = [
          ["month", "getMonth"],
          ["day", "getDate"],
          ["hour", "getHours"],
          ["minute", "getMinutes"],
          ["second", "getSeconds"]
        ];
        for (var i = 0, len = validateFields.length;i < len; i++) {
          if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
            return null;
          }
        }
      } else {
        dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
        if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
          return null;
        }
      }
      return dateTZ;
    }
    var fecha = {
      format,
      parse,
      defaultI18n,
      setGlobalDateI18n,
      setGlobalDateMasks
    };
    exports2.assign = assign;
    exports2.default = fecha;
    exports2.format = format;
    exports2.parse = parse;
    exports2.defaultI18n = defaultI18n;
    exports2.setGlobalDateI18n = setGlobalDateI18n;
    exports2.setGlobalDateMasks = setGlobalDateMasks;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/logform/timestamp.js
var require_timestamp = __commonJS((exports, module) => {
  var fecha = require_fecha_umd();
  var format = require_format();
  module.exports = format((info, opts = {}) => {
    if (opts.format) {
      info.timestamp = typeof opts.format === "function" ? opts.format() : fecha.format(new Date, opts.format);
    }
    if (!info.timestamp) {
      info.timestamp = new Date().toISOString();
    }
    if (opts.alias) {
      info[opts.alias] = info.timestamp;
    }
    return info;
  });
});

// node_modules/logform/uncolorize.js
var require_uncolorize = __commonJS((exports, module) => {
  var colors = require_safe();
  var format = require_format();
  var { MESSAGE } = require_triple_beam();
  module.exports = format((info, opts) => {
    if (opts.level !== false) {
      info.level = colors.strip(info.level);
    }
    if (opts.message !== false) {
      info.message = colors.strip(String(info.message));
    }
    if (opts.raw !== false && info[MESSAGE]) {
      info[MESSAGE] = colors.strip(String(info[MESSAGE]));
    }
    return info;
  });
});

// node_modules/logform/index.js
var require_logform = __commonJS((exports) => {
  var exposeFormat = function(name, requireFormat) {
    Object.defineProperty(format, name, {
      get() {
        return requireFormat();
      },
      configurable: true
    });
  };
  var format = exports.format = require_format();
  exports.levels = require_levels();
  exposeFormat("align", function() {
    return require_align();
  });
  exposeFormat("errors", function() {
    return require_errors();
  });
  exposeFormat("cli", function() {
    return require_cli2();
  });
  exposeFormat("combine", function() {
    return require_combine();
  });
  exposeFormat("colorize", function() {
    return require_colorize();
  });
  exposeFormat("json", function() {
    return require_json();
  });
  exposeFormat("label", function() {
    return require_label();
  });
  exposeFormat("logstash", function() {
    return require_logstash();
  });
  exposeFormat("metadata", function() {
    return require_metadata();
  });
  exposeFormat("ms", function() {
    return require_ms2();
  });
  exposeFormat("padLevels", function() {
    return require_pad_levels();
  });
  exposeFormat("prettyPrint", function() {
    return require_pretty_print();
  });
  exposeFormat("printf", function() {
    return require_printf();
  });
  exposeFormat("simple", function() {
    return require_simple();
  });
  exposeFormat("splat", function() {
    return require_splat();
  });
  exposeFormat("timestamp", function() {
    return require_timestamp();
  });
  exposeFormat("uncolorize", function() {
    return require_uncolorize();
  });
});

// node_modules/winston/lib/winston/common.js
var require_common = __commonJS((exports) => {
  var { format } = import.meta.require("util");
  exports.warn = {
    deprecated(prop) {
      return () => {
        throw new Error(format("{ %s } was removed in winston@3.0.0.", prop));
      };
    },
    useFormat(prop) {
      return () => {
        throw new Error([
          format("{ %s } was removed in winston@3.0.0.", prop),
          "Use a custom winston.format = winston.format(function) instead."
        ].join("\n"));
      };
    },
    forFunctions(obj, type, props) {
      props.forEach((prop) => {
        obj[prop] = exports.warn[type](prop);
      });
    },
    forProperties(obj, type, props) {
      props.forEach((prop) => {
        const notice = exports.warn[type](prop);
        Object.defineProperty(obj, prop, {
          get: notice,
          set: notice
        });
      });
    }
  };
});

// node_modules/winston/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "winston",
    description: "A logger for just about everything.",
    version: "3.12.0",
    author: "Charlie Robbins <charlie.robbins@gmail.com>",
    maintainers: [
      "David Hyde <dabh@alumni.stanford.edu>"
    ],
    repository: {
      type: "git",
      url: "https://github.com/winstonjs/winston.git"
    },
    keywords: [
      "winston",
      "logger",
      "logging",
      "logs",
      "sysadmin",
      "bunyan",
      "pino",
      "loglevel",
      "tools",
      "json",
      "stream"
    ],
    dependencies: {
      "@dabh/diagnostics": "^2.0.2",
      "@colors/colors": "^1.6.0",
      async: "^3.2.3",
      "is-stream": "^2.0.0",
      logform: "^2.4.0",
      "one-time": "^1.0.0",
      "readable-stream": "^3.4.0",
      "safe-stable-stringify": "^2.3.1",
      "stack-trace": "0.0.x",
      "triple-beam": "^1.3.0",
      "winston-transport": "^4.7.0"
    },
    devDependencies: {
      "@babel/cli": "^7.23.9",
      "@babel/core": "^7.24.0",
      "@babel/preset-env": "^7.24.0",
      "@dabh/eslint-config-populist": "^5.0.0",
      "@types/node": "^20.11.24",
      "abstract-winston-transport": "^0.5.1",
      assume: "^2.2.0",
      "cross-spawn-async": "^2.2.5",
      eslint: "^8.57.0",
      hock: "^1.4.1",
      mocha: "^10.3.0",
      nyc: "^15.1.0",
      rimraf: "^5.0.5",
      split2: "^4.1.0",
      "std-mocks": "^2.0.0",
      through2: "^4.0.2",
      "winston-compat": "^0.1.5"
    },
    main: "./lib/winston.js",
    browser: "./dist/winston",
    types: "./index.d.ts",
    scripts: {
      lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
      test: "rimraf test/fixtures/logs/* && mocha",
      "test:coverage": "nyc npm run test:unit",
      "test:unit": "mocha test/unit",
      "test:integration": "mocha test/integration",
      build: "rimraf dist && babel lib -d dist",
      prepublishOnly: "npm run build"
    },
    engines: {
      node: ">= 12.0.0"
    },
    license: "MIT"
  };
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var copyProps = function(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  };
  var SafeBuffer = function(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  };
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = import.meta.require("buffer");
  var Buffer2 = buffer.Buffer;
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS((exports) => {
  var _normalizeEncoding = function(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  };
  var normalizeEncoding = function(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  };
  var StringDecoder = function(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  };
  var utf8CheckByte = function(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  };
  var utf8CheckIncomplete = function(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  };
  var utf8CheckExtraBytes = function(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "\uFFFD";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "\uFFFD";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "\uFFFD";
        }
      }
    }
  };
  var utf8FillLast = function(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  var utf8Text = function(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  };
  var utf8End = function(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "\uFFFD";
    return r;
  };
  var utf16Text = function(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  };
  var utf16End = function(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  };
  var base64Text = function(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  };
  var base64End = function(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  };
  var simpleWrite = function(buf) {
    return buf.toString(this.encoding);
  };
  var simpleEnd = function(buf) {
    return buf && buf.length ? this.write(buf) : "";
  };
  var Buffer2 = require_safe_buffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  exports.StringDecoder = StringDecoder;
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports, module) => {
  var ownKeys = function(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  };
  var _objectSpread = function(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  };
  var _defineProperty = function(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  var _classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var _defineProperties = function(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  };
  var _createClass = function(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  };
  var _toPropertyKey = function(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  };
  var _toPrimitive = function(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  };
  var copyBuffer = function(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  };
  var _require = import.meta.require("buffer");
  var Buffer2 = _require.Buffer;
  var _require2 = import.meta.require("util");
  var inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  module.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next)
          ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports, module) => {
  var destroy = function(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  };
  var emitErrorAndCloseNT = function(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  };
  var emitCloseNT = function(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  };
  var undestroy = function() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  };
  var emitErrorNT = function(self2, err) {
    self2.emit("error", err);
  };
  var errorOrDestroy = function(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  };
  module.exports = {
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/readable-stream/errors.js
var require_errors2 = __commonJS((exports, module) => {
  var createErrorType = function(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }

    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  };
  var oneOf = function(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  };
  var startsWith = function(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  };
  var endsWith = function(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  };
  var includes = function(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  };
  var codes = {};
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports.codes = codes;
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS((exports, module) => {
  var highWaterMarkFrom = function(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  };
  var getHighWaterMark = function(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  };
  var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
  module.exports = {
    getHighWaterMark
  };
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    util = import.meta.require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module.exports = util.inherits;
  } catch (e) {
    module.exports = require_inherits_browser();
  }
  var util;
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports, module) => {
  var once = function(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  };
  var noop = function() {
  };
  var isRequest = function(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  };
  var eos = function(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE;
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  };
  var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
  module.exports = eos;
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS((exports, module) => {
  var _defineProperty = function(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  var _toPropertyKey = function(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  };
  var _toPrimitive = function(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  };
  var createIterResult = function(value, done) {
    return {
      value,
      done
    };
  };
  var readAndResolve = function(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  };
  var onReadable = function(iter) {
    process.nextTick(readAndResolve, iter);
  };
  var wrapForNext = function(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(undefined, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  };
  var _Object$setPrototypeO;
  var finished = require_end_of_stream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(undefined, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(undefined, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  module.exports = createReadableStreamAsyncIterator;
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS((exports, module) => {
  var asyncGeneratorStep = function(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  };
  var _asyncToGenerator = function(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  };
  var ownKeys = function(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  };
  var _objectSpread = function(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  };
  var _defineProperty = function(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  var _toPropertyKey = function(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  };
  var _toPrimitive = function(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  };
  var from = function(Readable, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") {
      iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator])
      iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator])
      iterator = iterable[Symbol.iterator]();
    else
      throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable = new Readable(_objectSpread({
      objectMode: true
    }, opts));
    var reading = false;
    readable._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
          if (done) {
            readable.push(null);
          } else if (readable.push(yield value)) {
            next();
          } else {
            reading = false;
          }
        } catch (err) {
          readable.destroy(err);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable;
  };
  var ERR_INVALID_ARG_TYPE = require_errors2().codes.ERR_INVALID_ARG_TYPE;
  module.exports = from;
});

// node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable = __commonJS((exports, module) => {
  var _uint8ArrayToBuffer = function(chunk) {
    return Buffer2.from(chunk);
  };
  var _isUint8Array = function(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  };
  var prependListener = function(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  };
  var ReadableState = function(options, stream, isDuplex) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  };
  var Readable = function(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  };
  var readableAddChunk = function(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  };
  var addChunk = function(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  };
  var chunkInvalid = function(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  };
  var computeNewHighWaterMark = function(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  };
  var howMuchToRead = function(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  };
  var onEofChunk = function(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  };
  var emitReadable = function(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  };
  var emitReadable_ = function(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  };
  var maybeReadMore = function(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  };
  var maybeReadMore_ = function(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  };
  var pipeOnDrain = function(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  };
  var updateReadableListening = function(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  };
  var nReadingNextTick = function(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  };
  var resume = function(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  };
  var resume_ = function(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  };
  var flow = function(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null)
      ;
  };
  var fromList = function(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  };
  var endReadable = function(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  };
  var endReadableNT = function(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  };
  var indexOf = function(xs, x) {
    for (var i = 0, l = xs.length;i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  };
  module.exports = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = import.meta.require("events").EventEmitter;
  var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = import.meta.require("stream");
  var Buffer2 = import.meta.require("buffer").Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  var debugUtil = import.meta.require("util");
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug() {
    };
  }
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors2().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  require_inherits()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++)
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === undefined) {
        createReadableStreamAsyncIterator = require_async_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === undefined) {
        from = require_from();
      }
      return from(Readable, iterable, opts);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex = __commonJS((exports, module) => {
  var Duplex = function(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  };
  var onend = function() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  };
  var onEndNT = function(self2) {
    self2.end();
  };
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj)
      keys2.push(key);
    return keys2;
  };
  module.exports = Duplex;
  var Readable = require__stream_readable();
  var Writable = require__stream_writable();
  require_inherits()(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  Object.defineProperty(Duplex.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS((exports, module) => {
  module.exports = import.meta.require("util").deprecate;
});

// node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable = __commonJS((exports, module) => {
  var CorkedRequest = function(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  };
  var _uint8ArrayToBuffer = function(chunk) {
    return Buffer2.from(chunk);
  };
  var _isUint8Array = function(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  };
  var nop = function() {
  };
  var WritableState = function(options, stream, isDuplex) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  };
  var Writable = function(options) {
    Duplex = Duplex || require__stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  };
  var writeAfterEnd = function(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END;
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
  };
  var validChunk = function(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES;
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  };
  var decodeChunk = function(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  };
  var writeOrBuffer = function(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  };
  var doWrite = function(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  };
  var onwriteError = function(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  };
  var onwriteStateUpdate = function(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  };
  var onwrite = function(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state) || stream.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  };
  var afterWrite = function(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  };
  var onwriteDrain = function(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  };
  var clearBuffer = function(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  };
  var needFinish = function(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  };
  var callFinal = function(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  };
  var prefinish = function(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  };
  var finishMaybe = function(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  };
  var endWritable = function(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  };
  var onCorkedFinish = function(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  };
  module.exports = Writable;
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: require_node()
  };
  var Stream = import.meta.require("stream");
  var Buffer2 = import.meta.require("buffer").Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors2().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
  var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
  var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  require_inherits()(Writable, Stream);
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance(object) {
      return object instanceof this;
    };
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
});

// node_modules/winston-transport/modern.js
var require_modern = __commonJS((exports, module) => {
  var util = import.meta.require("util");
  var Writable = require__stream_writable();
  var { LEVEL } = require_triple_beam();
  var TransportStream = module.exports = function TransportStream(options = {}) {
    Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
    this.format = options.format;
    this.level = options.level;
    this.handleExceptions = options.handleExceptions;
    this.handleRejections = options.handleRejections;
    this.silent = options.silent;
    if (options.log)
      this.log = options.log;
    if (options.logv)
      this.logv = options.logv;
    if (options.close)
      this.close = options.close;
    this.once("pipe", (logger) => {
      this.levels = logger.levels;
      this.parent = logger;
    });
    this.once("unpipe", (src) => {
      if (src === this.parent) {
        this.parent = null;
        if (this.close) {
          this.close();
        }
      }
    });
  };
  util.inherits(TransportStream, Writable);
  TransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
      return callback(null);
    }
    const level = this.level || this.parent && this.parent.level;
    if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
      if (info && !this.format) {
        return this.log(info, callback);
      }
      let errState;
      let transformed;
      try {
        transformed = this.format.transform(Object.assign({}, info), this.format.options);
      } catch (err) {
        errState = err;
      }
      if (errState || !transformed) {
        callback();
        if (errState)
          throw errState;
        return;
      }
      return this.log(transformed, callback);
    }
    this._writableState.sync = false;
    return callback(null);
  };
  TransportStream.prototype._writev = function _writev(chunks, callback) {
    if (this.logv) {
      const infos = chunks.filter(this._accept, this);
      if (!infos.length) {
        return callback(null);
      }
      return this.logv(infos, callback);
    }
    for (let i = 0;i < chunks.length; i++) {
      if (!this._accept(chunks[i]))
        continue;
      if (chunks[i].chunk && !this.format) {
        this.log(chunks[i].chunk, chunks[i].callback);
        continue;
      }
      let errState;
      let transformed;
      try {
        transformed = this.format.transform(Object.assign({}, chunks[i].chunk), this.format.options);
      } catch (err) {
        errState = err;
      }
      if (errState || !transformed) {
        chunks[i].callback();
        if (errState) {
          callback(null);
          throw errState;
        }
      } else {
        this.log(transformed, chunks[i].callback);
      }
    }
    return callback(null);
  };
  TransportStream.prototype._accept = function _accept(write) {
    const info = write.chunk;
    if (this.silent) {
      return false;
    }
    const level = this.level || this.parent && this.parent.level;
    if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
      if (this.handleExceptions || info.exception !== true) {
        return true;
      }
    }
    return false;
  };
  TransportStream.prototype._nop = function _nop() {
    return;
  };
});

// node_modules/winston-transport/legacy.js
var require_legacy = __commonJS((exports, module) => {
  var util = import.meta.require("util");
  var { LEVEL } = require_triple_beam();
  var TransportStream = require_modern();
  var LegacyTransportStream = module.exports = function LegacyTransportStream(options = {}) {
    TransportStream.call(this, options);
    if (!options.transport || typeof options.transport.log !== "function") {
      throw new Error("Invalid transport, must be an object with a log method.");
    }
    this.transport = options.transport;
    this.level = this.level || options.transport.level;
    this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
    this._deprecated();
    function transportError(err) {
      this.emit("error", err, this.transport);
    }
    if (!this.transport.__winstonError) {
      this.transport.__winstonError = transportError.bind(this);
      this.transport.on("error", this.transport.__winstonError);
    }
  };
  util.inherits(LegacyTransportStream, TransportStream);
  LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
    if (this.silent || info.exception === true && !this.handleExceptions) {
      return callback(null);
    }
    if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
      this.transport.log(info[LEVEL], info.message, info, this._nop);
    }
    callback(null);
  };
  LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
    for (let i = 0;i < chunks.length; i++) {
      if (this._accept(chunks[i])) {
        this.transport.log(chunks[i].chunk[LEVEL], chunks[i].chunk.message, chunks[i].chunk, this._nop);
        chunks[i].callback();
      }
    }
    return callback(null);
  };
  LegacyTransportStream.prototype._deprecated = function _deprecated() {
    console.error([
      `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
      "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
    ].join("\n"));
  };
  LegacyTransportStream.prototype.close = function close() {
    if (this.transport.close) {
      this.transport.close();
    }
    if (this.transport.__winstonError) {
      this.transport.removeListener("error", this.transport.__winstonError);
      this.transport.__winstonError = null;
    }
  };
});

// node_modules/winston-transport/index.js
var require_winston_transport = __commonJS((exports, module) => {
  module.exports = require_modern();
  module.exports.LegacyTransportStream = require_legacy();
});

// node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS((exports, module) => {
  var os = import.meta.require("os");
  var { LEVEL, MESSAGE } = require_triple_beam();
  var TransportStream = require_winston_transport();
  module.exports = class Console extends TransportStream {
    constructor(options = {}) {
      super(options);
      this.name = options.name || "console";
      this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
      this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
      this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      this.setMaxListeners(30);
    }
    log(info, callback) {
      setImmediate(() => this.emit("logged", info));
      if (this.stderrLevels[info[LEVEL]]) {
        if (console._stderr) {
          console._stderr.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          console.error(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
        return;
      } else if (this.consoleWarnLevels[info[LEVEL]]) {
        if (console._stderr) {
          console._stderr.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          console.warn(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
        return;
      }
      if (console._stdout) {
        console._stdout.write(`${info[MESSAGE]}${this.eol}`);
      } else {
        console.log(info[MESSAGE]);
      }
      if (callback) {
        callback();
      }
    }
    _stringArrayToSet(strArray, errMsg) {
      if (!strArray)
        return {};
      errMsg = errMsg || "Cannot make set from type other than Array of string elements";
      if (!Array.isArray(strArray)) {
        throw new Error(errMsg);
      }
      return strArray.reduce((set, el) => {
        if (typeof el !== "string") {
          throw new Error(errMsg);
        }
        set[el] = true;
        return set;
      }, {});
    }
  };
});

// node_modules/async/internal/isArrayLike.js
var require_isArrayLike = __commonJS((exports, module) => {
  var isArrayLike = function(value) {
    return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isArrayLike;
  module.exports = exports.default;
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(fn) {
    return function(...args) {
      var callback = args.pop();
      return fn.call(this, args, callback);
    };
  };
  module.exports = exports.default;
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS((exports) => {
  var fallback = function(fn) {
    setTimeout(fn, 0);
  };
  var wrap = function(defer) {
    return (fn, ...args) => defer(() => fn(...args));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.fallback = fallback;
  exports.wrap = wrap;
  var hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
  var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
  var hasNextTick = exports.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
  var _defer;
  if (hasQueueMicrotask) {
    _defer = queueMicrotask;
  } else if (hasSetImmediate) {
    _defer = setImmediate;
  } else if (hasNextTick) {
    _defer = process.nextTick;
  } else {
    _defer = fallback;
  }
  exports.default = wrap(_defer);
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var asyncify = function(func) {
    if ((0, _wrapAsync.isAsync)(func)) {
      return function(...args) {
        const callback = args.pop();
        const promise = func.apply(this, args);
        return handlePromise(promise, callback);
      };
    }
    return (0, _initialParams2.default)(function(args, callback) {
      var result;
      try {
        result = func.apply(this, args);
      } catch (e) {
        return callback(e);
      }
      if (result && typeof result.then === "function") {
        return handlePromise(result, callback);
      } else {
        callback(null, result);
      }
    });
  };
  var handlePromise = function(promise, callback) {
    return promise.then((value) => {
      invokeCallback(callback, null, value);
    }, (err) => {
      invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
    });
  };
  var invokeCallback = function(callback, error, value) {
    try {
      callback(error, value);
    } catch (err) {
      (0, _setImmediate2.default)((e) => {
        throw e;
      }, err);
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = asyncify;
  var _initialParams = require_initialParams();
  var _initialParams2 = _interopRequireDefault(_initialParams);
  var _setImmediate = require_setImmediate();
  var _setImmediate2 = _interopRequireDefault(_setImmediate);
  var _wrapAsync = require_wrapAsync();
  module.exports = exports.default;
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isAsync = function(fn) {
    return fn[Symbol.toStringTag] === "AsyncFunction";
  };
  var isAsyncGenerator = function(fn) {
    return fn[Symbol.toStringTag] === "AsyncGenerator";
  };
  var isAsyncIterable = function(obj) {
    return typeof obj[Symbol.asyncIterator] === "function";
  };
  var wrapAsync = function(asyncFn) {
    if (typeof asyncFn !== "function")
      throw new Error("expected a function");
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;
  var _asyncify = require_asyncify();
  var _asyncify2 = _interopRequireDefault(_asyncify);
  exports.default = wrapAsync;
  exports.isAsync = isAsync;
  exports.isAsyncGenerator = isAsyncGenerator;
  exports.isAsyncIterable = isAsyncIterable;
});

// node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS((exports, module) => {
  var awaitify = function(asyncFn, arity) {
    if (!arity)
      arity = asyncFn.length;
    if (!arity)
      throw new Error("arity is undefined");
    function awaitable(...args) {
      if (typeof args[arity - 1] === "function") {
        return asyncFn.apply(this, args);
      }
      return new Promise((resolve, reject) => {
        args[arity - 1] = (err, ...cbArgs) => {
          if (err)
            return reject(err);
          resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
        };
        asyncFn.apply(this, args);
      });
    }
    return awaitable;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = awaitify;
  module.exports = exports.default;
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
    eachfn(tasks, (task, key, taskCb) => {
      (0, _wrapAsync2.default)(task)((err, ...result) => {
        if (result.length < 2) {
          [result] = result;
        }
        results[key] = result;
        taskCb(err);
      });
    }, (err) => callback(err, results));
  }, 3);
  module.exports = exports.default;
});

// node_modules/async/internal/once.js
var require_once = __commonJS((exports, module) => {
  var once = function(fn) {
    function wrapper(...args) {
      if (fn === null)
        return;
      var callFn = fn;
      fn = null;
      callFn.apply(this, args);
    }
    Object.assign(wrapper, fn);
    return wrapper;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = once;
  module.exports = exports.default;
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
  };
  module.exports = exports.default;
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var createArrayIterator = function(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
      return ++i < len ? { value: coll[i], key: i } : null;
    };
  };
  var createES2015Iterator = function(iterator) {
    var i = -1;
    return function next() {
      var item = iterator.next();
      if (item.done)
        return null;
      i++;
      return { value: item.value, key: i };
    };
  };
  var createObjectIterator = function(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i = -1;
    var len = okeys.length;
    return function next() {
      var key = okeys[++i];
      if (key === "__proto__") {
        return next();
      }
      return i < len ? { value: obj[key], key } : null;
    };
  };
  var createIterator = function(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
      return createArrayIterator(coll);
    }
    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createIterator;
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _getIterator = require_getIterator();
  var _getIterator2 = _interopRequireDefault(_getIterator);
  module.exports = exports.default;
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS((exports, module) => {
  var onlyOnce = function(fn) {
    return function(...args) {
      if (fn === null)
        throw new Error("Callback was already called.");
      var callFn = fn;
      fn = null;
      callFn.apply(this, args);
    };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = onlyOnce;
  module.exports = exports.default;
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var breakLoop = {};
  exports.default = breakLoop;
  module.exports = exports.default;
});

// node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var asyncEachOfLimit = function(generator, limit, iteratee, callback) {
    let done = false;
    let canceled = false;
    let awaiting = false;
    let running = 0;
    let idx = 0;
    function replenish() {
      if (running >= limit || awaiting || done)
        return;
      awaiting = true;
      generator.next().then(({ value, done: iterDone }) => {
        if (canceled || done)
          return;
        awaiting = false;
        if (iterDone) {
          done = true;
          if (running <= 0) {
            callback(null);
          }
          return;
        }
        running++;
        iteratee(value, idx, iterateeCallback);
        idx++;
        replenish();
      }).catch(handleError);
    }
    function iterateeCallback(err, result) {
      running -= 1;
      if (canceled)
        return;
      if (err)
        return handleError(err);
      if (err === false) {
        done = true;
        canceled = true;
        return;
      }
      if (result === _breakLoop2.default || done && running <= 0) {
        done = true;
        return callback(null);
      }
      replenish();
    }
    function handleError(err) {
      if (canceled)
        return;
      awaiting = false;
      done = true;
      callback(err);
    }
    replenish();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = asyncEachOfLimit;
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  module.exports = exports.default;
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _once = require_once();
  var _once2 = _interopRequireDefault(_once);
  var _iterator = require_iterator();
  var _iterator2 = _interopRequireDefault(_iterator);
  var _onlyOnce = require_onlyOnce();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync();
  var _asyncEachOfLimit = require_asyncEachOfLimit();
  var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  exports.default = (limit) => {
    return (obj, iteratee, callback) => {
      callback = (0, _once2.default)(callback);
      if (limit <= 0) {
        throw new RangeError("concurrency limit cannot be less than 1");
      }
      if (!obj) {
        return callback(null);
      }
      if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
      }
      if ((0, _wrapAsync.isAsyncIterable)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
      }
      var nextElem = (0, _iterator2.default)(obj);
      var done = false;
      var canceled = false;
      var running = 0;
      var looping = false;
      function iterateeCallback(err, value) {
        if (canceled)
          return;
        running -= 1;
        if (err) {
          done = true;
          callback(err);
        } else if (err === false) {
          done = true;
          canceled = true;
        } else if (value === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        } else if (!looping) {
          replenish();
        }
      }
      function replenish() {
        looping = true;
        while (running < limit && !done) {
          var elem = nextElem();
          if (elem === null) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running += 1;
          iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
        }
        looping = false;
      }
      replenish();
    };
  };
  module.exports = exports.default;
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfLimit = function(coll, limit, iteratee, callback) {
    return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOfLimit2 = require_eachOfLimit();
  var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachOfLimit, 4);
  module.exports = exports.default;
});

// node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfSeries = function(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOfLimit = require_eachOfLimit2();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachOfSeries, 3);
  module.exports = exports.default;
});

// node_modules/async/series.js
var require_series = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var series = function(tasks, callback) {
    return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = series;
  var _parallel2 = require_parallel();
  var _parallel3 = _interopRequireDefault(_parallel2);
  var _eachOfSeries = require_eachOfSeries();
  var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
  module.exports = exports.default;
});

// node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform = __commonJS((exports, module) => {
  var afterTransform = function(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK);
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  };
  var Transform = function(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  };
  var prefinish = function() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  };
  var done = function(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0;
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING;
    return stream.push(null);
  };
  module.exports = Transform;
  var _require$codes = require_errors2().codes;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
  var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require__stream_duplex();
  require_inherits()(Transform, Duplex);
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough = __commonJS((exports, module) => {
  var PassThrough = function(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  };
  module.exports = PassThrough;
  var Transform = require__stream_transform();
  require_inherits()(PassThrough, Transform);
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS((exports, module) => {
  var once = function(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(undefined, arguments);
    };
  };
  var noop = function(err) {
    if (err)
      throw err;
  };
  var isRequest = function(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  };
  var destroyer = function(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === undefined)
      eos = require_end_of_stream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  };
  var call = function(fn) {
    fn();
  };
  var pipe = function(from, to) {
    return from.pipe(to);
  };
  var popCallback = function(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  };
  var pipeline = function() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0;_key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  };
  var eos;
  var _require$codes = require_errors2().codes;
  var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  module.exports = pipeline;
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports, module) => {
  var Stream = import.meta.require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream.Readable;
    Object.assign(module.exports, Stream);
    module.exports.Stream = Stream;
  } else {
    exports = module.exports = require__stream_readable();
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require__stream_writable();
    exports.Duplex = require__stream_duplex();
    exports.Transform = require__stream_transform();
    exports.PassThrough = require__stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS((exports, module) => {
  var use = function(adapter) {
    if (~adapters.indexOf(adapter))
      return false;
    adapters.push(adapter);
    return true;
  };
  var set = function(custom) {
    logger = custom;
  };
  var enabled = function(namespace) {
    var async = [];
    for (var i = 0;i < adapters.length; i++) {
      if (adapters[i].async) {
        async.push(adapters[i]);
        continue;
      }
      if (adapters[i](namespace))
        return true;
    }
    if (!async.length)
      return false;
    return new Promise(function pinky(resolve) {
      Promise.all(async.map(function prebind(fn) {
        return fn(namespace);
      })).then(function resolved(values) {
        resolve(values.some(Boolean));
      });
    });
  };
  var modify = function(fn) {
    if (~modifiers.indexOf(fn))
      return false;
    modifiers.push(fn);
    return true;
  };
  var write = function() {
    logger.apply(logger, arguments);
  };
  var process2 = function(message) {
    for (var i = 0;i < modifiers.length; i++) {
      message = modifiers[i].apply(modifiers[i], arguments);
    }
    return message;
  };
  var introduce = function(fn, options) {
    var has = Object.prototype.hasOwnProperty;
    for (var key in options) {
      if (has.call(options, key)) {
        fn[key] = options[key];
      }
    }
    return fn;
  };
  var nope = function(options) {
    options.enabled = false;
    options.modify = modify;
    options.set = set;
    options.use = use;
    return introduce(function diagnopes() {
      return false;
    }, options);
  };
  var yep = function(options) {
    function diagnostics() {
      var args = Array.prototype.slice.call(arguments, 0);
      write.call(write, options, process2(args, options));
      return true;
    }
    options.enabled = true;
    options.modify = modify;
    options.set = set;
    options.use = use;
    return introduce(diagnostics, options);
  };
  var adapters = [];
  var modifiers = [];
  var logger = function devnull() {
  };
  module.exports = function create(diagnostics) {
    diagnostics.introduce = introduce;
    diagnostics.enabled = enabled;
    diagnostics.process = process2;
    diagnostics.modify = modify;
    diagnostics.write = write;
    diagnostics.nope = nope;
    diagnostics.yep = yep;
    diagnostics.set = set;
    diagnostics.use = use;
    return diagnostics;
  };
});

// node_modules/color-name/index.js
var require_color_name = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS((exports, module) => {
  module.exports = function isArrayish(obj) {
    if (!obj || typeof obj === "string") {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
  };
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS((exports, module) => {
  var isArrayish = require_is_arrayish();
  var concat = Array.prototype.concat;
  var slice = Array.prototype.slice;
  var swizzle = module.exports = function swizzle(args) {
    var results = [];
    for (var i = 0, len = args.length;i < len; i++) {
      var arg = args[i];
      if (isArrayish(arg)) {
        results = concat.call(results, slice.call(arg));
      } else {
        results.push(arg);
      }
    }
    return results;
  };
  swizzle.wrap = function(fn) {
    return function() {
      return fn(swizzle(arguments));
    };
  };
});

// node_modules/color-string/index.js
var require_color_string = __commonJS((exports, module) => {
  var clamp = function(num, min, max) {
    return Math.min(Math.max(min, num), max);
  };
  var hexDouble = function(num) {
    var str = Math.round(num).toString(16).toUpperCase();
    return str.length < 2 ? "0" + str : str;
  };
  var colorNames = require_color_name();
  var swizzle = require_simple_swizzle();
  var hasOwnProperty = Object.hasOwnProperty;
  var reverseNames = Object.create(null);
  for (name in colorNames) {
    if (hasOwnProperty.call(colorNames, name)) {
      reverseNames[colorNames[name]] = name;
    }
  }
  var name;
  var cs = module.exports = {
    to: {},
    get: {}
  };
  cs.get = function(string) {
    var prefix = string.substring(0, 3).toLowerCase();
    var val;
    var model;
    switch (prefix) {
      case "hsl":
        val = cs.get.hsl(string);
        model = "hsl";
        break;
      case "hwb":
        val = cs.get.hwb(string);
        model = "hwb";
        break;
      default:
        val = cs.get.rgb(string);
        model = "rgb";
        break;
    }
    if (!val) {
      return null;
    }
    return { model, value: val };
  };
  cs.get.rgb = function(string) {
    if (!string) {
      return null;
    }
    var abbr = /^#([a-f0-9]{3,4})$/i;
    var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var keyword = /^(\w+)$/;
    var rgb = [0, 0, 0, 1];
    var match;
    var i;
    var hexAlpha;
    if (match = string.match(hex)) {
      hexAlpha = match[2];
      match = match[1];
      for (i = 0;i < 3; i++) {
        var i2 = i * 2;
        rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha, 16) / 255;
      }
    } else if (match = string.match(abbr)) {
      match = match[1];
      hexAlpha = match[3];
      for (i = 0;i < 3; i++) {
        rgb[i] = parseInt(match[i] + match[i], 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match = string.match(rgba)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = parseInt(match[i + 1], 0);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(per)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(keyword)) {
      if (match[1] === "transparent") {
        return [0, 0, 0, 0];
      }
      if (!hasOwnProperty.call(colorNames, match[1])) {
        return null;
      }
      rgb = colorNames[match[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }
    for (i = 0;i < 3; i++) {
      rgb[i] = clamp(rgb[i], 0, 255);
    }
    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };
  cs.get.hsl = function(string) {
    if (!string) {
      return null;
    }
    var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hsl);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var s = clamp(parseFloat(match[2]), 0, 100);
      var l = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
    }
    return null;
  };
  cs.get.hwb = function(string) {
    if (!string) {
      return null;
    }
    var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hwb);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var w = clamp(parseFloat(match[2]), 0, 100);
      var b = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
    }
    return null;
  };
  cs.to.hex = function() {
    var rgba = swizzle(arguments);
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
  };
  cs.to.rgb = function() {
    var rgba = swizzle(arguments);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
  };
  cs.to.rgb.percent = function() {
    var rgba = swizzle(arguments);
    var r = Math.round(rgba[0] / 255 * 100);
    var g = Math.round(rgba[1] / 255 * 100);
    var b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
  };
  cs.to.hsl = function() {
    var hsla = swizzle(arguments);
    return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
  };
  cs.to.hwb = function() {
    var hwba = swizzle(arguments);
    var a = "";
    if (hwba.length >= 4 && hwba[3] !== 1) {
      a = ", " + hwba[3];
    }
    return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
  };
  cs.to.keyword = function(rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports, module) => {
  var comparativeDistance = function(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  };
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (key in cssKeywords) {
    if (cssKeywords.hasOwnProperty(key)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
  }
  var key;
  var convert = module.exports = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  for (model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      channels = convert[model].channels;
      labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
  }
  var channels;
  var labels;
  var model;
  convert.rgb.hsl = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h;
    var s;
    var l;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);
    var diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h = convert.rgb.hsl(rgb)[0];
    var w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m;
    var y;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  convert.rgb.keyword = function(rgb) {
    var reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    var currentClosestDistance = Infinity;
    var currentClosestKeyword;
    for (var keyword in cssKeywords) {
      if (cssKeywords.hasOwnProperty(keyword)) {
        var value = cssKeywords[keyword];
        var distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    var h = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (var i = 0;i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    var h = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    var h = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h) % 6;
    var f = h - Math.floor(h);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    var h = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s) * v;
    lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    var h = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    n = wh + f * (v - wh);
    var r;
    var g;
    var b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z2 = Math.pow(z, 3);
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h;
    var c;
    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    var l = lch[0];
    var c = lch[1];
    var h = lch[2];
    var a;
    var b;
    var hr;
    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    var color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    var colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join("");
    }
    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 255;
    var g = integer >> 8 & 255;
    var b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max - min;
    var grayscale;
    var hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;
    if (l < 0.5) {
      c = 2 * s * l;
    } else {
      c = 2 * s * (1 - l);
    }
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    var h = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    var pure = [0, 0, 0];
    var hi = h % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    var f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1 - c) + 0.5 * c;
    var s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = convert.gray.hsv = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    var val = Math.round(gray[0] / 100 * 255) & 255;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// node_modules/color-convert/route.js
var require_route = __commonJS((exports, module) => {
  var buildGraph = function() {
    var graph = {};
    var models = Object.keys(conversions);
    for (var len = models.length, i = 0;i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  };
  var deriveBFS = function(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);
      for (var len = adjacents.length, i = 0;i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  };
  var link = function(from, to) {
    return function(args) {
      return to(from(args));
    };
  };
  var wrapConversion = function(toModel, graph) {
    var path = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  };
  var conversions = require_conversions();
  module.exports = function(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);
    for (var len = models.length, i = 0;i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports, module) => {
  var wrapRaw = function(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var wrapRounded = function(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      var result = fn(args);
      if (typeof result === "object") {
        for (var len = result.length, i = 0;i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  };
  var conversions = require_conversions();
  var route = require_route();
  var convert = {};
  var models = Object.keys(conversions);
  models.forEach(function(fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
    Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function(toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert;
});

// node_modules/color/index.js
var require_color = __commonJS((exports, module) => {
  var Color = function(obj, model) {
    if (!(this instanceof Color)) {
      return new Color(obj, model);
    }
    if (model && model in skippedModels) {
      model = null;
    }
    if (model && !(model in convert)) {
      throw new Error("Unknown model: " + model);
    }
    var i;
    var channels;
    if (obj == null) {
      this.model = "rgb";
      this.color = [0, 0, 0];
      this.valpha = 1;
    } else if (obj instanceof Color) {
      this.model = obj.model;
      this.color = obj.color.slice();
      this.valpha = obj.valpha;
    } else if (typeof obj === "string") {
      var result = colorString.get(obj);
      if (result === null) {
        throw new Error("Unable to parse color from string: " + obj);
      }
      this.model = result.model;
      channels = convert[this.model].channels;
      this.color = result.value.slice(0, channels);
      this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
    } else if (obj.length) {
      this.model = model || "rgb";
      channels = convert[this.model].channels;
      var newArr = _slice.call(obj, 0, channels);
      this.color = zeroArray(newArr, channels);
      this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
    } else if (typeof obj === "number") {
      obj &= 16777215;
      this.model = "rgb";
      this.color = [
        obj >> 16 & 255,
        obj >> 8 & 255,
        obj & 255
      ];
      this.valpha = 1;
    } else {
      this.valpha = 1;
      var keys = Object.keys(obj);
      if ("alpha" in obj) {
        keys.splice(keys.indexOf("alpha"), 1);
        this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
      }
      var hashedKeys = keys.sort().join("");
      if (!(hashedKeys in hashedModelKeys)) {
        throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
      }
      this.model = hashedModelKeys[hashedKeys];
      var labels = convert[this.model].labels;
      var color = [];
      for (i = 0;i < labels.length; i++) {
        color.push(obj[labels[i]]);
      }
      this.color = zeroArray(color);
    }
    if (limiters[this.model]) {
      channels = convert[this.model].channels;
      for (i = 0;i < channels; i++) {
        var limit = limiters[this.model][i];
        if (limit) {
          this.color[i] = limit(this.color[i]);
        }
      }
    }
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    if (Object.freeze) {
      Object.freeze(this);
    }
  };
  var roundTo = function(num, places) {
    return Number(num.toFixed(places));
  };
  var roundToPlace = function(places) {
    return function(num) {
      return roundTo(num, places);
    };
  };
  var getset = function(model, channel, modifier) {
    model = Array.isArray(model) ? model : [model];
    model.forEach(function(m) {
      (limiters[m] || (limiters[m] = []))[channel] = modifier;
    });
    model = model[0];
    return function(val) {
      var result;
      if (arguments.length) {
        if (modifier) {
          val = modifier(val);
        }
        result = this[model]();
        result.color[channel] = val;
        return result;
      }
      result = this[model]().color[channel];
      if (modifier) {
        result = modifier(result);
      }
      return result;
    };
  };
  var maxfn = function(max) {
    return function(v) {
      return Math.max(0, Math.min(max, v));
    };
  };
  var assertArray = function(val) {
    return Array.isArray(val) ? val : [val];
  };
  var zeroArray = function(arr, length) {
    for (var i = 0;i < length; i++) {
      if (typeof arr[i] !== "number") {
        arr[i] = 0;
      }
    }
    return arr;
  };
  var colorString = require_color_string();
  var convert = require_color_convert();
  var _slice = [].slice;
  var skippedModels = [
    "keyword",
    "gray",
    "hex"
  ];
  var hashedModelKeys = {};
  Object.keys(convert).forEach(function(model) {
    hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
  });
  var limiters = {};
  Color.prototype = {
    toString: function() {
      return this.string();
    },
    toJSON: function() {
      return this[this.model]();
    },
    string: function(places) {
      var self2 = this.model in colorString.to ? this : this.rgb();
      self2 = self2.round(typeof places === "number" ? places : 1);
      var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
      return colorString.to[self2.model](args);
    },
    percentString: function(places) {
      var self2 = this.rgb().round(typeof places === "number" ? places : 1);
      var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
      return colorString.to.rgb.percent(args);
    },
    array: function() {
      return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
    },
    object: function() {
      var result = {};
      var channels = convert[this.model].channels;
      var labels = convert[this.model].labels;
      for (var i = 0;i < channels; i++) {
        result[labels[i]] = this.color[i];
      }
      if (this.valpha !== 1) {
        result.alpha = this.valpha;
      }
      return result;
    },
    unitArray: function() {
      var rgb = this.rgb().color;
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;
      if (this.valpha !== 1) {
        rgb.push(this.valpha);
      }
      return rgb;
    },
    unitObject: function() {
      var rgb = this.rgb().object();
      rgb.r /= 255;
      rgb.g /= 255;
      rgb.b /= 255;
      if (this.valpha !== 1) {
        rgb.alpha = this.valpha;
      }
      return rgb;
    },
    round: function(places) {
      places = Math.max(places || 0, 0);
      return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
    },
    alpha: function(val) {
      if (arguments.length) {
        return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
      }
      return this.valpha;
    },
    red: getset("rgb", 0, maxfn(255)),
    green: getset("rgb", 1, maxfn(255)),
    blue: getset("rgb", 2, maxfn(255)),
    hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
      return (val % 360 + 360) % 360;
    }),
    saturationl: getset("hsl", 1, maxfn(100)),
    lightness: getset("hsl", 2, maxfn(100)),
    saturationv: getset("hsv", 1, maxfn(100)),
    value: getset("hsv", 2, maxfn(100)),
    chroma: getset("hcg", 1, maxfn(100)),
    gray: getset("hcg", 2, maxfn(100)),
    white: getset("hwb", 1, maxfn(100)),
    wblack: getset("hwb", 2, maxfn(100)),
    cyan: getset("cmyk", 0, maxfn(100)),
    magenta: getset("cmyk", 1, maxfn(100)),
    yellow: getset("cmyk", 2, maxfn(100)),
    black: getset("cmyk", 3, maxfn(100)),
    x: getset("xyz", 0, maxfn(100)),
    y: getset("xyz", 1, maxfn(100)),
    z: getset("xyz", 2, maxfn(100)),
    l: getset("lab", 0, maxfn(100)),
    a: getset("lab", 1),
    b: getset("lab", 2),
    keyword: function(val) {
      if (arguments.length) {
        return new Color(val);
      }
      return convert[this.model].keyword(this.color);
    },
    hex: function(val) {
      if (arguments.length) {
        return new Color(val);
      }
      return colorString.to.hex(this.rgb().round().color);
    },
    rgbNumber: function() {
      var rgb = this.rgb().color;
      return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
    },
    luminosity: function() {
      var rgb = this.rgb().color;
      var lum = [];
      for (var i = 0;i < rgb.length; i++) {
        var chan = rgb[i] / 255;
        lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast: function(color2) {
      var lum1 = this.luminosity();
      var lum2 = color2.luminosity();
      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }
      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level: function(color2) {
      var contrastRatio = this.contrast(color2);
      if (contrastRatio >= 7.1) {
        return "AAA";
      }
      return contrastRatio >= 4.5 ? "AA" : "";
    },
    isDark: function() {
      var rgb = this.rgb().color;
      var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
      return yiq < 128;
    },
    isLight: function() {
      return !this.isDark();
    },
    negate: function() {
      var rgb = this.rgb();
      for (var i = 0;i < 3; i++) {
        rgb.color[i] = 255 - rgb.color[i];
      }
      return rgb;
    },
    lighten: function(ratio) {
      var hsl = this.hsl();
      hsl.color[2] += hsl.color[2] * ratio;
      return hsl;
    },
    darken: function(ratio) {
      var hsl = this.hsl();
      hsl.color[2] -= hsl.color[2] * ratio;
      return hsl;
    },
    saturate: function(ratio) {
      var hsl = this.hsl();
      hsl.color[1] += hsl.color[1] * ratio;
      return hsl;
    },
    desaturate: function(ratio) {
      var hsl = this.hsl();
      hsl.color[1] -= hsl.color[1] * ratio;
      return hsl;
    },
    whiten: function(ratio) {
      var hwb = this.hwb();
      hwb.color[1] += hwb.color[1] * ratio;
      return hwb;
    },
    blacken: function(ratio) {
      var hwb = this.hwb();
      hwb.color[2] += hwb.color[2] * ratio;
      return hwb;
    },
    grayscale: function() {
      var rgb = this.rgb().color;
      var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      return Color.rgb(val, val, val);
    },
    fade: function(ratio) {
      return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer: function(ratio) {
      return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate: function(degrees) {
      var hsl = this.hsl();
      var hue = hsl.color[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      hsl.color[0] = hue;
      return hsl;
    },
    mix: function(mixinColor, weight) {
      if (!mixinColor || !mixinColor.rgb) {
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
      }
      var color1 = mixinColor.rgb();
      var color2 = this.rgb();
      var p = weight === undefined ? 0.5 : weight;
      var w = 2 * p - 1;
      var a = color1.alpha() - color2.alpha();
      var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      var w2 = 1 - w1;
      return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
    }
  };
  Object.keys(convert).forEach(function(model) {
    if (skippedModels.indexOf(model) !== -1) {
      return;
    }
    var channels = convert[model].channels;
    Color.prototype[model] = function() {
      if (this.model === model) {
        return new Color(this);
      }
      if (arguments.length) {
        return new Color(arguments, model);
      }
      var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
      return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
    };
    Color[model] = function(color) {
      if (typeof color === "number") {
        color = zeroArray(_slice.call(arguments), channels);
      }
      return new Color(color, model);
    };
  });
  module.exports = Color;
});

// node_modules/text-hex/index.js
var require_text_hex = __commonJS((exports, module) => {
  module.exports = function hex(str) {
    for (var i = 0, hash = 0;i < str.length; hash = str.charCodeAt(i++) + ((hash << 5) - hash))
      ;
    var color = Math.floor(Math.abs(Math.sin(hash) * 1e4 % 1 * 16777216)).toString(16);
    return "#" + Array(6 - color.length + 1).join("0") + color;
  };
});

// node_modules/colorspace/index.js
var require_colorspace = __commonJS((exports, module) => {
  var color = require_color();
  var hex = require_text_hex();
  module.exports = function colorspace(namespace, delimiter) {
    var split = namespace.split(delimiter || ":");
    var base = hex(split[0]);
    if (!split.length)
      return base;
    for (var i = 0, l = split.length - 1;i < l; i++) {
      base = color(base).mix(color(hex(split[i + 1]))).saturate(1).hex();
    }
    return base;
  };
});

// node_modules/kuler/index.js
var require_kuler = __commonJS((exports, module) => {
  var Kuler = function(text, color) {
    if (color)
      return new Kuler(text).style(color);
    if (!(this instanceof Kuler))
      return new Kuler(text);
    this.text = text;
  };
  Kuler.prototype.prefix = "\x1B[";
  Kuler.prototype.suffix = "m";
  Kuler.prototype.hex = function hex(color) {
    color = color[0] === "#" ? color.substring(1) : color;
    if (color.length === 3) {
      color = color.split("");
      color[5] = color[2];
      color[4] = color[2];
      color[3] = color[1];
      color[2] = color[1];
      color[1] = color[0];
      color = color.join("");
    }
    var r = color.substring(0, 2), g = color.substring(2, 4), b = color.substring(4, 6);
    return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
  };
  Kuler.prototype.rgb = function rgb(r, g, b) {
    var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
    return this.ansi(red, green, blue);
  };
  Kuler.prototype.ansi = function ansi(r, g, b) {
    var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
    return 16 + red * 36 + green * 6 + blue;
  };
  Kuler.prototype.reset = function reset() {
    return this.prefix + "39;49" + this.suffix;
  };
  Kuler.prototype.style = function style(color) {
    return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
  };
  module.exports = Kuler;
});

// node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js
var require_namespace_ansi = __commonJS((exports, module) => {
  var colorspace = require_colorspace();
  var kuler = require_kuler();
  module.exports = function ansiModifier(args, options) {
    var namespace = options.namespace;
    var ansi = options.colors !== false ? kuler(namespace + ":", colorspace(namespace)) : namespace + ":";
    args[0] = ansi + " " + args[0];
    return args;
  };
});

// node_modules/enabled/index.js
var require_enabled = __commonJS((exports, module) => {
  module.exports = function enabled(name, variable) {
    if (!variable)
      return false;
    var variables = variable.split(/[\s,]+/), i = 0;
    for (;i < variables.length; i++) {
      variable = variables[i].replace("*", ".*?");
      if (variable.charAt(0) === "-") {
        if (new RegExp("^" + variable.substr(1) + "$").test(name)) {
          return false;
        }
        continue;
      }
      if (new RegExp("^" + variable + "$").test(name)) {
        return true;
      }
    }
    return false;
  };
});

// node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS((exports, module) => {
  var enabled = require_enabled();
  module.exports = function create(fn) {
    return function adapter(namespace) {
      try {
        return enabled(namespace, fn());
      } catch (e) {
      }
      return false;
    };
  };
});

// node_modules/@dabh/diagnostics/adapters/process.env.js
var require_process_env = __commonJS((exports, module) => {
  var adapter = require_adapters();
  module.exports = adapter(function processenv() {
    return process.env.DEBUG || process.env.DIAGNOSTICS;
  });
});

// node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS((exports, module) => {
  module.exports = function(meta, messages) {
    try {
      Function.prototype.apply.call(console.log, console, messages);
    } catch (e) {
    }
  };
});

// node_modules/@dabh/diagnostics/node/development.js
var require_development = __commonJS((exports, module) => {
  var create = require_diagnostics();
  var tty = import.meta.require("tty").isatty(1);
  var diagnostics = create(function dev(namespace, options) {
    options = options || {};
    options.colors = "colors" in options ? options.colors : tty;
    options.namespace = namespace;
    options.prod = false;
    options.dev = true;
    if (!dev.enabled(namespace) && !(options.force || dev.force)) {
      return dev.nope(options);
    }
    return dev.yep(options);
  });
  diagnostics.modify(require_namespace_ansi());
  diagnostics.use(require_process_env());
  diagnostics.set(require_console2());
  module.exports = diagnostics;
});

// node_modules/@dabh/diagnostics/node/index.js
var require_node2 = __commonJS((exports, module) => {
  if (false) {
  } else {
    module.exports = require_development();
  }
});

// node_modules/winston/lib/winston/tail-file.js
var require_tail_file = __commonJS((exports, module) => {
  var noop = function() {
  };
  var fs = import.meta.require("fs");
  var { StringDecoder } = import.meta.require("string_decoder");
  var { Stream } = require_readable();
  module.exports = (options, iter) => {
    const buffer = Buffer.alloc(64 * 1024);
    const decode = new StringDecoder("utf8");
    const stream = new Stream;
    let buff = "";
    let pos = 0;
    let row = 0;
    if (options.start === -1) {
      delete options.start;
    }
    stream.readable = true;
    stream.destroy = () => {
      stream.destroyed = true;
      stream.emit("end");
      stream.emit("close");
    };
    fs.open(options.file, "a+", "0644", (err, fd) => {
      if (err) {
        if (!iter) {
          stream.emit("error", err);
        } else {
          iter(err);
        }
        stream.destroy();
        return;
      }
      (function read() {
        if (stream.destroyed) {
          fs.close(fd, noop);
          return;
        }
        return fs.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {
          if (error) {
            if (!iter) {
              stream.emit("error", error);
            } else {
              iter(error);
            }
            stream.destroy();
            return;
          }
          if (!bytes) {
            if (buff) {
              if (options.start == null || row > options.start) {
                if (!iter) {
                  stream.emit("line", buff);
                } else {
                  iter(null, buff);
                }
              }
              row++;
              buff = "";
            }
            return setTimeout(read, 1000);
          }
          let data = decode.write(buffer.slice(0, bytes));
          if (!iter) {
            stream.emit("data", data);
          }
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (;i < l; i++) {
            if (options.start == null || row > options.start) {
              if (!iter) {
                stream.emit("line", data[i]);
              } else {
                iter(null, data[i]);
              }
            }
            row++;
          }
          buff = data[l];
          pos += bytes;
          return read();
        });
      })();
    });
    if (!iter) {
      return stream;
    }
    return stream.destroy;
  };
});

// node_modules/winston/lib/winston/transports/file.js
var require_file = __commonJS((exports, module) => {
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var asyncSeries = require_series();
  var zlib = import.meta.require("zlib");
  var { MESSAGE } = require_triple_beam();
  var { Stream, PassThrough } = require_readable();
  var TransportStream = require_winston_transport();
  var debug = require_node2()("winston:file");
  var os = import.meta.require("os");
  var tailFile = require_tail_file();
  module.exports = class File extends TransportStream {
    constructor(options = {}) {
      super(options);
      this.name = options.name || "file";
      function throwIf(target, ...args) {
        args.slice(1).forEach((name) => {
          if (options[name]) {
            throw new Error(`Cannot set ${name} and ${target} together`);
          }
        });
      }
      this._stream = new PassThrough;
      this._stream.setMaxListeners(30);
      this._onError = this._onError.bind(this);
      if (options.filename || options.dirname) {
        throwIf("filename or dirname", "stream");
        this._basename = this.filename = options.filename ? path.basename(options.filename) : "winston.log";
        this.dirname = options.dirname || path.dirname(options.filename);
        this.options = options.options || { flags: "a" };
      } else if (options.stream) {
        console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
        throwIf("stream", "filename", "maxsize");
        this._dest = this._stream.pipe(this._setupStream(options.stream));
        this.dirname = path.dirname(this._dest.path);
      } else {
        throw new Error("Cannot log to file without filename or stream.");
      }
      this.maxsize = options.maxsize || null;
      this.rotationFormat = options.rotationFormat || false;
      this.zippedArchive = options.zippedArchive || false;
      this.maxFiles = options.maxFiles || null;
      this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      this.tailable = options.tailable || false;
      this.lazy = options.lazy || false;
      this._size = 0;
      this._pendingSize = 0;
      this._created = 0;
      this._drain = false;
      this._opening = false;
      this._ending = false;
      this._fileExist = false;
      if (this.dirname)
        this._createLogDirIfNotExist(this.dirname);
      if (!this.lazy)
        this.open();
    }
    finishIfEnding() {
      if (this._ending) {
        if (this._opening) {
          this.once("open", () => {
            this._stream.once("finish", () => this.emit("finish"));
            setImmediate(() => this._stream.end());
          });
        } else {
          this._stream.once("finish", () => this.emit("finish"));
          setImmediate(() => this._stream.end());
        }
      }
    }
    log(info, callback = () => {
    }) {
      if (this.silent) {
        callback();
        return true;
      }
      if (this._drain) {
        this._stream.once("drain", () => {
          this._drain = false;
          this.log(info, callback);
        });
        return;
      }
      if (this._rotate) {
        this._stream.once("rotate", () => {
          this._rotate = false;
          this.log(info, callback);
        });
        return;
      }
      if (this.lazy) {
        if (!this._fileExist) {
          if (!this._opening) {
            this.open();
          }
          this.once("open", () => {
            this._fileExist = true;
            this.log(info, callback);
            return;
          });
          return;
        }
        if (this._needsNewFile(this._pendingSize)) {
          this._dest.once("close", () => {
            if (!this._opening) {
              this.open();
            }
            this.once("open", () => {
              this.log(info, callback);
              return;
            });
            return;
          });
          return;
        }
      }
      const output = `${info[MESSAGE]}${this.eol}`;
      const bytes = Buffer.byteLength(output);
      function logged() {
        this._size += bytes;
        this._pendingSize -= bytes;
        debug("logged %s %s", this._size, output);
        this.emit("logged", info);
        if (this._rotate) {
          return;
        }
        if (this._opening) {
          return;
        }
        if (!this._needsNewFile()) {
          return;
        }
        if (this.lazy) {
          this._endStream(() => {
            this.emit("fileclosed");
          });
          return;
        }
        this._rotate = true;
        this._endStream(() => this._rotateFile());
      }
      this._pendingSize += bytes;
      if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
        this.rotatedWhileOpening = true;
      }
      const written = this._stream.write(output, logged.bind(this));
      if (!written) {
        this._drain = true;
        this._stream.once("drain", () => {
          this._drain = false;
          callback();
        });
      } else {
        callback();
      }
      debug("written", written, this._drain);
      this.finishIfEnding();
      return written;
    }
    query(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = normalizeQuery(options);
      const file = path.join(this.dirname, this.filename);
      let buff = "";
      let results = [];
      let row = 0;
      const stream = fs.createReadStream(file, {
        encoding: "utf8"
      });
      stream.on("error", (err) => {
        if (stream.readable) {
          stream.destroy();
        }
        if (!callback) {
          return;
        }
        return err.code !== "ENOENT" ? callback(err) : callback(null, results);
      });
      stream.on("data", (data) => {
        data = (buff + data).split(/\n+/);
        const l = data.length - 1;
        let i = 0;
        for (;i < l; i++) {
          if (!options.start || row >= options.start) {
            add(data[i]);
          }
          row++;
        }
        buff = data[l];
      });
      stream.on("close", () => {
        if (buff) {
          add(buff, true);
        }
        if (options.order === "desc") {
          results = results.reverse();
        }
        if (callback)
          callback(null, results);
      });
      function add(buff2, attempt) {
        try {
          const log = JSON.parse(buff2);
          if (check(log)) {
            push(log);
          }
        } catch (e) {
          if (!attempt) {
            stream.emit("error", e);
          }
        }
      }
      function push(log) {
        if (options.rows && results.length >= options.rows && options.order !== "desc") {
          if (stream.readable) {
            stream.destroy();
          }
          return;
        }
        if (options.fields) {
          log = options.fields.reduce((obj, key) => {
            obj[key] = log[key];
            return obj;
          }, {});
        }
        if (options.order === "desc") {
          if (results.length >= options.rows) {
            results.shift();
          }
        }
        results.push(log);
      }
      function check(log) {
        if (!log) {
          return;
        }
        if (typeof log !== "object") {
          return;
        }
        const time = new Date(log.timestamp);
        if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
          return;
        }
        return true;
      }
      function normalizeQuery(options2) {
        options2 = options2 || {};
        options2.rows = options2.rows || options2.limit || 10;
        options2.start = options2.start || 0;
        options2.until = options2.until || new Date;
        if (typeof options2.until !== "object") {
          options2.until = new Date(options2.until);
        }
        options2.from = options2.from || options2.until - 24 * 60 * 60 * 1000;
        if (typeof options2.from !== "object") {
          options2.from = new Date(options2.from);
        }
        options2.order = options2.order || "desc";
        return options2;
      }
    }
    stream(options = {}) {
      const file = path.join(this.dirname, this.filename);
      const stream = new Stream;
      const tail = {
        file,
        start: options.start
      };
      stream.destroy = tailFile(tail, (err, line) => {
        if (err) {
          return stream.emit("error", err);
        }
        try {
          stream.emit("data", line);
          line = JSON.parse(line);
          stream.emit("log", line);
        } catch (e) {
          stream.emit("error", e);
        }
      });
      return stream;
    }
    open() {
      if (!this.filename)
        return;
      if (this._opening)
        return;
      this._opening = true;
      this.stat((err, size) => {
        if (err) {
          return this.emit("error", err);
        }
        debug("stat done: %s { size: %s }", this.filename, size);
        this._size = size;
        this._dest = this._createStream(this._stream);
        this._opening = false;
        this.once("open", () => {
          if (this._stream.eventNames().includes("rotate")) {
            this._stream.emit("rotate");
          } else {
            this._rotate = false;
          }
        });
      });
    }
    stat(callback) {
      const target = this._getFile();
      const fullpath = path.join(this.dirname, target);
      fs.stat(fullpath, (err, stat) => {
        if (err && err.code === "ENOENT") {
          debug("ENOENT\xA0ok", fullpath);
          this.filename = target;
          return callback(null, 0);
        }
        if (err) {
          debug(`err ${err.code} ${fullpath}`);
          return callback(err);
        }
        if (!stat || this._needsNewFile(stat.size)) {
          return this._incFile(() => this.stat(callback));
        }
        this.filename = target;
        callback(null, stat.size);
      });
    }
    close(cb) {
      if (!this._stream) {
        return;
      }
      this._stream.end(() => {
        if (cb) {
          cb();
        }
        this.emit("flush");
        this.emit("closed");
      });
    }
    _needsNewFile(size) {
      size = size || this._size;
      return this.maxsize && size >= this.maxsize;
    }
    _onError(err) {
      this.emit("error", err);
    }
    _setupStream(stream) {
      stream.on("error", this._onError);
      return stream;
    }
    _cleanupStream(stream) {
      stream.removeListener("error", this._onError);
      stream.destroy();
      return stream;
    }
    _rotateFile() {
      this._incFile(() => this.open());
    }
    _endStream(callback = () => {
    }) {
      if (this._dest) {
        this._stream.unpipe(this._dest);
        this._dest.end(() => {
          this._cleanupStream(this._dest);
          callback();
        });
      } else {
        callback();
      }
    }
    _createStream(source) {
      const fullpath = path.join(this.dirname, this.filename);
      debug("create stream start", fullpath, this.options);
      const dest = fs.createWriteStream(fullpath, this.options).on("error", (err) => debug(err)).on("close", () => debug("close", dest.path, dest.bytesWritten)).on("open", () => {
        debug("file open ok", fullpath);
        this.emit("open", fullpath);
        source.pipe(dest);
        if (this.rotatedWhileOpening) {
          this._stream = new PassThrough;
          this._stream.setMaxListeners(30);
          this._rotateFile();
          this.rotatedWhileOpening = false;
          this._cleanupStream(dest);
          source.end();
        }
      });
      debug("create stream ok", fullpath);
      return dest;
    }
    _incFile(callback) {
      debug("_incFile", this.filename);
      const ext = path.extname(this._basename);
      const basename = path.basename(this._basename, ext);
      const tasks = [];
      if (this.zippedArchive) {
        tasks.push(function(cb) {
          const num = this._created > 0 && !this.tailable ? this._created : "";
          this._compressFile(path.join(this.dirname, `${basename}${num}${ext}`), path.join(this.dirname, `${basename}${num}${ext}.gz`), cb);
        }.bind(this));
      }
      tasks.push(function(cb) {
        if (!this.tailable) {
          this._created += 1;
          this._checkMaxFilesIncrementing(ext, basename, cb);
        } else {
          this._checkMaxFilesTailable(ext, basename, cb);
        }
      }.bind(this));
      asyncSeries(tasks, callback);
    }
    _getFile() {
      const ext = path.extname(this._basename);
      const basename = path.basename(this._basename, ext);
      const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
      return !this.tailable && this._created ? `${basename}${isRotation}${ext}` : `${basename}${ext}`;
    }
    _checkMaxFilesIncrementing(ext, basename, callback) {
      if (!this.maxFiles || this._created < this.maxFiles) {
        return setImmediate(callback);
      }
      const oldest = this._created - this.maxFiles;
      const isOldest = oldest !== 0 ? oldest : "";
      const isZipped = this.zippedArchive ? ".gz" : "";
      const filePath = `${basename}${isOldest}${ext}${isZipped}`;
      const target = path.join(this.dirname, filePath);
      fs.unlink(target, callback);
    }
    _checkMaxFilesTailable(ext, basename, callback) {
      const tasks = [];
      if (!this.maxFiles) {
        return;
      }
      const isZipped = this.zippedArchive ? ".gz" : "";
      for (let x = this.maxFiles - 1;x > 1; x--) {
        tasks.push(function(i, cb) {
          let fileName = `${basename}${i - 1}${ext}${isZipped}`;
          const tmppath = path.join(this.dirname, fileName);
          fs.exists(tmppath, (exists) => {
            if (!exists) {
              return cb(null);
            }
            fileName = `${basename}${i}${ext}${isZipped}`;
            fs.rename(tmppath, path.join(this.dirname, fileName), cb);
          });
        }.bind(this, x));
      }
      asyncSeries(tasks, () => {
        fs.rename(path.join(this.dirname, `${basename}${ext}${isZipped}`), path.join(this.dirname, `${basename}1${ext}${isZipped}`), callback);
      });
    }
    _compressFile(src, dest, callback) {
      fs.access(src, fs.F_OK, (err) => {
        if (err) {
          return callback();
        }
        var gzip = zlib.createGzip();
        var inp = fs.createReadStream(src);
        var out = fs.createWriteStream(dest);
        out.on("finish", () => {
          fs.unlink(src, callback);
        });
        inp.pipe(gzip).pipe(out);
      });
    }
    _createLogDirIfNotExist(dirPath) {
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
      }
    }
  };
});

// node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS((exports, module) => {
  var http = import.meta.require("http");
  var https = import.meta.require("https");
  var { Stream } = require_readable();
  var TransportStream = require_winston_transport();
  var jsonStringify = require_safe_stable_stringify();
  module.exports = class Http extends TransportStream {
    constructor(options = {}) {
      super(options);
      this.options = options;
      this.name = options.name || "http";
      this.ssl = !!options.ssl;
      this.host = options.host || "localhost";
      this.port = options.port;
      this.auth = options.auth;
      this.path = options.path || "";
      this.agent = options.agent;
      this.headers = options.headers || {};
      this.headers["content-type"] = "application/json";
      this.batch = options.batch || false;
      this.batchInterval = options.batchInterval || 5000;
      this.batchCount = options.batchCount || 10;
      this.batchOptions = [];
      this.batchTimeoutID = -1;
      this.batchCallback = {};
      if (!this.port) {
        this.port = this.ssl ? 443 : 80;
      }
    }
    log(info, callback) {
      this._request(info, null, null, (err, res) => {
        if (res && res.statusCode !== 200) {
          err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
        }
        if (err) {
          this.emit("warn", err);
        } else {
          this.emit("logged", info);
        }
      });
      if (callback) {
        setImmediate(callback);
      }
    }
    query(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = {
        method: "query",
        params: this.normalizeQuery(options)
      };
      const auth = options.params.auth || null;
      delete options.params.auth;
      const path = options.params.path || null;
      delete options.params.path;
      this._request(options, auth, path, (err, res, body) => {
        if (res && res.statusCode !== 200) {
          err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
        }
        if (err) {
          return callback(err);
        }
        if (typeof body === "string") {
          try {
            body = JSON.parse(body);
          } catch (e) {
            return callback(e);
          }
        }
        callback(null, body);
      });
    }
    stream(options = {}) {
      const stream = new Stream;
      options = {
        method: "stream",
        params: options
      };
      const path = options.params.path || null;
      delete options.params.path;
      const auth = options.params.auth || null;
      delete options.params.auth;
      let buff = "";
      const req = this._request(options, auth, path);
      stream.destroy = () => req.destroy();
      req.on("data", (data) => {
        data = (buff + data).split(/\n+/);
        const l = data.length - 1;
        let i = 0;
        for (;i < l; i++) {
          try {
            stream.emit("log", JSON.parse(data[i]));
          } catch (e) {
            stream.emit("error", e);
          }
        }
        buff = data[l];
      });
      req.on("error", (err) => stream.emit("error", err));
      return stream;
    }
    _request(options, auth, path, callback) {
      options = options || {};
      auth = auth || this.auth;
      path = path || this.path || "";
      if (this.batch) {
        this._doBatch(options, callback, auth, path);
      } else {
        this._doRequest(options, callback, auth, path);
      }
    }
    _doBatch(options, callback, auth, path) {
      this.batchOptions.push(options);
      if (this.batchOptions.length === 1) {
        const me = this;
        this.batchCallback = callback;
        this.batchTimeoutID = setTimeout(function() {
          me.batchTimeoutID = -1;
          me._doBatchRequest(me.batchCallback, auth, path);
        }, this.batchInterval);
      }
      if (this.batchOptions.length === this.batchCount) {
        this._doBatchRequest(this.batchCallback, auth, path);
      }
    }
    _doBatchRequest(callback, auth, path) {
      if (this.batchTimeoutID > 0) {
        clearTimeout(this.batchTimeoutID);
        this.batchTimeoutID = -1;
      }
      const batchOptionsCopy = this.batchOptions.slice();
      this.batchOptions = [];
      this._doRequest(batchOptionsCopy, callback, auth, path);
    }
    _doRequest(options, callback, auth, path) {
      const headers = Object.assign({}, this.headers);
      if (auth && auth.bearer) {
        headers.Authorization = `Bearer ${auth.bearer}`;
      }
      const req = (this.ssl ? https : http).request({
        ...this.options,
        method: "POST",
        host: this.host,
        port: this.port,
        path: `/${path.replace(/^\//, "")}`,
        headers,
        auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
        agent: this.agent
      });
      req.on("error", callback);
      req.on("response", (res) => res.on("end", () => callback(null, res)).resume());
      req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
    }
  };
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports, module) => {
  var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
  isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
  isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
  module.exports = isStream;
});

// node_modules/winston/lib/winston/transports/stream.js
var require_stream = __commonJS((exports, module) => {
  var isStream = require_is_stream();
  var { MESSAGE } = require_triple_beam();
  var os = import.meta.require("os");
  var TransportStream = require_winston_transport();
  module.exports = class Stream extends TransportStream {
    constructor(options = {}) {
      super(options);
      if (!options.stream || !isStream(options.stream)) {
        throw new Error("options.stream is required.");
      }
      this._stream = options.stream;
      this._stream.setMaxListeners(Infinity);
      this.isObjectMode = options.stream._writableState.objectMode;
      this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
    }
    log(info, callback) {
      setImmediate(() => this.emit("logged", info));
      if (this.isObjectMode) {
        this._stream.write(info);
        if (callback) {
          callback();
        }
        return;
      }
      this._stream.write(`${info[MESSAGE]}${this.eol}`);
      if (callback) {
        callback();
      }
      return;
    }
  };
});

// node_modules/winston/lib/winston/transports/index.js
var require_transports = __commonJS((exports) => {
  Object.defineProperty(exports, "Console", {
    configurable: true,
    enumerable: true,
    get() {
      return require_console();
    }
  });
  Object.defineProperty(exports, "File", {
    configurable: true,
    enumerable: true,
    get() {
      return require_file();
    }
  });
  Object.defineProperty(exports, "Http", {
    configurable: true,
    enumerable: true,
    get() {
      return require_http();
    }
  });
  Object.defineProperty(exports, "Stream", {
    configurable: true,
    enumerable: true,
    get() {
      return require_stream();
    }
  });
});

// node_modules/winston/lib/winston/config/index.js
var require_config3 = __commonJS((exports) => {
  var logform = require_logform();
  var { configs } = require_triple_beam();
  exports.cli = logform.levels(configs.cli);
  exports.npm = logform.levels(configs.npm);
  exports.syslog = logform.levels(configs.syslog);
  exports.addColors = logform.levels;
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachOfArrayLike = function(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback);
    var index = 0, completed = 0, { length } = coll, canceled = false;
    if (length === 0) {
      callback(null);
    }
    function iteratorCallback(err, value) {
      if (err === false) {
        canceled = true;
      }
      if (canceled === true)
        return;
      if (err) {
        callback(err);
      } else if (++completed === length || value === _breakLoop2.default) {
        callback(null);
      }
    }
    for (;index < length; index++) {
      iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
    }
  };
  var eachOfGeneric = function(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
  };
  var eachOf = function(coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _isArrayLike = require_isArrayLike();
  var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
  var _breakLoop = require_breakLoop();
  var _breakLoop2 = _interopRequireDefault(_breakLoop);
  var _eachOfLimit = require_eachOfLimit2();
  var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
  var _once = require_once();
  var _once2 = _interopRequireDefault(_once);
  var _onlyOnce = require_onlyOnce();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachOf, 3);
  module.exports = exports.default;
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS((exports, module) => {
  var _withoutIndex = function(iteratee) {
    return (value, index, callback) => iteratee(value, callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _withoutIndex;
  module.exports = exports.default;
});

// node_modules/async/forEach.js
var require_forEach = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var eachLimit = function(coll, iteratee, callback) {
    return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOf = require_eachOf();
  var _eachOf2 = _interopRequireDefault(_eachOf);
  var _withoutIndex = require_withoutIndex();
  var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  var _awaitify = require_awaitify();
  var _awaitify2 = _interopRequireDefault(_awaitify);
  exports.default = (0, _awaitify2.default)(eachLimit, 3);
  module.exports = exports.default;
});

// node_modules/fn.name/index.js
var require_fn = __commonJS((exports, module) => {
  var toString = Object.prototype.toString;
  module.exports = function name(fn) {
    if (typeof fn.displayName === "string" && fn.constructor.name) {
      return fn.displayName;
    } else if (typeof fn.name === "string" && fn.name) {
      return fn.name;
    }
    if (typeof fn === "object" && fn.constructor && typeof fn.constructor.name === "string")
      return fn.constructor.name;
    var named = fn.toString(), type = toString.call(fn).slice(8, -1);
    if (type === "Function") {
      named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
    } else {
      named = type;
    }
    return named || "anonymous";
  };
});

// node_modules/one-time/index.js
var require_one_time = __commonJS((exports, module) => {
  var name = require_fn();
  module.exports = function one(fn) {
    var called = 0, value;
    function onetime() {
      if (called)
        return value;
      called = 1;
      value = fn.apply(this, arguments);
      fn = null;
      return value;
    }
    onetime.displayName = name(fn);
    return onetime;
  };
});

// node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS((exports) => {
  var CallSite = function(properties) {
    for (var property in properties) {
      this[property] = properties[property];
    }
  };
  exports.get = function(belowFn) {
    var oldLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Infinity;
    var dummyObject = {};
    var v8Handler = Error.prepareStackTrace;
    Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
      return v8StackTrace2;
    };
    Error.captureStackTrace(dummyObject, belowFn || exports.get);
    var v8StackTrace = dummyObject.stack;
    Error.prepareStackTrace = v8Handler;
    Error.stackTraceLimit = oldLimit;
    return v8StackTrace;
  };
  exports.parse = function(err) {
    if (!err.stack) {
      return [];
    }
    var self2 = this;
    var lines = err.stack.split("\n").slice(1);
    return lines.map(function(line) {
      if (line.match(/^\s*[-]{4,}$/)) {
        return self2._createParsedCallSite({
          fileName: line,
          lineNumber: null,
          functionName: null,
          typeName: null,
          methodName: null,
          columnNumber: null,
          native: null
        });
      }
      var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
      if (!lineMatch) {
        return;
      }
      var object = null;
      var method = null;
      var functionName = null;
      var typeName = null;
      var methodName = null;
      var isNative = lineMatch[5] === "native";
      if (lineMatch[1]) {
        functionName = lineMatch[1];
        var methodStart = functionName.lastIndexOf(".");
        if (functionName[methodStart - 1] == ".")
          methodStart--;
        if (methodStart > 0) {
          object = functionName.substr(0, methodStart);
          method = functionName.substr(methodStart + 1);
          var objectEnd = object.indexOf(".Module");
          if (objectEnd > 0) {
            functionName = functionName.substr(objectEnd + 1);
            object = object.substr(0, objectEnd);
          }
        }
        typeName = null;
      }
      if (method) {
        typeName = object;
        methodName = method;
      }
      if (method === "<anonymous>") {
        methodName = null;
        functionName = null;
      }
      var properties = {
        fileName: lineMatch[2] || null,
        lineNumber: parseInt(lineMatch[3], 10) || null,
        functionName,
        typeName,
        methodName,
        columnNumber: parseInt(lineMatch[4], 10) || null,
        native: isNative
      };
      return self2._createParsedCallSite(properties);
    }).filter(function(callSite) {
      return !!callSite;
    });
  };
  var strProperties = [
    "this",
    "typeName",
    "functionName",
    "methodName",
    "fileName",
    "lineNumber",
    "columnNumber",
    "function",
    "evalOrigin"
  ];
  var boolProperties = [
    "topLevel",
    "eval",
    "native",
    "constructor"
  ];
  strProperties.forEach(function(property) {
    CallSite.prototype[property] = null;
    CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
      return this[property];
    };
  });
  boolProperties.forEach(function(property) {
    CallSite.prototype[property] = false;
    CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
      return this[property];
    };
  });
  exports._createParsedCallSite = function(properties) {
    return new CallSite(properties);
  };
});

// node_modules/winston/lib/winston/exception-stream.js
var require_exception_stream = __commonJS((exports, module) => {
  var { Writable } = require_readable();
  module.exports = class ExceptionStream extends Writable {
    constructor(transport) {
      super({ objectMode: true });
      if (!transport) {
        throw new Error("ExceptionStream requires a TransportStream instance.");
      }
      this.handleExceptions = true;
      this.transport = transport;
    }
    _write(info, enc, callback) {
      if (info.exception) {
        return this.transport.log(info, callback);
      }
      callback();
      return true;
    }
  };
});

// node_modules/winston/lib/winston/exception-handler.js
var require_exception_handler = __commonJS((exports, module) => {
  var os = import.meta.require("os");
  var asyncForEach = require_forEach();
  var debug = require_node2()("winston:exception");
  var once = require_one_time();
  var stackTrace = require_stack_trace();
  var ExceptionStream = require_exception_stream();
  module.exports = class ExceptionHandler {
    constructor(logger) {
      if (!logger) {
        throw new Error("Logger is required to handle exceptions");
      }
      this.logger = logger;
      this.handlers = new Map;
    }
    handle(...args) {
      args.forEach((arg) => {
        if (Array.isArray(arg)) {
          return arg.forEach((handler) => this._addHandler(handler));
        }
        this._addHandler(arg);
      });
      if (!this.catcher) {
        this.catcher = this._uncaughtException.bind(this);
        process.on("uncaughtException", this.catcher);
      }
    }
    unhandle() {
      if (this.catcher) {
        process.removeListener("uncaughtException", this.catcher);
        this.catcher = false;
        Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
      }
    }
    getAllInfo(err) {
      let message = null;
      if (err) {
        message = typeof err === "string" ? err : err.message;
      }
      return {
        error: err,
        level: "error",
        message: [
          `uncaughtException: ${message || "(no error message)"}`,
          err && err.stack || "  No stack trace"
        ].join("\n"),
        stack: err && err.stack,
        exception: true,
        date: new Date().toString(),
        process: this.getProcessInfo(),
        os: this.getOsInfo(),
        trace: this.getTrace(err)
      };
    }
    getProcessInfo() {
      return {
        pid: process.pid,
        uid: process.getuid ? process.getuid() : null,
        gid: process.getgid ? process.getgid() : null,
        cwd: process.cwd(),
        execPath: process.execPath,
        version: process.version,
        argv: process.argv,
        memoryUsage: process.memoryUsage()
      };
    }
    getOsInfo() {
      return {
        loadavg: os.loadavg(),
        uptime: os.uptime()
      };
    }
    getTrace(err) {
      const trace = err ? stackTrace.parse(err) : stackTrace.get();
      return trace.map((site) => {
        return {
          column: site.getColumnNumber(),
          file: site.getFileName(),
          function: site.getFunctionName(),
          line: site.getLineNumber(),
          method: site.getMethodName(),
          native: site.isNative()
        };
      });
    }
    _addHandler(handler) {
      if (!this.handlers.has(handler)) {
        handler.handleExceptions = true;
        const wrapper = new ExceptionStream(handler);
        this.handlers.set(handler, wrapper);
        this.logger.pipe(wrapper);
      }
    }
    _uncaughtException(err) {
      const info = this.getAllInfo(err);
      const handlers = this._getExceptionHandlers();
      let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
      let timeout;
      if (!handlers.length && doExit) {
        console.warn("winston: exitOnError cannot be true with no exception handlers.");
        console.warn("winston: not exiting process.");
        doExit = false;
      }
      function gracefulExit() {
        debug("doExit", doExit);
        debug("process._exiting", process._exiting);
        if (doExit && !process._exiting) {
          if (timeout) {
            clearTimeout(timeout);
          }
          process.exit(1);
        }
      }
      if (!handlers || handlers.length === 0) {
        return process.nextTick(gracefulExit);
      }
      asyncForEach(handlers, (handler, next) => {
        const done = once(next);
        const transport = handler.transport || handler;
        function onDone(event) {
          return () => {
            debug(event);
            done();
          };
        }
        transport._ending = true;
        transport.once("finish", onDone("finished"));
        transport.once("error", onDone("error"));
      }, () => doExit && gracefulExit());
      this.logger.log(info);
      if (doExit) {
        timeout = setTimeout(gracefulExit, 3000);
      }
    }
    _getExceptionHandlers() {
      return this.logger.transports.filter((wrap) => {
        const transport = wrap.transport || wrap;
        return transport.handleExceptions;
      });
    }
  };
});

// node_modules/winston/lib/winston/rejection-stream.js
var require_rejection_stream = __commonJS((exports, module) => {
  var { Writable } = require_readable();
  module.exports = class RejectionStream extends Writable {
    constructor(transport) {
      super({ objectMode: true });
      if (!transport) {
        throw new Error("RejectionStream requires a TransportStream instance.");
      }
      this.handleRejections = true;
      this.transport = transport;
    }
    _write(info, enc, callback) {
      if (info.rejection) {
        return this.transport.log(info, callback);
      }
      callback();
      return true;
    }
  };
});

// node_modules/winston/lib/winston/rejection-handler.js
var require_rejection_handler = __commonJS((exports, module) => {
  var os = import.meta.require("os");
  var asyncForEach = require_forEach();
  var debug = require_node2()("winston:rejection");
  var once = require_one_time();
  var stackTrace = require_stack_trace();
  var RejectionStream = require_rejection_stream();
  module.exports = class RejectionHandler {
    constructor(logger) {
      if (!logger) {
        throw new Error("Logger is required to handle rejections");
      }
      this.logger = logger;
      this.handlers = new Map;
    }
    handle(...args) {
      args.forEach((arg) => {
        if (Array.isArray(arg)) {
          return arg.forEach((handler) => this._addHandler(handler));
        }
        this._addHandler(arg);
      });
      if (!this.catcher) {
        this.catcher = this._unhandledRejection.bind(this);
        process.on("unhandledRejection", this.catcher);
      }
    }
    unhandle() {
      if (this.catcher) {
        process.removeListener("unhandledRejection", this.catcher);
        this.catcher = false;
        Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
      }
    }
    getAllInfo(err) {
      let message = null;
      if (err) {
        message = typeof err === "string" ? err : err.message;
      }
      return {
        error: err,
        level: "error",
        message: [
          `unhandledRejection: ${message || "(no error message)"}`,
          err && err.stack || "  No stack trace"
        ].join("\n"),
        stack: err && err.stack,
        rejection: true,
        date: new Date().toString(),
        process: this.getProcessInfo(),
        os: this.getOsInfo(),
        trace: this.getTrace(err)
      };
    }
    getProcessInfo() {
      return {
        pid: process.pid,
        uid: process.getuid ? process.getuid() : null,
        gid: process.getgid ? process.getgid() : null,
        cwd: process.cwd(),
        execPath: process.execPath,
        version: process.version,
        argv: process.argv,
        memoryUsage: process.memoryUsage()
      };
    }
    getOsInfo() {
      return {
        loadavg: os.loadavg(),
        uptime: os.uptime()
      };
    }
    getTrace(err) {
      const trace = err ? stackTrace.parse(err) : stackTrace.get();
      return trace.map((site) => {
        return {
          column: site.getColumnNumber(),
          file: site.getFileName(),
          function: site.getFunctionName(),
          line: site.getLineNumber(),
          method: site.getMethodName(),
          native: site.isNative()
        };
      });
    }
    _addHandler(handler) {
      if (!this.handlers.has(handler)) {
        handler.handleRejections = true;
        const wrapper = new RejectionStream(handler);
        this.handlers.set(handler, wrapper);
        this.logger.pipe(wrapper);
      }
    }
    _unhandledRejection(err) {
      const info = this.getAllInfo(err);
      const handlers = this._getRejectionHandlers();
      let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
      let timeout;
      if (!handlers.length && doExit) {
        console.warn("winston: exitOnError cannot be true with no rejection handlers.");
        console.warn("winston: not exiting process.");
        doExit = false;
      }
      function gracefulExit() {
        debug("doExit", doExit);
        debug("process._exiting", process._exiting);
        if (doExit && !process._exiting) {
          if (timeout) {
            clearTimeout(timeout);
          }
          process.exit(1);
        }
      }
      if (!handlers || handlers.length === 0) {
        return process.nextTick(gracefulExit);
      }
      asyncForEach(handlers, (handler, next) => {
        const done = once(next);
        const transport = handler.transport || handler;
        function onDone(event) {
          return () => {
            debug(event);
            done();
          };
        }
        transport._ending = true;
        transport.once("finish", onDone("finished"));
        transport.once("error", onDone("error"));
      }, () => doExit && gracefulExit());
      this.logger.log(info);
      if (doExit) {
        timeout = setTimeout(gracefulExit, 3000);
      }
    }
    _getRejectionHandlers() {
      return this.logger.transports.filter((wrap) => {
        const transport = wrap.transport || wrap;
        return transport.handleRejections;
      });
    }
  };
});

// node_modules/winston/lib/winston/profiler.js
var require_profiler = __commonJS((exports, module) => {
  class Profiler {
    constructor(logger) {
      const Logger = require_logger();
      if (typeof logger !== "object" || Array.isArray(logger) || !(logger instanceof Logger)) {
        throw new Error("Logger is required for profiling");
      } else {
        this.logger = logger;
        this.start = Date.now();
      }
    }
    done(...args) {
      if (typeof args[args.length - 1] === "function") {
        console.warn("Callback function no longer supported as of winston@3.0.0");
        args.pop();
      }
      const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
      info.level = info.level || "info";
      info.durationMs = Date.now() - this.start;
      return this.logger.write(info);
    }
  }
  module.exports = Profiler;
});

// node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS((exports, module) => {
  var getLevelValue = function(levels, level) {
    const value = levels[level];
    if (!value && value !== 0) {
      return null;
    }
    return value;
  };
  var { Stream, Transform } = require_readable();
  var asyncForEach = require_forEach();
  var { LEVEL, SPLAT } = require_triple_beam();
  var isStream = require_is_stream();
  var ExceptionHandler = require_exception_handler();
  var RejectionHandler = require_rejection_handler();
  var LegacyTransportStream = require_legacy();
  var Profiler = require_profiler();
  var { warn } = require_common();
  var config2 = require_config3();
  var formatRegExp = /%[scdjifoO%]/g;

  class Logger extends Transform {
    constructor(options) {
      super({ objectMode: true });
      this.configure(options);
    }
    child(defaultRequestMetadata) {
      const logger = this;
      return Object.create(logger, {
        write: {
          value: function(info) {
            const infoClone = Object.assign({}, defaultRequestMetadata, info);
            if (info instanceof Error) {
              infoClone.stack = info.stack;
              infoClone.message = info.message;
            }
            logger.write(infoClone);
          }
        }
      });
    }
    configure({
      silent,
      format,
      defaultMeta,
      levels,
      level = "info",
      exitOnError = true,
      transports,
      colors,
      emitErrs,
      formatters,
      padLevels,
      rewriters,
      stripColors,
      exceptionHandlers,
      rejectionHandlers
    } = {}) {
      if (this.transports.length) {
        this.clear();
      }
      this.silent = silent;
      this.format = format || this.format || require_json()();
      this.defaultMeta = defaultMeta || null;
      this.levels = levels || this.levels || config2.npm.levels;
      this.level = level;
      if (this.exceptions) {
        this.exceptions.unhandle();
      }
      if (this.rejections) {
        this.rejections.unhandle();
      }
      this.exceptions = new ExceptionHandler(this);
      this.rejections = new RejectionHandler(this);
      this.profilers = {};
      this.exitOnError = exitOnError;
      if (transports) {
        transports = Array.isArray(transports) ? transports : [transports];
        transports.forEach((transport) => this.add(transport));
      }
      if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
        throw new Error([
          "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
          "Use a custom winston.format(function) instead.",
          "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
        ].join("\n"));
      }
      if (exceptionHandlers) {
        this.exceptions.handle(exceptionHandlers);
      }
      if (rejectionHandlers) {
        this.rejections.handle(rejectionHandlers);
      }
    }
    isLevelEnabled(level) {
      const givenLevelValue = getLevelValue(this.levels, level);
      if (givenLevelValue === null) {
        return false;
      }
      const configuredLevelValue = getLevelValue(this.levels, this.level);
      if (configuredLevelValue === null) {
        return false;
      }
      if (!this.transports || this.transports.length === 0) {
        return configuredLevelValue >= givenLevelValue;
      }
      const index = this.transports.findIndex((transport) => {
        let transportLevelValue = getLevelValue(this.levels, transport.level);
        if (transportLevelValue === null) {
          transportLevelValue = configuredLevelValue;
        }
        return transportLevelValue >= givenLevelValue;
      });
      return index !== -1;
    }
    log(level, msg, ...splat) {
      if (arguments.length === 1) {
        level[LEVEL] = level.level;
        this._addDefaultMeta(level);
        this.write(level);
        return this;
      }
      if (arguments.length === 2) {
        if (msg && typeof msg === "object") {
          msg[LEVEL] = msg.level = level;
          this._addDefaultMeta(msg);
          this.write(msg);
          return this;
        }
        msg = { [LEVEL]: level, level, message: msg };
        this._addDefaultMeta(msg);
        this.write(msg);
        return this;
      }
      const [meta] = splat;
      if (typeof meta === "object" && meta !== null) {
        const tokens = msg && msg.match && msg.match(formatRegExp);
        if (!tokens) {
          const info = Object.assign({}, this.defaultMeta, meta, {
            [LEVEL]: level,
            [SPLAT]: splat,
            level,
            message: msg
          });
          if (meta.message)
            info.message = `${info.message} ${meta.message}`;
          if (meta.stack)
            info.stack = meta.stack;
          this.write(info);
          return this;
        }
      }
      this.write(Object.assign({}, this.defaultMeta, {
        [LEVEL]: level,
        [SPLAT]: splat,
        level,
        message: msg
      }));
      return this;
    }
    _transform(info, enc, callback) {
      if (this.silent) {
        return callback();
      }
      if (!info[LEVEL]) {
        info[LEVEL] = info.level;
      }
      if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
        console.error("[winston] Unknown logger level: %s", info[LEVEL]);
      }
      if (!this._readableState.pipes) {
        console.error("[winston] Attempt to write logs with no transports, which can increase memory usage: %j", info);
      }
      try {
        this.push(this.format.transform(info, this.format.options));
      } finally {
        this._writableState.sync = false;
        callback();
      }
    }
    _final(callback) {
      const transports = this.transports.slice();
      asyncForEach(transports, (transport, next) => {
        if (!transport || transport.finished)
          return setImmediate(next);
        transport.once("finish", next);
        transport.end();
      }, callback);
    }
    add(transport) {
      const target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({ transport }) : transport;
      if (!target._writableState || !target._writableState.objectMode) {
        throw new Error("Transports must WritableStreams in objectMode. Set { objectMode: true }.");
      }
      this._onEvent("error", target);
      this._onEvent("warn", target);
      this.pipe(target);
      if (transport.handleExceptions) {
        this.exceptions.handle();
      }
      if (transport.handleRejections) {
        this.rejections.handle();
      }
      return this;
    }
    remove(transport) {
      if (!transport)
        return this;
      let target = transport;
      if (!isStream(transport) || transport.log.length > 2) {
        target = this.transports.filter((match) => match.transport === transport)[0];
      }
      if (target) {
        this.unpipe(target);
      }
      return this;
    }
    clear() {
      this.unpipe();
      return this;
    }
    close() {
      this.exceptions.unhandle();
      this.rejections.unhandle();
      this.clear();
      this.emit("close");
      return this;
    }
    setLevels() {
      warn.deprecated("setLevels");
    }
    query(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      const results = {};
      const queryObject = Object.assign({}, options.query || {});
      function queryTransport(transport, next) {
        if (options.query && typeof transport.formatQuery === "function") {
          options.query = transport.formatQuery(queryObject);
        }
        transport.query(options, (err, res) => {
          if (err) {
            return next(err);
          }
          if (typeof transport.formatResults === "function") {
            res = transport.formatResults(res, options.format);
          }
          next(null, res);
        });
      }
      function addResults(transport, next) {
        queryTransport(transport, (err, result) => {
          if (next) {
            result = err || result;
            if (result) {
              results[transport.name] = result;
            }
            next();
          }
          next = null;
        });
      }
      asyncForEach(this.transports.filter((transport) => !!transport.query), addResults, () => callback(null, results));
    }
    stream(options = {}) {
      const out = new Stream;
      const streams = [];
      out._streams = streams;
      out.destroy = () => {
        let i = streams.length;
        while (i--) {
          streams[i].destroy();
        }
      };
      this.transports.filter((transport) => !!transport.stream).forEach((transport) => {
        const str = transport.stream(options);
        if (!str) {
          return;
        }
        streams.push(str);
        str.on("log", (log) => {
          log.transport = log.transport || [];
          log.transport.push(transport.name);
          out.emit("log", log);
        });
        str.on("error", (err) => {
          err.transport = err.transport || [];
          err.transport.push(transport.name);
          out.emit("error", err);
        });
      });
      return out;
    }
    startTimer() {
      return new Profiler(this);
    }
    profile(id, ...args) {
      const time = Date.now();
      if (this.profilers[id]) {
        const timeEnd = this.profilers[id];
        delete this.profilers[id];
        if (typeof args[args.length - 2] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = time - timeEnd;
        info.message = info.message || id;
        return this.write(info);
      }
      this.profilers[id] = time;
      return this;
    }
    handleExceptions(...args) {
      console.warn("Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()");
      this.exceptions.handle(...args);
    }
    unhandleExceptions(...args) {
      console.warn("Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()");
      this.exceptions.unhandle(...args);
    }
    cli() {
      throw new Error([
        "Logger.cli() was removed in winston@3.0.0",
        "Use a custom winston.formats.cli() instead.",
        "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
      ].join("\n"));
    }
    _onEvent(event, transport) {
      function transportEvent(err) {
        if (event === "error" && !this.transports.includes(transport)) {
          this.add(transport);
        }
        this.emit(event, err, transport);
      }
      if (!transport["__winston" + event]) {
        transport["__winston" + event] = transportEvent.bind(this);
        transport.on(event, transport["__winston" + event]);
      }
    }
    _addDefaultMeta(msg) {
      if (this.defaultMeta) {
        Object.assign(msg, this.defaultMeta);
      }
    }
  }
  Object.defineProperty(Logger.prototype, "transports", {
    configurable: false,
    enumerable: true,
    get() {
      const { pipes } = this._readableState;
      return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
    }
  });
  module.exports = Logger;
});

// node_modules/winston/lib/winston/create-logger.js
var require_create_logger = __commonJS((exports, module) => {
  var isLevelEnabledFunctionName = function(level) {
    return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
  };
  var { LEVEL } = require_triple_beam();
  var config2 = require_config3();
  var Logger = require_logger();
  var debug = require_node2()("winston:create-logger");
  module.exports = function(opts = {}) {
    opts.levels = opts.levels || config2.npm.levels;

    class DerivedLogger extends Logger {
      constructor(options) {
        super(options);
      }
    }
    const logger = new DerivedLogger(opts);
    Object.keys(opts.levels).forEach(function(level) {
      debug('Define prototype method for "%s"', level);
      if (level === "log") {
        console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
        return;
      }
      DerivedLogger.prototype[level] = function(...args) {
        const self2 = this || logger;
        if (args.length === 1) {
          const [msg] = args;
          const info = msg && msg.message && msg || { message: msg };
          info.level = info[LEVEL] = level;
          self2._addDefaultMeta(info);
          self2.write(info);
          return this || logger;
        }
        if (args.length === 0) {
          self2.log(level, "");
          return self2;
        }
        return self2.log(level, ...args);
      };
      DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
        return (this || logger).isLevelEnabled(level);
      };
    });
    return logger;
  };
});

// node_modules/winston/lib/winston/container.js
var require_container = __commonJS((exports, module) => {
  var createLogger = require_create_logger();
  module.exports = class Container {
    constructor(options = {}) {
      this.loggers = new Map;
      this.options = options;
    }
    add(id, options) {
      if (!this.loggers.has(id)) {
        options = Object.assign({}, options || this.options);
        const existing = options.transports || this.options.transports;
        if (existing) {
          options.transports = Array.isArray(existing) ? existing.slice() : [existing];
        } else {
          options.transports = [];
        }
        const logger = createLogger(options);
        logger.on("close", () => this._delete(id));
        this.loggers.set(id, logger);
      }
      return this.loggers.get(id);
    }
    get(id, options) {
      return this.add(id, options);
    }
    has(id) {
      return !!this.loggers.has(id);
    }
    close(id) {
      if (id) {
        return this._removeLogger(id);
      }
      this.loggers.forEach((val, key) => this._removeLogger(key));
    }
    _removeLogger(id) {
      if (!this.loggers.has(id)) {
        return;
      }
      const logger = this.loggers.get(id);
      logger.close();
      this._delete(id);
    }
    _delete(id) {
      this.loggers.delete(id);
    }
  };
});

// node_modules/winston/lib/winston.js
var require_winston = __commonJS((exports) => {
  var logform = require_logform();
  var { warn } = require_common();
  exports.version = require_package2().version;
  exports.transports = require_transports();
  exports.config = require_config3();
  exports.addColors = logform.levels;
  exports.format = logform.format;
  exports.createLogger = require_create_logger();
  exports.Logger = require_logger();
  exports.ExceptionHandler = require_exception_handler();
  exports.RejectionHandler = require_rejection_handler();
  exports.Container = require_container();
  exports.Transport = require_winston_transport();
  exports.loggers = new exports.Container;
  var defaultLogger = exports.createLogger();
  Object.keys(exports.config.npm.levels).concat([
    "log",
    "query",
    "stream",
    "add",
    "remove",
    "clear",
    "profile",
    "startTimer",
    "handleExceptions",
    "unhandleExceptions",
    "handleRejections",
    "unhandleRejections",
    "configure",
    "child"
  ]).forEach((method) => exports[method] = (...args) => defaultLogger[method](...args));
  Object.defineProperty(exports, "level", {
    get() {
      return defaultLogger.level;
    },
    set(val) {
      defaultLogger.level = val;
    }
  });
  Object.defineProperty(exports, "exceptions", {
    get() {
      return defaultLogger.exceptions;
    }
  });
  Object.defineProperty(exports, "rejections", {
    get() {
      return defaultLogger.rejections;
    }
  });
  ["exitOnError"].forEach((prop) => {
    Object.defineProperty(exports, prop, {
      get() {
        return defaultLogger[prop];
      },
      set(val) {
        defaultLogger[prop] = val;
      }
    });
  });
  Object.defineProperty(exports, "default", {
    get() {
      return {
        exceptionHandlers: defaultLogger.exceptionHandlers,
        rejectionHandlers: defaultLogger.rejectionHandlers,
        transports: defaultLogger.transports
      };
    }
  });
  warn.deprecated(exports, "setLevels");
  warn.forFunctions(exports, "useFormat", ["cli"]);
  warn.forProperties(exports, "useFormat", ["padLevels", "stripColors"]);
  warn.forFunctions(exports, "deprecated", [
    "addRewriter",
    "addFilter",
    "clone",
    "extend"
  ]);
  warn.forProperties(exports, "deprecated", ["emitErrs", "levelLength"]);
});

// node_modules/@prisma/client/runtime/library.js
var require_library = __commonJS((exports, module) => {
  var io = function(e) {
    return typeof e == "function" ? e : (r) => r.$extends(e);
  };
  var oo = function(e) {
    return e;
  };
  var so = function(...e) {
    return (r) => r;
  };
  var F = function(e, r) {
    let t = new RegExp(`\\x1b\\[${r}m`, "g"), n = `\x1B[${e}m`, i = `\x1B[${r}m`;
    return function(o) {
      return !po.enabled || o == null ? o : n + (~("" + o).indexOf(i) ? o.replace(t, i + n) : o) + i;
    };
  };
  var au = function(e) {
    let r = { color: mo[su++ % mo.length], enabled: $r.enabled(e), namespace: e, log: $r.log, extend: () => {
    } }, t = (...n) => {
      let { enabled: i, namespace: o, color: s, log: a } = r;
      if (n.length !== 0 && Mr.push([o, ...n]), Mr.length > ou && Mr.shift(), $r.enabled(o) || i) {
        let l = n.map((c) => typeof c == "string" ? c : lu(c)), u = `+${Date.now() - fo}ms`;
        fo = Date.now(), globalThis.DEBUG_COLORS ? a(St[s](W(o)), ...l, St[s](u)) : a(o, ...l, u);
      }
    };
    return new Proxy(t, { get: (n, i) => r[i], set: (n, i, o) => r[i] = o });
  };
  var lu = function(e, r = 2) {
    let t = new Set;
    return JSON.stringify(e, (n, i) => {
      if (typeof i == "object" && i !== null) {
        if (t.has(i))
          return "[Circular *]";
        t.add(i);
      } else if (typeof i == "bigint")
        return i.toString();
      return i;
    }, r);
  };
  var go = function(e = 7500) {
    let r = Mr.map(([t, ...n]) => `${t} ${n.map((i) => typeof i == "string" ? i : JSON.stringify(i)).join(" ")}`).join(`
`);
    return r.length < e ? r : r.slice(-e);
  };
  var ho = function() {
    Mr.length = 0;
  };
  var Fn = function() {
    let e = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
    if (!(e && yo.default.existsSync(e)) && process.arch === "ia32")
      throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
  };
  var It = function(e, r) {
    let t = r === "url";
    return e.includes("windows") ? t ? "query_engine.dll.node" : `query_engine-${e}.dll.node` : e.includes("darwin") ? t ? `${At}.dylib.node` : `${At}-${e}.dylib.node` : t ? `${At}.so.node` : `${At}-${e}.so.node`;
  };
  var fe = function(e) {
    return Object.assign(e, { optional: () => cu(e), and: (r) => B(e, r), or: (r) => pu(e, r), select: (r) => r === undefined ? Eo(e) : Eo(r, e) });
  };
  var cu = function(e) {
    return fe({ [ke]: () => ({ match: (r) => {
      let t = {}, n = (i, o) => {
        t[i] = o;
      };
      return r === undefined ? (Ve(e).forEach((i) => n(i, undefined)), { matched: true, selections: t }) : { matched: we(e, r, n), selections: t };
    }, getSelectionKeys: () => Ve(e), matcherType: "optional" }) });
  };
  var B = function(...e) {
    return fe({ [ke]: () => ({ match: (r) => {
      let t = {}, n = (i, o) => {
        t[i] = o;
      };
      return { matched: e.every((i) => we(i, r, n)), selections: t };
    }, getSelectionKeys: () => qr(e, Ve), matcherType: "and" }) });
  };
  var pu = function(...e) {
    return fe({ [ke]: () => ({ match: (r) => {
      let t = {}, n = (i, o) => {
        t[i] = o;
      };
      return qr(e, Ve).forEach((i) => n(i, undefined)), { matched: e.some((i) => we(i, r, n)), selections: t };
    }, getSelectionKeys: () => qr(e, Ve), matcherType: "or" }) });
  };
  var k = function(e) {
    return { [ke]: () => ({ match: (r) => ({ matched: !!e(r) }) }) };
  };
  var Eo = function(...e) {
    let r = typeof e[0] == "string" ? e[0] : undefined, t = e.length === 2 ? e[1] : typeof e[0] == "string" ? undefined : e[0];
    return fe({ [ke]: () => ({ match: (n) => {
      let i = { [r ?? kt]: n };
      return { matched: t === undefined || we(t, n, (o, s) => {
        i[o] = s;
      }), selections: i };
    }, getSelectionKeys: () => [r ?? kt].concat(t === undefined ? [] : Ve(t)) }) });
  };
  var Ee = function(e) {
    return typeof e == "number";
  };
  var Xe = function(e) {
    return typeof e == "string";
  };
  var qe = function(e) {
    return typeof e == "bigint";
  };
  var mr = function(e) {
    return new Bn(e, qn);
  };
  var Dt = function(e, ...r) {
    du.warn() && console.warn(`${mu.warn} ${e}`, ...r);
  };
  async function vo() {
    let e = Nt.default.platform(), r = process.arch;
    if (e === "freebsd") {
      let s = await Ot("freebsd-version");
      if (s && s.trim().length > 0) {
        let l = /^(\d+)\.?/.exec(s);
        if (l)
          return { platform: "freebsd", targetDistro: `freebsd${l[1]}`, arch: r };
      }
    }
    if (e !== "linux")
      return { platform: e, arch: r };
    let t = await yu(), n = await Cu(), i = bu({ arch: r, archFromUname: n, familyDistro: t.familyDistro }), { libssl: o } = await wu(i);
    return { platform: "linux", libssl: o, arch: r, archFromUname: n, ...t };
  }
  var hu = function(e) {
    let r = /^ID="?([^"\n]*)"?$/im, t = /^ID_LIKE="?([^"\n]*)"?$/im, n = r.exec(e), i = n && n[1] && n[1].toLowerCase() || "", o = t.exec(e), s = o && o[1] && o[1].toLowerCase() || "", a = mr({ id: i, idLike: s }).with({ id: "alpine" }, ({ id: l }) => ({ targetDistro: "musl", familyDistro: l, originalDistro: l })).with({ id: "raspbian" }, ({ id: l }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l })).with({ id: "nixos" }, ({ id: l }) => ({ targetDistro: "nixos", originalDistro: l, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).when(({ idLike: l }) => l.includes("debian") || l.includes("ubuntu"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).when(({ idLike: l }) => i === "arch" || l.includes("arch"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l })).when(({ idLike: l }) => l.includes("centos") || l.includes("fedora") || l.includes("rhel") || l.includes("suse"), ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).otherwise(({ id: l }) => ({ targetDistro: undefined, familyDistro: undefined, originalDistro: l }));
    return te(`Found distro info:
${JSON.stringify(a, null, 2)}`), a;
  };
  async function yu() {
    let e = "/etc/os-release";
    try {
      let r = await Vn.default.readFile(e, { encoding: "utf-8" });
      return hu(r);
    } catch {
      return { targetDistro: undefined, familyDistro: undefined, originalDistro: undefined };
    }
  }
  var Eu = function(e) {
    let r = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);
    if (r) {
      let t = `${r[1]}.x`;
      return To(t);
    }
  };
  var bo = function(e) {
    let r = /libssl\.so\.(\d)(\.\d)?/.exec(e);
    if (r) {
      let t = `${r[1]}${r[2] ?? ".0"}.x`;
      return To(t);
    }
  };
  var To = function(e) {
    let r = (() => {
      if (Ro(e))
        return e;
      let t = e.split(".");
      return t[1] = "0", t.join(".");
    })();
    if (gu.includes(r))
      return r;
  };
  var bu = function(e) {
    return mr(e).with({ familyDistro: "musl" }, () => (te('Trying platform-specific paths for "alpine"'), ["/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: r }) => (te('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${r}-linux-gnu`, `/lib/${r}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (te('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: r, arch: t, archFromUname: n }) => (te(`Don't know any platform-specific paths for "${r}" on ${t} (${n})`), []));
  };
  async function wu(e) {
    let r = 'grep -v "libssl.so.0"', t = await wo(e);
    if (t) {
      te(`Found libssl.so file using platform-specific paths: ${t}`);
      let o = bo(t);
      if (te(`The parsed libssl version is: ${o}`), o)
        return { libssl: o, strategy: "libssl-specific-path" };
    }
    te('Falling back to "ldconfig" and other generic paths');
    let n = await Ot(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${r}`);
    if (n || (n = await wo(["/lib64", "/usr/lib64", "/lib"])), n) {
      te(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);
      let o = bo(n);
      if (te(`The parsed libssl version is: ${o}`), o)
        return { libssl: o, strategy: "ldconfig" };
    }
    let i = await Ot("openssl version -v");
    if (i) {
      te(`Found openssl binary with version: ${i}`);
      let o = Eu(i);
      if (te(`The parsed openssl version is: ${o}`), o)
        return { libssl: o, strategy: "openssl-binary" };
    }
    return te("Couldn't find any version of libssl or OpenSSL in the system"), {};
  }
  async function wo(e) {
    for (let r of e) {
      let t = await xu(r);
      if (t)
        return t;
    }
  }
  async function xu(e) {
    try {
      return (await Vn.default.readdir(e)).find((t) => t.startsWith("libssl.so.") && !t.startsWith("libssl.so.0"));
    } catch (r) {
      if (r.code === "ENOENT")
        return;
      throw r;
    }
  }
  async function rr() {
    let { binaryTarget: e } = await Co();
    return e;
  }
  var Pu = function(e) {
    return e.binaryTarget !== undefined;
  };
  async function jn() {
    let { memoized: e, ...r } = await Co();
    return r;
  }
  async function Co() {
    if (Pu(Lt))
      return Promise.resolve({ ...Lt, memoized: true });
    let e = await vo(), r = vu(e);
    return Lt = { ...e, binaryTarget: r }, { ...Lt, memoized: false };
  }
  var vu = function(e) {
    let { platform: r, arch: t, archFromUname: n, libssl: i, targetDistro: o, familyDistro: s, originalDistro: a } = e;
    r === "linux" && !["x64", "arm64"].includes(t) && Dt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures. If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);
    let l = "1.1.x";
    if (r === "linux" && i === undefined) {
      let c = mr({ familyDistro: s }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
      Dt(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".
${c}`);
    }
    let u = "debian";
    if (r === "linux" && o === undefined && te(`Distro is "${a}". Falling back to Prisma engines built for "${u}".`), r === "darwin" && t === "arm64")
      return "darwin-arm64";
    if (r === "darwin")
      return "darwin";
    if (r === "win32")
      return "windows";
    if (r === "freebsd")
      return o;
    if (r === "openbsd")
      return "openbsd";
    if (r === "netbsd")
      return "netbsd";
    if (r === "linux" && o === "nixos")
      return "linux-nixos";
    if (r === "linux" && t === "arm64")
      return `${o === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i || l}`;
    if (r === "linux" && t === "arm")
      return `linux-arm-openssl-${i || l}`;
    if (r === "linux" && o === "musl") {
      let c = "linux-musl";
      return !i || Ro(i) ? c : `${c}-openssl-${i}`;
    }
    return r === "linux" && o && i ? `${o}-openssl-${i}` : (r !== "linux" && Dt(`Prisma detected unknown OS "${r}" and may not work as expected. Defaulting to "linux".`), i ? `${u}-openssl-${i}` : o ? `${o}-openssl-${l}` : `${u}-openssl-${l}`);
  };
  async function Tu(e) {
    try {
      return await e();
    } catch {
      return;
    }
  }
  var Ot = function(e) {
    return Tu(async () => {
      let r = await fu(e);
      return te(`Command "${e}" successfully returned "${r.stdout}"`), r.stdout;
    });
  };
  async function Cu() {
    return typeof Nt.default.machine == "function" ? Nt.default.machine() : (await Ot("uname -m"))?.trim();
  }
  var Ro = function(e) {
    return e.startsWith("1.");
  };
  var Kn = function(e) {
    return (0, $o.default)(e, e, { fallback: ee });
  };
  var jo = function(e) {
    let r = e.ignoreProcessEnv ? {} : process.env, t = (n) => n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o, s) {
      let a = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);
      if (!a)
        return o;
      let l = a[1], u, c;
      if (l === "\\")
        c = a[0], u = c.replace("\\$", "$");
      else {
        let p = a[2];
        c = a[0].substring(l.length), u = Object.hasOwnProperty.call(r, p) ? r[p] : e.parsed[p] || "", u = t(u);
      }
      return o.replace(c, u);
    }, n) ?? n;
    for (let n in e.parsed) {
      let i = Object.hasOwnProperty.call(r, n) ? r[n] : e.parsed[n];
      e.parsed[n] = t(i);
    }
    for (let n in e.parsed)
      r[n] = e.parsed[n];
    return e;
  };
  var jr = function({ rootEnvPath: e, schemaEnvPath: r }, t = { conflictCheck: "none" }) {
    let n = Uo(e);
    t.conflictCheck !== "none" && qu(n, r, t.conflictCheck);
    let i = null;
    return Qo(n?.path, r) || (i = Uo(r)), !n && !i && Yn("No Environment variables loaded"), i?.dotenvResult.error ? console.error(ce(W("Schema Env Error: ")) + i.dotenvResult.error) : { message: [n?.message, i?.message].filter(Boolean).join(`
`), parsed: { ...n?.dotenvResult?.parsed, ...i?.dotenvResult?.parsed } };
  };
  var qu = function(e, r, t) {
    let n = e?.dotenvResult.parsed, i = !Qo(e?.path, r);
    if (n && r && i && qt.default.existsSync(r)) {
      let o = Zn.default.parse(qt.default.readFileSync(r)), s = [];
      for (let a in o)
        n[a] === o[a] && s.push(a);
      if (s.length > 0) {
        let a = gr.default.relative(process.cwd(), e.path), l = gr.default.relative(process.cwd(), r);
        if (t === "error") {
          let u = `There is a conflict between env var${s.length > 1 ? "s" : ""} in ${ee(a)} and ${ee(l)}
Conflicting env vars:
${s.map((c) => `  ${W(c)}`).join(`
`)}

We suggest to move the contents of ${ee(l)} to ${ee(a)} to consolidate your env vars.
`;
          throw new Error(u);
        } else if (t === "warn") {
          let u = `Conflict for env var${s.length > 1 ? "s" : ""} ${s.map((c) => W(c)).join(", ")} in ${ee(a)} and ${ee(l)}
Env vars from ${ee(l)} overwrite the ones from ${ee(a)}
      `;
          console.warn(`${de("warn(prisma)")} ${u}`);
        }
      }
    }
  };
  var Uo = function(e) {
    if (Bu(e)) {
      Yn(`Environment variables loaded from ${e}`);
      let r = Zn.default.config({ path: e, debug: process.env.DOTENV_CONFIG_DEBUG ? true : undefined });
      return { dotenvResult: jo(r), message: Ie(`Environment variables loaded from ${gr.default.relative(process.cwd(), e)}`), path: e };
    } else
      Yn(`Environment variables not found at ${e}`);
    return null;
  };
  var Qo = function(e, r) {
    return e && r && gr.default.resolve(e) === gr.default.resolve(r);
  };
  var Bu = function(e) {
    return !!(e && qt.default.existsSync(e));
  };
  var Ur = function(e) {
    let r = Vu();
    return r || (e?.config.engineType === "library" ? "library" : e?.config.engineType === "binary" ? "binary" : Go);
  };
  var Vu = function() {
    let e = process.env.PRISMA_CLIENT_ENGINE_TYPE;
    return e === "library" ? "library" : e === "binary" ? "binary" : undefined;
  };
  var zo = function() {
    return M.default.join(__dirname, "../");
  };
  var ti = function(e) {
    if (process.platform === "win32")
      return;
    let r = ri.default.statSync(e), t = r.mode | 64 | 8 | 1;
    if (r.mode === t) {
      Yo(`Execution permissions of ${e} are fine`);
      return;
    }
    let n = t.toString(8).slice(-3);
    Yo(`Have to call chmodPlusX on ${e}`), ri.default.chmodSync(e, n);
  };
  var ni = function(e) {
    let r = e.e, t = (a) => `Prisma cannot find the required \`${a}\` system library in your system`, n = r.message.includes("cannot open shared object file"), i = `Please refer to the documentation about Prisma's system requirements: ${Kn("https://pris.ly/d/system-requirements")}`, o = `Unable to require(\`${Ie(e.id)}\`).`, s = mr({ message: r.message, code: r.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a }) => n && a.includes("libz"), () => `${t("libz")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libgcc_s"), () => `${t("libgcc_s")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libssl"), () => {
      let a = e.platformInfo.libssl ? `openssl-${e.platformInfo.libssl}` : "openssl";
      return `${t("libssl")}. Please install ${a} and try again.`;
    }).when(({ message: a }) => a.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({ message: a }) => e.platformInfo.platform === "linux" && a.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i}`);
    return `${o}
${s}

Details: ${r.message}`;
  };
  var ii = function(e) {
    return Qr.default.sep === Qr.default.posix.sep ? e : e.split(Qr.default.sep).join(Qr.default.posix.sep);
  };
  var ai = function(e) {
    return String(new si(e));
  };
  var Ju = function(e) {
    let r;
    if (e.length > 0) {
      let t = e.find((n) => n.fromEnvVar !== null);
      t ? r = `env("${t.fromEnvVar}")` : r = e.map((n) => n.native ? "native" : n.value);
    } else
      r = undefined;
    return r;
  };
  var Hu = function(e) {
    let r = Object.keys(e).reduce((t, n) => Math.max(t, n.length), 0);
    return Object.entries(e).map(([t, n]) => `${t.padEnd(r)} = ${Wu(n)}`).join(`
`);
  };
  var Wu = function(e) {
    return JSON.parse(JSON.stringify(e, (r, t) => Array.isArray(t) ? `[${t.map((n) => JSON.stringify(n)).join(", ")}]` : JSON.stringify(t)));
  };
  var Ku = function(...e) {
    console.log(...e);
  };
  var li = function(e, ...r) {
    es.warn() && console.warn(`${Gr.warn} ${e}`, ...r);
  };
  var zu = function(e, ...r) {
    console.info(`${Gr.info} ${e}`, ...r);
  };
  var Yu = function(e, ...r) {
    console.error(`${Gr.error} ${e}`, ...r);
  };
  var Zu = function(e, ...r) {
    console.log(`${Gr.query} ${e}`, ...r);
  };
  var Vt = function(e, r) {
    if (!e)
      throw new Error(`${r}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`);
  };
  var tr = function(e, r) {
    throw new Error(r);
  };
  var ci = function(e, r) {
    return Object.prototype.hasOwnProperty.call(e, r);
  };
  var hr = function(e, r) {
    let t = {};
    for (let n of Object.keys(e))
      t[n] = r(e[n], n);
    return t;
  };
  var mi = function(e, r) {
    if (e.length === 0)
      return;
    let t = e[0];
    for (let n = 1;n < e.length; n++)
      r(t, e[n]) < 0 && (t = e[n]);
    return t;
  };
  var w = function(e, r) {
    Object.defineProperty(e, "name", { value: r, configurable: true });
  };
  var Wr = function(e) {
    let r;
    return { get() {
      return r || (r = { value: e() }), r.value;
    } };
  };
  var ss = function(e, r) {
    let t = Wr(() => ec(r));
    Object.defineProperty(e, "dmmf", { get: () => t.get() });
  };
  var ec = function(e) {
    return { datamodel: { models: di(e.models), enums: di(e.enums), types: di(e.types) } };
  };
  var di = function(e) {
    return Object.entries(e).map(([r, t]) => ({ name: r, ...t }));
  };
  var gi = function(e, r) {
    Object.defineProperty(e, "name", { value: r, configurable: true });
  };
  var Xr = function(e) {
    return { ok: false, error: e, map() {
      return Xr(e);
    }, flatMap() {
      return Xr(e);
    } };
  };
  var nr = function(e, r) {
    return async (...t) => {
      try {
        return await r(...t);
      } catch (n) {
        let i = e.registerNewError(n);
        return Xr({ kind: "GenericJs", id: i });
      }
    };
  };
  var tc = function(e, r) {
    return (...t) => {
      try {
        return r(...t);
      } catch (n) {
        let i = e.registerNewError(n);
        return Xr({ kind: "GenericJs", id: i });
      }
    };
  };
  var as = function(e, r = ",", t = "", n = "") {
    if (e.length === 0)
      throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
    return new oe([t, ...Array(e.length - 1).fill(r), n], e);
  };
  var Ei = function(e) {
    return new oe([e], []);
  };
  var bi = function(e, ...r) {
    return new oe(e, r);
  };
  var et = function(e) {
    return { getKeys() {
      return Object.keys(e);
    }, getPropertyValue(r) {
      return e[r];
    } };
  };
  var ne = function(e, r) {
    return { getKeys() {
      return [e];
    }, getPropertyValue() {
      return r();
    } };
  };
  var ir = function(e) {
    let r = new xe;
    return { getKeys() {
      return e.getKeys();
    }, getPropertyValue(t) {
      return r.getOrCreate(t, () => e.getPropertyValue(t));
    }, getPropertyDescriptor(t) {
      return e.getPropertyDescriptor?.(t);
    } };
  };
  var Ht = function(e) {
    let r = new Set(e);
    return { getOwnPropertyDescriptor: () => Jt, has: (t, n) => r.has(n), set: (t, n, i) => r.add(n) && Reflect.set(t, n, i), ownKeys: () => [...r] };
  };
  var Pe = function(e, r) {
    let t = nc(r), n = new Set, i = new Proxy(e, { get(o, s) {
      if (n.has(s))
        return o[s];
      let a = t.get(s);
      return a ? a.getPropertyValue(s) : o[s];
    }, has(o, s) {
      if (n.has(s))
        return true;
      let a = t.get(s);
      return a ? a.has?.(s) ?? true : Reflect.has(o, s);
    }, ownKeys(o) {
      let s = cs(Reflect.ownKeys(o), t), a = cs(Array.from(t.keys()), t);
      return [...new Set([...s, ...a, ...n])];
    }, set(o, s, a) {
      return t.get(s)?.getPropertyDescriptor?.(s)?.writable === false ? false : (n.add(s), Reflect.set(o, s, a));
    }, getOwnPropertyDescriptor(o, s) {
      let a = Reflect.getOwnPropertyDescriptor(o, s);
      if (a && !a.configurable)
        return a;
      let l = t.get(s);
      return l ? l.getPropertyDescriptor ? { ...Jt, ...l?.getPropertyDescriptor(s) } : Jt : a;
    }, defineProperty(o, s, a) {
      return n.add(s), Reflect.defineProperty(o, s, a);
    } });
    return i[us] = function() {
      let o = { ...this };
      return delete o[us], o;
    }, i;
  };
  var nc = function(e) {
    let r = new Map;
    for (let t of e) {
      let n = t.getKeys();
      for (let i of n)
        r.set(i, t);
    }
    return r;
  };
  var cs = function(e, r) {
    return e.filter((t) => r.get(t)?.has?.(t) ?? true);
  };
  var rt = function(e) {
    return { getKeys() {
      return e;
    }, has() {
      return false;
    }, getPropertyValue() {
    } };
  };
  var Er = function(e, r) {
    return { batch: e, transaction: r?.kind === "batch" ? { isolationLevel: r.options.isolationLevel } : undefined };
  };
  var ps = function(e) {
    return e.substring(0, 1).toLowerCase() + e.substring(1);
  };
  var wr = function(e) {
    return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
  };
  var Wt = function(e) {
    return e.toString() !== "Invalid Date";
  };
  var z = function(e) {
    var r, t, n, i = e.length - 1, o = "", s = e[0];
    if (i > 0) {
      for (o += s, r = 1;r < i; r++)
        n = e[r] + "", t = b - n.length, t && (o += Ue(t)), o += n;
      s = e[r], n = s + "", t = b - n.length, t && (o += Ue(t));
    } else if (s === 0)
      return "0";
    for (;s % 10 === 0; )
      s /= 10;
    return o + s;
  };
  var se = function(e, r, t) {
    if (e !== ~~e || e < r || e > t)
      throw Error(Ge + e);
  };
  var tt = function(e, r, t, n) {
    var i, o, s, a;
    for (o = e[0];o >= 10; o /= 10)
      --r;
    return --r < 0 ? (r += b, i = 0) : (i = Math.ceil((r + 1) / b), r %= b), o = Q(10, b - r), a = e[i] % o | 0, n == null ? r < 3 ? (r == 0 ? a = a / 100 | 0 : r == 1 && (a = a / 10 | 0), s = t < 4 && a == 99999 || t > 3 && a == 49999 || a == 50000 || a == 0) : s = (t < 4 && a + 1 == o || t > 3 && a + 1 == o / 2) && (e[i + 1] / o / 100 | 0) == Q(10, r - 2) - 1 || (a == o / 2 || a == 0) && (e[i + 1] / o / 100 | 0) == 0 : r < 4 ? (r == 0 ? a = a / 1000 | 0 : r == 1 ? a = a / 100 | 0 : r == 2 && (a = a / 10 | 0), s = (n || t < 4) && a == 9999 || !n && t > 3 && a == 4999) : s = ((n || t < 4) && a + 1 == o || !n && t > 3 && a + 1 == o / 2) && (e[i + 1] / o / 1000 | 0) == Q(10, r - 3) - 1, s;
  };
  var Kt = function(e, r, t) {
    for (var n, i = [0], o, s = 0, a = e.length;s < a; ) {
      for (o = i.length;o--; )
        i[o] *= r;
      for (i[0] += wi.indexOf(e.charAt(s++)), n = 0;n < i.length; n++)
        i[n] > t - 1 && (i[n + 1] === undefined && (i[n + 1] = 0), i[n + 1] += i[n] / t | 0, i[n] %= t);
    }
    return i.reverse();
  };
  var uc = function(e, r) {
    var t, n, i;
    if (r.isZero())
      return r;
    n = r.d.length, n < 32 ? (t = Math.ceil(n / 3), i = (1 / rn(4, t)).toString()) : (t = 16, i = "2.3283064365386962890625e-10"), e.precision += t, r = Pr(e, 1, r.times(i), new e(1));
    for (var o = t;o--; ) {
      var s = r.times(r);
      r = s.times(s).minus(s).times(8).plus(1);
    }
    return e.precision -= t, r;
  };
  var y = function(e, r, t, n) {
    var i, o, s, a, l, u, c, p, m, f = e.constructor;
    e:
      if (r != null) {
        if (p = e.d, !p)
          return e;
        for (i = 1, a = p[0];a >= 10; a /= 10)
          i++;
        if (o = r - i, o < 0)
          o += b, s = r, c = p[m = 0], l = c / Q(10, i - s - 1) % 10 | 0;
        else if (m = Math.ceil((o + 1) / b), a = p.length, m >= a)
          if (n) {
            for (;a++ <= m; )
              p.push(0);
            c = l = 0, i = 1, o %= b, s = o - b + 1;
          } else
            break e;
        else {
          for (c = a = p[m], i = 1;a >= 10; a /= 10)
            i++;
          o %= b, s = o - b + i, l = s < 0 ? 0 : c / Q(10, i - s - 1) % 10 | 0;
        }
        if (n = n || r < 0 || p[m + 1] !== undefined || (s < 0 ? c : c % Q(10, i - s - 1)), u = t < 4 ? (l || n) && (t == 0 || t == (e.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (t == 4 || n || t == 6 && (o > 0 ? s > 0 ? c / Q(10, i - s) : 0 : p[m - 1]) % 10 & 1 || t == (e.s < 0 ? 8 : 7)), r < 1 || !p[0])
          return p.length = 0, u ? (r -= e.e + 1, p[0] = Q(10, (b - r % b) % b), e.e = -r || 0) : p[0] = e.e = 0, e;
        if (o == 0 ? (p.length = m, a = 1, m--) : (p.length = m + 1, a = Q(10, b - o), p[m] = s > 0 ? (c / Q(10, i - s) % Q(10, s) | 0) * a : 0), u)
          for (;; )
            if (m == 0) {
              for (o = 1, s = p[0];s >= 10; s /= 10)
                o++;
              for (s = p[0] += a, a = 1;s >= 10; s /= 10)
                a++;
              o != a && (e.e++, p[0] == he && (p[0] = 1));
              break;
            } else {
              if (p[m] += a, p[m] != he)
                break;
              p[m--] = 0, a = 1;
            }
        for (o = p.length;p[--o] === 0; )
          p.pop();
      }
    return x && (e.e > f.maxE ? (e.d = null, e.e = NaN) : e.e < f.minE && (e.e = 0, e.d = [0])), e;
  };
  var ve = function(e, r, t) {
    if (!e.isFinite())
      return vs(e);
    var n, i = e.e, o = z(e.d), s = o.length;
    return r ? (t && (n = t - s) > 0 ? o = o.charAt(0) + "." + o.slice(1) + Ue(n) : s > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (o = "0." + Ue(-i - 1) + o, t && (n = t - s) > 0 && (o += Ue(n))) : i >= s ? (o += Ue(i + 1 - s), t && (n = t - i - 1) > 0 && (o = o + "." + Ue(n))) : ((n = i + 1) < s && (o = o.slice(0, n) + "." + o.slice(n)), t && (n = t - s) > 0 && (i + 1 === s && (o += "."), o += Ue(n))), o;
  };
  var en = function(e, r) {
    var t = e[0];
    for (r *= b;t >= 10; t /= 10)
      r++;
    return r;
  };
  var Zt = function(e, r, t) {
    if (r > lc)
      throw x = true, t && (e.precision = t), Error(hs);
    return y(new e(zt), r, 1, true);
  };
  var ge = function(e, r, t) {
    if (r > Pi)
      throw Error(hs);
    return y(new e(Yt), r, t, true);
  };
  var ws = function(e) {
    var r = e.length - 1, t = r * b + 1;
    if (r = e[r], r) {
      for (;r % 10 == 0; r /= 10)
        t--;
      for (r = e[0];r >= 10; r /= 10)
        t++;
    }
    return t;
  };
  var Ue = function(e) {
    for (var r = "";e--; )
      r += "0";
    return r;
  };
  var xs = function(e, r, t, n) {
    var i, o = new e(1), s = Math.ceil(n / b + 4);
    for (x = false;; ) {
      if (t % 2 && (o = o.times(r), ds(o.d, s) && (i = true)), t = re(t / 2), t === 0) {
        t = o.d.length - 1, i && o.d[t] === 0 && ++o.d[t];
        break;
      }
      r = r.times(r), ds(r.d, s);
    }
    return x = true, o;
  };
  var ms = function(e) {
    return e.d[e.d.length - 1] & 1;
  };
  var Ps = function(e, r, t) {
    for (var n, i = new e(r[0]), o = 0;++o < r.length; )
      if (n = new e(r[o]), n.s)
        i[t](n) && (i = n);
      else {
        i = n;
        break;
      }
    return i;
  };
  var vi = function(e, r) {
    var t, n, i, o, s, a, l, u = 0, c = 0, p = 0, m = e.constructor, f = m.rounding, g = m.precision;
    if (!e.d || !e.d[0] || e.e > 17)
      return new m(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : NaN);
    for (r == null ? (x = false, l = g) : l = r, a = new m(0.03125);e.e > -2; )
      e = e.times(a), p += 5;
    for (n = Math.log(Q(2, p)) / Math.LN10 * 2 + 5 | 0, l += n, t = o = s = new m(1), m.precision = l;; ) {
      if (o = y(o.times(e), l, 1), t = t.times(++c), a = s.plus(O(o, t, l, 1)), z(a.d).slice(0, l) === z(s.d).slice(0, l)) {
        for (i = p;i--; )
          s = y(s.times(s), l, 1);
        if (r == null)
          if (u < 3 && tt(s.d, l - n, f, u))
            m.precision = l += 10, t = o = a = new m(1), c = 0, u++;
          else
            return y(s, m.precision = g, f, x = true);
        else
          return m.precision = g, s;
      }
      s = a;
    }
  };
  var Qe = function(e, r) {
    var t, n, i, o, s, a, l, u, c, p, m, f = 1, g = 10, h = e, A = h.d, T = h.constructor, C = T.rounding, E = T.precision;
    if (h.s < 0 || !A || !A[0] || !h.e && A[0] == 1 && A.length == 1)
      return new T(A && !A[0] ? -1 / 0 : h.s != 1 ? NaN : A ? 0 : h);
    if (r == null ? (x = false, c = E) : c = r, T.precision = c += g, t = z(A), n = t.charAt(0), Math.abs(o = h.e) < 1500000000000000) {
      for (;n < 7 && n != 1 || n == 1 && t.charAt(1) > 3; )
        h = h.times(e), t = z(h.d), n = t.charAt(0), f++;
      o = h.e, n > 1 ? (h = new T("0." + t), o++) : h = new T(n + "." + t.slice(1));
    } else
      return u = Zt(T, c + 2, E).times(o + ""), h = Qe(new T(n + "." + t.slice(1)), c - g).plus(u), T.precision = E, r == null ? y(h, E, C, x = true) : h;
    for (p = h, l = s = h = O(h.minus(1), h.plus(1), c, 1), m = y(h.times(h), c, 1), i = 3;; ) {
      if (s = y(s.times(m), c, 1), u = l.plus(O(s, new T(i), c, 1)), z(u.d).slice(0, c) === z(l.d).slice(0, c))
        if (l = l.times(2), o !== 0 && (l = l.plus(Zt(T, c + 2, E).times(o + ""))), l = O(l, new T(f), c, 1), r == null)
          if (tt(l.d, c - g, C, a))
            T.precision = c += g, u = s = h = O(p.minus(1), p.plus(1), c, 1), m = y(h.times(h), c, 1), i = a = 1;
          else
            return y(l, T.precision = E, C, x = true);
        else
          return T.precision = E, l;
      l = u, i += 2;
    }
  };
  var vs = function(e) {
    return String(e.s * e.s / 0);
  };
  var Ti = function(e, r) {
    var t, n, i;
    for ((t = r.indexOf(".")) > -1 && (r = r.replace(".", "")), (n = r.search(/e/i)) > 0 ? (t < 0 && (t = n), t += +r.slice(n + 1), r = r.substring(0, n)) : t < 0 && (t = r.length), n = 0;r.charCodeAt(n) === 48; n++)
      ;
    for (i = r.length;r.charCodeAt(i - 1) === 48; --i)
      ;
    if (r = r.slice(n, i), r) {
      if (i -= n, e.e = t = t - n - 1, e.d = [], n = (t + 1) % b, t < 0 && (n += b), n < i) {
        for (n && e.d.push(+r.slice(0, n)), i -= b;n < i; )
          e.d.push(+r.slice(n, n += b));
        r = r.slice(n), n = b - r.length;
      } else
        n -= i;
      for (;n--; )
        r += "0";
      e.d.push(+r), x && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
    } else
      e.e = 0, e.d = [0];
    return e;
  };
  var cc = function(e, r) {
    var t, n, i, o, s, a, l, u, c;
    if (r.indexOf("_") > -1) {
      if (r = r.replace(/(\d)_(?=\d)/g, "$1"), bs.test(r))
        return Ti(e, r);
    } else if (r === "Infinity" || r === "NaN")
      return +r || (e.s = NaN), e.e = NaN, e.d = null, e;
    if (oc.test(r))
      t = 16, r = r.toLowerCase();
    else if (ic.test(r))
      t = 2;
    else if (sc.test(r))
      t = 8;
    else
      throw Error(Ge + r);
    for (o = r.search(/p/i), o > 0 ? (l = +r.slice(o + 1), r = r.substring(2, o)) : r = r.slice(2), o = r.indexOf("."), s = o >= 0, n = e.constructor, s && (r = r.replace(".", ""), a = r.length, o = a - o, i = xs(n, new n(t), o, o * 2)), u = Kt(r, t, he), c = u.length - 1, o = c;u[o] === 0; --o)
      u.pop();
    return o < 0 ? new n(e.s * 0) : (e.e = en(u, c), e.d = u, x = false, s && (e = O(e, i, a * 4)), l && (e = e.times(Math.abs(l) < 54 ? Q(2, l) : or.pow(2, l))), x = true, e);
  };
  var pc = function(e, r) {
    var t, n = r.d.length;
    if (n < 3)
      return r.isZero() ? r : Pr(e, 2, r, r);
    t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, r = r.times(1 / rn(5, t)), r = Pr(e, 2, r, r);
    for (var i, o = new e(5), s = new e(16), a = new e(20);t--; )
      i = r.times(r), r = r.times(o.plus(i.times(s.times(i).minus(a))));
    return r;
  };
  var Pr = function(e, r, t, n, i) {
    var o, s, a, l, u = 1, c = e.precision, p = Math.ceil(c / b);
    for (x = false, l = t.times(t), a = new e(n);; ) {
      if (s = O(a.times(l), new e(r++ * r++), c, 1), a = i ? n.plus(s) : n.minus(s), n = O(s.times(l), new e(r++ * r++), c, 1), s = a.plus(n), s.d[p] !== undefined) {
        for (o = p;s.d[o] === a.d[o] && o--; )
          ;
        if (o == -1)
          break;
      }
      o = a, a = n, n = s, s = o, u++;
    }
    return x = true, s.d.length = p + 1, s;
  };
  var rn = function(e, r) {
    for (var t = e;--r; )
      t *= e;
    return t;
  };
  var Ts = function(e, r) {
    var t, n = r.s < 0, i = ge(e, e.precision, 1), o = i.times(0.5);
    if (r = r.abs(), r.lte(o))
      return Oe = n ? 4 : 1, r;
    if (t = r.divToInt(i), t.isZero())
      Oe = n ? 3 : 2;
    else {
      if (r = r.minus(t.times(i)), r.lte(o))
        return Oe = ms(t) ? n ? 2 : 3 : n ? 4 : 1, r;
      Oe = ms(t) ? n ? 1 : 4 : n ? 3 : 2;
    }
    return r.minus(i).abs();
  };
  var Ci = function(e, r, t, n) {
    var i, o, s, a, l, u, c, p, m, f = e.constructor, g = t !== undefined;
    if (g ? (se(t, 1, Je), n === undefined ? n = f.rounding : se(n, 0, 8)) : (t = f.precision, n = f.rounding), !e.isFinite())
      c = vs(e);
    else {
      for (c = ve(e), s = c.indexOf("."), g ? (i = 2, r == 16 ? t = t * 4 - 3 : r == 8 && (t = t * 3 - 2)) : i = r, s >= 0 && (c = c.replace(".", ""), m = new f(1), m.e = c.length - s, m.d = Kt(ve(m), 10, i), m.e = m.d.length), p = Kt(c, 10, i), o = l = p.length;p[--l] == 0; )
        p.pop();
      if (!p[0])
        c = g ? "0p+0" : "0";
      else {
        if (s < 0 ? o-- : (e = new f(e), e.d = p, e.e = o, e = O(e, m, t, n, 0, i), p = e.d, o = e.e, u = gs), s = p[t], a = i / 2, u = u || p[t + 1] !== undefined, u = n < 4 ? (s !== undefined || u) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : s > a || s === a && (n === 4 || u || n === 6 && p[t - 1] & 1 || n === (e.s < 0 ? 8 : 7)), p.length = t, u)
          for (;++p[--t] > i - 1; )
            p[t] = 0, t || (++o, p.unshift(1));
        for (l = p.length;!p[l - 1]; --l)
          ;
        for (s = 0, c = "";s < l; s++)
          c += wi.charAt(p[s]);
        if (g) {
          if (l > 1)
            if (r == 16 || r == 8) {
              for (s = r == 16 ? 4 : 3, --l;l % s; l++)
                c += "0";
              for (p = Kt(c, i, r), l = p.length;!p[l - 1]; --l)
                ;
              for (s = 1, c = "1.";s < l; s++)
                c += wi.charAt(p[s]);
            } else
              c = c.charAt(0) + "." + c.slice(1);
          c = c + (o < 0 ? "p" : "p+") + o;
        } else if (o < 0) {
          for (;++o; )
            c = "0" + c;
          c = "0." + c;
        } else if (++o > l)
          for (o -= l;o--; )
            c += "0";
        else
          o < l && (c = c.slice(0, o) + "." + c.slice(o));
      }
      c = (r == 16 ? "0x" : r == 2 ? "0b" : r == 8 ? "0o" : "") + c;
    }
    return e.s < 0 ? "-" + c : c;
  };
  var ds = function(e, r) {
    if (e.length > r)
      return e.length = r, true;
  };
  var mc = function(e) {
    return new this(e).abs();
  };
  var dc = function(e) {
    return new this(e).acos();
  };
  var fc = function(e) {
    return new this(e).acosh();
  };
  var gc = function(e, r) {
    return new this(e).plus(r);
  };
  var hc = function(e) {
    return new this(e).asin();
  };
  var yc = function(e) {
    return new this(e).asinh();
  };
  var Ec = function(e) {
    return new this(e).atan();
  };
  var bc = function(e) {
    return new this(e).atanh();
  };
  var wc = function(e, r) {
    e = new this(e), r = new this(r);
    var t, n = this.precision, i = this.rounding, o = n + 4;
    return !e.s || !r.s ? t = new this(NaN) : !e.d && !r.d ? (t = ge(this, o, 1).times(r.s > 0 ? 0.25 : 0.75), t.s = e.s) : !r.d || e.isZero() ? (t = r.s < 0 ? ge(this, n, i) : new this(0), t.s = e.s) : !e.d || r.isZero() ? (t = ge(this, o, 1).times(0.5), t.s = e.s) : r.s < 0 ? (this.precision = o, this.rounding = 1, t = this.atan(O(e, r, o, 1)), r = ge(this, o, 1), this.precision = n, this.rounding = i, t = e.s < 0 ? t.minus(r) : t.plus(r)) : t = this.atan(O(e, r, o, 1)), t;
  };
  var xc = function(e) {
    return new this(e).cbrt();
  };
  var Pc = function(e) {
    return y(e = new this(e), e.e + 1, 2);
  };
  var vc = function(e, r, t) {
    return new this(e).clamp(r, t);
  };
  var Tc = function(e) {
    if (!e || typeof e != "object")
      throw Error(Xt + "Object expected");
    var r, t, n, i = e.defaults === true, o = ["precision", 1, Je, "rounding", 0, 8, "toExpNeg", -xr, 0, "toExpPos", 0, xr, "maxE", 0, xr, "minE", -xr, 0, "modulo", 0, 9];
    for (r = 0;r < o.length; r += 3)
      if (t = o[r], i && (this[t] = xi[t]), (n = e[t]) !== undefined)
        if (re(n) === n && n >= o[r + 1] && n <= o[r + 2])
          this[t] = n;
        else
          throw Error(Ge + t + ": " + n);
    if (t = "crypto", i && (this[t] = xi[t]), (n = e[t]) !== undefined)
      if (n === true || n === false || n === 0 || n === 1)
        if (n)
          if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
            this[t] = true;
          else
            throw Error(ys);
        else
          this[t] = false;
      else
        throw Error(Ge + t + ": " + n);
    return this;
  };
  var Cc = function(e) {
    return new this(e).cos();
  };
  var Rc = function(e) {
    return new this(e).cosh();
  };
  var Cs = function(e) {
    var r, t, n;
    function i(o) {
      var s, a, l, u = this;
      if (!(u instanceof i))
        return new i(o);
      if (u.constructor = i, fs(o)) {
        u.s = o.s, x ? !o.d || o.e > i.maxE ? (u.e = NaN, u.d = null) : o.e < i.minE ? (u.e = 0, u.d = [0]) : (u.e = o.e, u.d = o.d.slice()) : (u.e = o.e, u.d = o.d ? o.d.slice() : o.d);
        return;
      }
      if (l = typeof o, l === "number") {
        if (o === 0) {
          u.s = 1 / o < 0 ? -1 : 1, u.e = 0, u.d = [0];
          return;
        }
        if (o < 0 ? (o = -o, u.s = -1) : u.s = 1, o === ~~o && o < 1e7) {
          for (s = 0, a = o;a >= 10; a /= 10)
            s++;
          x ? s > i.maxE ? (u.e = NaN, u.d = null) : s < i.minE ? (u.e = 0, u.d = [0]) : (u.e = s, u.d = [o]) : (u.e = s, u.d = [o]);
          return;
        } else if (o * 0 !== 0) {
          o || (u.s = NaN), u.e = NaN, u.d = null;
          return;
        }
        return Ti(u, o.toString());
      } else if (l !== "string")
        throw Error(Ge + o);
      return (a = o.charCodeAt(0)) === 45 ? (o = o.slice(1), u.s = -1) : (a === 43 && (o = o.slice(1)), u.s = 1), bs.test(o) ? Ti(u, o) : cc(u, o);
    }
    if (i.prototype = d, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = Tc, i.clone = Cs, i.isDecimal = fs, i.abs = mc, i.acos = dc, i.acosh = fc, i.add = gc, i.asin = hc, i.asinh = yc, i.atan = Ec, i.atanh = bc, i.atan2 = wc, i.cbrt = xc, i.ceil = Pc, i.clamp = vc, i.cos = Cc, i.cosh = Rc, i.div = Sc, i.exp = Ac, i.floor = Ic, i.hypot = _c, i.ln = kc, i.log = Dc, i.log10 = Nc, i.log2 = Lc, i.max = Oc, i.min = Fc, i.mod = Mc, i.mul = $c, i.pow = qc, i.random = Bc, i.round = Vc, i.sign = jc, i.sin = Uc, i.sinh = Qc, i.sqrt = Gc, i.sub = Jc, i.sum = Hc, i.tan = Wc, i.tanh = Kc, i.trunc = zc, e === undefined && (e = {}), e && e.defaults !== true)
      for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], r = 0;r < n.length; )
        e.hasOwnProperty(t = n[r++]) || (e[t] = this[t]);
    return i.config(e), i;
  };
  var Sc = function(e, r) {
    return new this(e).div(r);
  };
  var Ac = function(e) {
    return new this(e).exp();
  };
  var Ic = function(e) {
    return y(e = new this(e), e.e + 1, 3);
  };
  var _c = function() {
    var e, r, t = new this(0);
    for (x = false, e = 0;e < arguments.length; )
      if (r = new this(arguments[e++]), r.d)
        t.d && (t = t.plus(r.times(r)));
      else {
        if (r.s)
          return x = true, new this(1 / 0);
        t = r;
      }
    return x = true, t.sqrt();
  };
  var fs = function(e) {
    return e instanceof or || e && e.toStringTag === Es || false;
  };
  var kc = function(e) {
    return new this(e).ln();
  };
  var Dc = function(e, r) {
    return new this(e).log(r);
  };
  var Lc = function(e) {
    return new this(e).log(2);
  };
  var Nc = function(e) {
    return new this(e).log(10);
  };
  var Oc = function() {
    return Ps(this, arguments, "lt");
  };
  var Fc = function() {
    return Ps(this, arguments, "gt");
  };
  var Mc = function(e, r) {
    return new this(e).mod(r);
  };
  var $c = function(e, r) {
    return new this(e).mul(r);
  };
  var qc = function(e, r) {
    return new this(e).pow(r);
  };
  var Bc = function(e) {
    var r, t, n, i, o = 0, s = new this(1), a = [];
    if (e === undefined ? e = this.precision : se(e, 1, Je), n = Math.ceil(e / b), this.crypto)
      if (crypto.getRandomValues)
        for (r = crypto.getRandomValues(new Uint32Array(n));o < n; )
          i = r[o], i >= 4290000000 ? r[o] = crypto.getRandomValues(new Uint32Array(1))[0] : a[o++] = i % 1e7;
      else if (crypto.randomBytes) {
        for (r = crypto.randomBytes(n *= 4);o < n; )
          i = r[o] + (r[o + 1] << 8) + (r[o + 2] << 16) + ((r[o + 3] & 127) << 24), i >= 2140000000 ? crypto.randomBytes(4).copy(r, o) : (a.push(i % 1e7), o += 4);
        o = n / 4;
      } else
        throw Error(ys);
    else
      for (;o < n; )
        a[o++] = Math.random() * 1e7 | 0;
    for (n = a[--o], e %= b, n && e && (i = Q(10, b - e), a[o] = (n / i | 0) * i);a[o] === 0; o--)
      a.pop();
    if (o < 0)
      t = 0, a = [0];
    else {
      for (t = -1;a[0] === 0; t -= b)
        a.shift();
      for (n = 1, i = a[0];i >= 10; i /= 10)
        n++;
      n < b && (t -= b - n);
    }
    return s.e = t, s.d = a, s;
  };
  var Vc = function(e) {
    return y(e = new this(e), e.e + 1, this.rounding);
  };
  var jc = function(e) {
    return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
  };
  var Uc = function(e) {
    return new this(e).sin();
  };
  var Qc = function(e) {
    return new this(e).sinh();
  };
  var Gc = function(e) {
    return new this(e).sqrt();
  };
  var Jc = function(e, r) {
    return new this(e).sub(r);
  };
  var Hc = function() {
    var e = 0, r = arguments, t = new this(r[e]);
    for (x = false;t.s && ++e < r.length; )
      t = t.plus(r[e]);
    return x = true, y(t, this.precision, this.rounding);
  };
  var Wc = function(e) {
    return new this(e).tan();
  };
  var Kc = function(e) {
    return new this(e).tanh();
  };
  var zc = function(e) {
    return y(e = new this(e), e.e + 1, 1);
  };
  var vr = function(e) {
    return or.isDecimal(e) ? true : e !== null && typeof e == "object" && typeof e.s == "number" && typeof e.e == "number" && typeof e.toFixed == "function" && Array.isArray(e.d);
  };
  var Tr = function(e) {
    return e instanceof nt;
  };
  var an = function(e) {
    return new Ri(As(e));
  };
  var As = function(e) {
    let r = new J;
    for (let [t, n] of Object.entries(e)) {
      let i = new sn(t, Is(n));
      r.addField(i);
    }
    return r;
  };
  var Is = function(e) {
    if (typeof e == "string")
      return new H(JSON.stringify(e));
    if (typeof e == "number" || typeof e == "boolean")
      return new H(String(e));
    if (typeof e == "bigint")
      return new H(`${e}n`);
    if (e === null)
      return new H("null");
    if (e === undefined)
      return new H("undefined");
    if (vr(e))
      return new H(`new Prisma.Decimal("${e.toFixed()}")`);
    if (e instanceof Uint8Array)
      return Buffer.isBuffer(e) ? new H(`Buffer.alloc(${e.byteLength})`) : new H(`new Uint8Array(${e.byteLength})`);
    if (e instanceof Date) {
      let r = Wt(e) ? e.toISOString() : "Invalid Date";
      return new H(`new Date("${r}")`);
    }
    return e instanceof Ne ? new H(`Prisma.${e._getName()}`) : Tr(e) ? new H(`prisma.${ps(e.modelName)}.\$fields.${e.name}`) : Array.isArray(e) ? Zc(e) : typeof e == "object" ? As(e) : new H(Object.prototype.toString.call(e));
  };
  var Zc = function(e) {
    let r = new Rr;
    for (let t of e)
      r.addItem(Is(t));
    return r;
  };
  var _s = function(e) {
    if (e === undefined)
      return "";
    let r = an(e);
    return new br(0, { colors: on }).write(r).toString();
  };
  var sr = function({ error: e, user_facing_error: r }, t, n) {
    return r.error_code ? new V(ep(r, n), { code: r.error_code, clientVersion: t, meta: r.meta, batchRequestIdx: r.batch_request_idx }) : new j(e, { clientVersion: t, batchRequestIdx: r.batch_request_idx });
  };
  var ep = function(e, r) {
    let t = e.message;
    return (r === "postgresql" || r === "postgres" || r === "mysql") && e.error_code === Xc && (t += `
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`), t;
  };
  var ks = function(e) {
    var r = e.split(`
`);
    return r.reduce(function(t, n) {
      var i = np(n) || op(n) || lp(n) || mp(n) || cp(n);
      return i && t.push(i), t;
    }, []);
  };
  var np = function(e) {
    var r = rp.exec(e);
    if (!r)
      return null;
    var t = r[2] && r[2].indexOf("native") === 0, n = r[2] && r[2].indexOf("eval") === 0, i = tp.exec(r[2]);
    return n && i != null && (r[2] = i[1], r[3] = i[2], r[4] = i[3]), { file: t ? null : r[2], methodName: r[1] || it, arguments: t ? [r[2]] : [], lineNumber: r[3] ? +r[3] : null, column: r[4] ? +r[4] : null };
  };
  var op = function(e) {
    var r = ip.exec(e);
    return r ? { file: r[2], methodName: r[1] || it, arguments: [], lineNumber: +r[3], column: r[4] ? +r[4] : null } : null;
  };
  var lp = function(e) {
    var r = sp.exec(e);
    if (!r)
      return null;
    var t = r[3] && r[3].indexOf(" > eval") > -1, n = ap.exec(r[3]);
    return t && n != null && (r[3] = n[1], r[4] = n[2], r[5] = null), { file: r[3], methodName: r[1] || it, arguments: r[2] ? r[2].split(",") : [], lineNumber: r[4] ? +r[4] : null, column: r[5] ? +r[5] : null };
  };
  var cp = function(e) {
    var r = up.exec(e);
    return r ? { file: r[3], methodName: r[1] || it, arguments: [], lineNumber: +r[4], column: r[5] ? +r[5] : null } : null;
  };
  var mp = function(e) {
    var r = pp.exec(e);
    return r ? { file: r[2], methodName: r[1] || it, arguments: [], lineNumber: +r[3], column: r[4] ? +r[4] : null } : null;
  };
  var We = function(e) {
    return e === "minimal" ? typeof $EnabledCallSite == "function" && e !== "minimal" ? new $EnabledCallSite : new Si : new Ai;
  };
  var Sr = function(e = {}) {
    let r = fp(e);
    return Object.entries(r).reduce((n, [i, o]) => (Ds[i] !== undefined ? n.select[i] = { select: o } : n[i] = o, n), { select: {} });
  };
  var fp = function(e = {}) {
    return typeof e._count == "boolean" ? { ...e, _count: { _all: e._count } } : e;
  };
  var ln = function(e = {}) {
    return (r) => (typeof e._count == "boolean" && (r._count = r._count._all), r);
  };
  var Ls = function(e, r) {
    let t = ln(e);
    return r({ action: "aggregate", unpacker: t, argsMapper: Sr })(e);
  };
  var gp = function(e = {}) {
    let { select: r, ...t } = e;
    return typeof r == "object" ? Sr({ ...t, _count: r }) : Sr({ ...t, _count: { _all: true } });
  };
  var hp = function(e = {}) {
    return typeof e.select == "object" ? (r) => ln(e)(r)._count : (r) => ln(e)(r)._count._all;
  };
  var Ns = function(e, r) {
    return r({ action: "count", unpacker: hp(e), argsMapper: gp })(e);
  };
  var yp = function(e = {}) {
    let r = Sr(e);
    if (Array.isArray(r.by))
      for (let t of r.by)
        typeof t == "string" && (r.select[t] = true);
    else
      typeof r.by == "string" && (r.select[r.by] = true);
    return r;
  };
  var Ep = function(e = {}) {
    return (r) => (typeof e?._count == "boolean" && r.forEach((t) => {
      t._count = t._count._all;
    }), r);
  };
  var Os = function(e, r) {
    return r({ action: "groupBy", unpacker: Ep(e), argsMapper: yp })(e);
  };
  var Fs = function(e, r, t) {
    if (r === "aggregate")
      return (n) => Ls(n, t);
    if (r === "count")
      return (n) => Ns(n, t);
    if (r === "groupBy")
      return (n) => Os(n, t);
  };
  var Ms = function(e, r) {
    let t = r.fields.filter((i) => !i.relationName), n = pi(t, (i) => i.name);
    return new Proxy({}, { get(i, o) {
      if (o in i || typeof o == "symbol")
        return i[o];
      let s = n[o];
      if (s)
        return new nt(e, o, s.type, s.isList, s.kind === "enum");
    }, ...Ht(Object.keys(n)) });
  };
  var bp = function(e, r) {
    return e === undefined || r === undefined ? [] : [...r, "select", e];
  };
  var wp = function(e, r, t) {
    return r === undefined ? e ?? {} : qs(r, t, e || true);
  };
  var _i = function(e, r, t, n, i, o) {
    let a = e._runtimeDataModel.models[r].fields.reduce((l, u) => ({ ...l, [u.name]: u }), {});
    return (l) => {
      let u = We(e._errorFormat), c = bp(n, i), p = wp(l, o, c), m = t({ dataPath: c, callsite: u })(p), f = xp(e, r);
      return new Proxy(m, { get(g, h) {
        if (!f.includes(h))
          return g[h];
        let T = [a[h].type, t, h], C = [c, p];
        return _i(e, ...T, ...C);
      }, ...Ht([...f, ...Object.getOwnPropertyNames(m)]) });
    };
  };
  var xp = function(e, r) {
    return e._runtimeDataModel.models[r].fields.filter((t) => t.kind === "object").map((t) => t.name);
  };
  var ye = function(e, r, t, n, i) {
    this.type = e, this.content = r, this.alias = t, this.length = (n || "").length | 0, this.greedy = !!i;
  };
  var Tp = function(e) {
    return Bs[e] || Pp;
  };
  var Vs = function(e) {
    return Cp(e, P.languages.javascript);
  };
  var Cp = function(e, r) {
    return P.tokenize(e, r).map((n) => ye.stringify(n)).join("");
  };
  var Us = function(e) {
    return (0, js.default)(e);
  };
  var Ap = function({ message: e, originalMethod: r, isPanic: t, callArguments: n }) {
    return { functionName: `prisma.${r}()`, message: e, isPanic: t ?? false, callArguments: n };
  };
  var Ip = function({ callsite: e, message: r, originalMethod: t, isPanic: n, callArguments: i }, o) {
    let s = Ap({ message: r, originalMethod: t, isPanic: n, callArguments: i });
    if (!e || typeof window < "u" || false)
      return s;
    let a = e.getLocation();
    if (!a || !a.lineNumber || !a.columnNumber)
      return s;
    let l = Math.max(1, a.lineNumber - 3), u = cn.read(a.fileName)?.slice(l, a.lineNumber), c = u?.lineAt(a.lineNumber);
    if (u && c) {
      let p = kp(c), m = _p(c);
      if (!m)
        return s;
      s.functionName = `${m.code})`, s.location = a, n || (u = u.mapLineAt(a.lineNumber, (g) => g.slice(0, m.openingBraceIndex))), u = o.highlightSource(u);
      let f = String(u.lastLineNumber).length;
      if (s.contextLines = u.mapLines((g, h) => o.gray(String(h).padStart(f)) + " " + g).mapLines((g) => o.dim(g)).prependSymbolAt(a.lineNumber, o.bold(o.red("\u2192"))), i) {
        let g = p + f + 1;
        g += 2, s.callArguments = (0, Gs.default)(i, g).slice(g);
      }
    }
    return s;
  };
  var _p = function(e) {
    let r = Object.keys(De.ModelAction).join("|"), n = new RegExp(String.raw`\.(${r})\(`).exec(e);
    if (n) {
      let i = n.index + n[0].length, o = e.lastIndexOf(" ", n.index) + 1;
      return { code: e.slice(o, i), openingBraceIndex: i };
    }
    return null;
  };
  var kp = function(e) {
    let r = 0;
    for (let t = 0;t < e.length; t++) {
      if (e.charAt(t) !== " ")
        return r;
      r++;
    }
    return r;
  };
  var Dp = function({ functionName: e, location: r, message: t, isPanic: n, contextLines: i, callArguments: o }, s) {
    let a = [""], l = r ? " in" : ":";
    if (n ? (a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)), a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))) : a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)), r && a.push(s.underline(Lp(r))), i) {
      a.push("");
      let u = [i.toString()];
      o && (u.push(o), u.push(s.dim(")"))), a.push(u.join("")), o && a.push("");
    } else
      a.push(""), o && a.push(o), a.push("");
    return a.push(t), a.join(`
`);
  };
  var Lp = function(e) {
    let r = [e.fileName];
    return e.lineNumber && r.push(String(e.lineNumber)), e.columnNumber && r.push(String(e.columnNumber)), r.join(":");
  };
  var Ar = function(e) {
    let r = e.showColors ? Rp : Sp, t;
    return t = Ip(e, r), Dp(t, r);
  };
  var Js = function(e, r, t, n) {
    return e === De.ModelAction.findFirstOrThrow || e === De.ModelAction.findUniqueOrThrow ? Np(r, t, n) : n;
  };
  var Np = function(e, r, t) {
    return async (n) => {
      if ("rejectOnNotFound" in n.args) {
        let o = Ar({ originalMethod: n.clientMethod, callsite: n.callsite, message: "'rejectOnNotFound' option is not supported" });
        throw new K(o, { clientVersion: r });
      }
      return await t(n).catch((o) => {
        throw o instanceof V && o.code === "P2025" ? new Le(`No ${e} found`, r) : o;
      });
    };
  };
  var Re = function(e) {
    return e.replace(/^./, (r) => r.toLowerCase());
  };
  var ki = function(e, r) {
    let t = e._extensions.getAllModelExtensions(r) ?? {}, n = [Mp(e, r), qp(e, r), et(t), ne("name", () => r), ne("$name", () => r), ne("$parent", () => e._appliedParent)];
    return Pe({}, n);
  };
  var Mp = function(e, r) {
    let t = Re(r), n = Object.keys(De.ModelAction).concat("count");
    return { getKeys() {
      return n;
    }, getPropertyValue(i) {
      let o = i, s = (l) => e._request(l);
      s = Js(o, r, e._clientVersion, s);
      let a = (l) => (u) => {
        let c = We(e._errorFormat);
        return e._createPrismaPromise((p) => {
          let m = { args: u, dataPath: [], action: o, model: r, clientMethod: `${t}.${i}`, jsModelName: t, transaction: p, callsite: c };
          return s({ ...m, ...l });
        });
      };
      return Op.includes(o) ? _i(e, r, a) : $p(i) ? Fs(e, i, a) : a({});
    } };
  };
  var $p = function(e) {
    return Fp.includes(e);
  };
  var qp = function(e, r) {
    return ir(ne("fields", () => {
      let t = e._runtimeDataModel.models[r];
      return Ms(r, t);
    }));
  };
  var Hs = function(e) {
    return e.replace(/^./, (r) => r.toUpperCase());
  };
  var ot = function(e) {
    let r = [Bp(e), ne(Di, () => e), ne("$parent", () => e._appliedParent)], t = e._extensions.getAllClientExtensions();
    return t && r.push(et(t)), Pe(e, r);
  };
  var Bp = function(e) {
    let r = Object.keys(e._runtimeDataModel.models), t = r.map(Re), n = [...new Set(r.concat(t))];
    return ir({ getKeys() {
      return n;
    }, getPropertyValue(i) {
      let o = Hs(i);
      if (e._runtimeDataModel.models[o] !== undefined)
        return ki(e, o);
      if (e._runtimeDataModel.models[i] !== undefined)
        return ki(e, i);
    }, getPropertyDescriptor(i) {
      if (!t.includes(i))
        return { enumerable: false };
    } });
  };
  var Ws = function(e) {
    return e[Di] ? e[Di] : e;
  };
  var Ks = function(e) {
    if (typeof e == "function")
      return e(this);
    if (e.client?.__AccelerateEngine) {
      let t = e.client.__AccelerateEngine;
      this._originalClient._engine = new t(this._originalClient._accelerateEngineConfig);
    }
    let r = Object.create(this._originalClient, { _extensions: { value: this._extensions.append(e) }, _appliedParent: { value: this, configurable: true }, $use: { value: undefined }, $on: { value: undefined } });
    return ot(r);
  };
  var zs = function({ result: e, modelName: r, select: t, extensions: n }) {
    let i = n.getAllComputedFields(r);
    if (!i)
      return e;
    let o = [], s = [];
    for (let a of Object.values(i)) {
      if (t) {
        if (!t[a.name])
          continue;
        let l = a.needs.filter((u) => !t[u]);
        l.length > 0 && s.push(rt(l));
      }
      Vp(e, a.needs) && o.push(jp(a, Pe(e, o)));
    }
    return o.length > 0 || s.length > 0 ? Pe(e, [...o, ...s]) : e;
  };
  var Vp = function(e, r) {
    return r.every((t) => ci(e, t));
  };
  var jp = function(e, r) {
    return ir(ne(e.name, () => e.compute(r)));
  };
  var pn = function({ visitor: e, result: r, args: t, runtimeDataModel: n, modelName: i }) {
    if (Array.isArray(r)) {
      for (let s = 0;s < r.length; s++)
        r[s] = pn({ result: r[s], args: t, modelName: i, runtimeDataModel: n, visitor: e });
      return r;
    }
    let o = e(r, i, t) ?? r;
    return t.include && Ys({ includeOrSelect: t.include, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), t.select && Ys({ includeOrSelect: t.select, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), o;
  };
  var Ys = function({ includeOrSelect: e, result: r, parentModelName: t, runtimeDataModel: n, visitor: i }) {
    for (let [o, s] of Object.entries(e)) {
      if (!s || r[o] == null)
        continue;
      let l = n.models[t].fields.find((c) => c.name === o);
      if (!l || l.kind !== "object" || !l.relationName)
        continue;
      let u = typeof s == "object" ? s : {};
      r[o] = pn({ visitor: i, result: r[o], args: u, modelName: l.type, runtimeDataModel: n });
    }
  };
  var Zs = function({ result: e, modelName: r, args: t, extensions: n, runtimeDataModel: i }) {
    return n.isEmpty() || e == null || typeof e != "object" || !i.models[r] ? e : pn({ result: e, args: t ?? {}, modelName: r, runtimeDataModel: i, visitor: (s, a, l) => zs({ result: s, modelName: Re(a), select: l.select, extensions: n }) });
  };
  var Xs = function(e) {
    if (e instanceof oe)
      return Up(e);
    if (Array.isArray(e)) {
      let t = [e[0]];
      for (let n = 1;n < e.length; n++)
        t[n] = st(e[n]);
      return t;
    }
    let r = {};
    for (let t in e)
      r[t] = st(e[t]);
    return r;
  };
  var Up = function(e) {
    return new oe(e.strings, e.values);
  };
  var st = function(e) {
    if (typeof e != "object" || e == null || e instanceof Ne || Tr(e))
      return e;
    if (vr(e))
      return new Te(e.toFixed());
    if (wr(e))
      return new Date(+e);
    if (ArrayBuffer.isView(e))
      return e.slice(0);
    if (Array.isArray(e)) {
      let r = e.length, t;
      for (t = Array(r);r--; )
        t[r] = st(e[r]);
      return t;
    }
    if (typeof e == "object") {
      let r = {};
      for (let t in e)
        t === "__proto__" ? Object.defineProperty(r, t, { value: st(e[t]), configurable: true, enumerable: true, writable: true }) : r[t] = st(e[t]);
      return r;
    }
    tr(e, "Unknown value");
  };
  var ra = function(e, r, t, n = 0) {
    return e._createPrismaPromise((i) => {
      let o = r.customDataProxyFetch;
      return "transaction" in r && i !== undefined && (r.transaction?.kind === "batch" && r.transaction.lock.then(), r.transaction = i), n === t.length ? e._executeRequest(r) : t[n]({ model: r.model, operation: r.model ? r.action : r.clientMethod, args: Xs(r.args ?? {}), __internalParams: r, query: (s, a = r) => {
        let l = a.customDataProxyFetch;
        return a.customDataProxyFetch = oa(o, l), a.args = s, ra(e, a, t, n + 1);
      } });
    });
  };
  var ta = function(e, r) {
    let { jsModelName: t, action: n, clientMethod: i } = r, o = t ? n : i;
    if (e._extensions.isEmpty())
      return e._executeRequest(r);
    let s = e._extensions.getAllQueryCallbacks(t ?? "$none", o);
    return ra(e, r, s);
  };
  var na = function(e) {
    return (r) => {
      let t = { requests: r }, n = r[0].extensions.getAllBatchQueryCallbacks();
      return n.length ? ia(t, n, 0, e) : e(t);
    };
  };
  var ia = function(e, r, t, n) {
    if (t === r.length)
      return n(e);
    let i = e.customDataProxyFetch, o = e.requests[0].transaction;
    return r[t]({ args: { queries: e.requests.map((s) => ({ model: s.modelName, operation: s.action, args: s.args })), transaction: o ? { isolationLevel: o.kind === "batch" ? o.isolationLevel : undefined } : undefined }, __internalParams: e, query(s, a = e) {
      let l = a.customDataProxyFetch;
      return a.customDataProxyFetch = oa(i, l), ia(a, r, t + 1, n);
    } });
  };
  var oa = function(e = ea, r = ea) {
    return (t) => e(r(t));
  };
  var aa = function(e, r, t) {
    let n = Re(t);
    return !r.result || !(r.result.$allModels || r.result[n]) ? e : Qp({ ...e, ...sa(r.name, e, r.result.$allModels), ...sa(r.name, e, r.result[n]) });
  };
  var Qp = function(e) {
    let r = new xe, t = (n, i) => r.getOrCreate(n, () => i.has(n) ? [n] : (i.add(n), e[n] ? e[n].needs.flatMap((o) => t(o, i)) : [n]));
    return hr(e, (n) => ({ ...n, needs: t(n.name, new Set) }));
  };
  var sa = function(e, r, t) {
    return t ? hr(t, ({ needs: n, compute: i }, o) => ({ name: o, needs: n ? Object.keys(n).filter((s) => n[s]) : [], compute: Gp(r, o, i) })) : {};
  };
  var Gp = function(e, r, t) {
    let n = e?.[r]?.compute;
    return n ? (i) => t({ ...i, [r]: n(i) }) : t;
  };
  var la = function(e, r) {
    if (!r)
      return e;
    let t = { ...e };
    for (let n of Object.values(r))
      if (e[n.name])
        for (let i of n.needs)
          t[i] = true;
    return t;
  };
  var pa = function({ postinstall: e, ciName: r, clientVersion: t }) {
    if (ua("checkPlatformCaching:postinstall", e), ua("checkPlatformCaching:ciName", r), e === true && r && r in ca) {
      let n = `Prisma has detected that this project was built on ${r}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ca[r]}-build`;
      throw console.error(n), new R(n, t);
    }
  };
  var ma = function(e, r) {
    return e ? e.datasources ? e.datasources : e.datasourceUrl ? { [r[0]]: { url: e.datasourceUrl } } : {} : {};
  };
  var da = function() {
    return typeof Netlify == "object" ? "netlify" : typeof EdgeRuntime == "string" ? "edge-light" : globalThis.navigator?.userAgent === Jp ? "workerd" : globalThis.Deno ? "deno" : globalThis.__lagon__ ? "lagon" : globalThis.process?.release?.name === Hp ? "node" : globalThis.Bun ? "bun" : globalThis.fastly ? "fastly" : "unknown";
  };
  var fn = function() {
    let e = da();
    return { id: e, prettyName: Wp[e] || e, isEdge: ["workerd", "deno", "netlify", "edge-light"].includes(e) };
  };
  var gn = function(e) {
    let { runtimeBinaryTarget: r } = e;
    return `Add "${r}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Kp(e)}`;
  };
  var Kp = function(e) {
    let { generator: r, generatorBinaryTargets: t, runtimeBinaryTarget: n } = e, i = { fromEnvVar: null, value: n }, o = [...t, i];
    return ai({ ...r, binaryTargets: o });
  };
  var Ke = function(e) {
    let { runtimeBinaryTarget: r } = e;
    return `Prisma Client could not locate the Query Engine for runtime "${r}".`;
  };
  var ze = function(e) {
    let { searchedLocations: r } = e;
    return `The following locations have been searched:
${[...new Set(r)].map((i) => `  ${i}`).join(`
`)}`;
  };
  var fa = function(e) {
    let { runtimeBinaryTarget: r } = e;
    return `${Ke(e)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${r}".
${gn(e)}

${ze(e)}`;
  };
  var hn = function(e) {
    return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e}`;
  };
  var yn = function(e) {
    let { errorStack: r } = e;
    return r?.match(/\/\.next|\/next@|\/next\//) ? `

We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.` : "";
  };
  var ga = function(e) {
    let { queryEngineName: r } = e;
    return `${Ke(e)}${yn(e)}

This is likely caused by a bundler that has not copied "${r}" next to the resulting bundle.
Ensure that "${r}" has been copied next to the bundle or in "${e.expectedLocation}".

${hn("engine-not-found-bundler-investigation")}

${ze(e)}`;
  };
  var ha = function(e) {
    let { runtimeBinaryTarget: r, generatorBinaryTargets: t } = e, n = t.find((i) => i.native);
    return `${Ke(e)}

This happened because Prisma Client was generated for "${n?.value ?? "unknown"}", but the actual deployment required "${r}".
${gn(e)}

${ze(e)}`;
  };
  var ya = function(e) {
    let { queryEngineName: r } = e;
    return `${Ke(e)}${yn(e)}

This is likely caused by tooling that has not copied "${r}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${r}" has been copied to "${e.expectedLocation}".

${hn("engine-not-found-tooling-investigation")}

${ze(e)}`;
  };
  async function ba(e, r) {
    let t = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e] ?? r.prismaPath;
    if (t !== undefined)
      return t;
    let { enginePath: n, searchedLocations: i } = await Zp(e, r);
    if (zp("enginePath", n), n !== undefined && e === "binary" && ti(n), n !== undefined)
      return r.prismaPath = n;
    let o = await rr(), s = r.generator?.binaryTargets ?? [], a = s.some((m) => m.native), l = !s.some((m) => m.value === o), u = __filename.match(Yp()) === null, c = { searchedLocations: i, generatorBinaryTargets: s, generator: r.generator, runtimeBinaryTarget: o, queryEngineName: wa(e, o), expectedLocation: at.default.relative(process.cwd(), r.dirname), errorStack: new Error().stack }, p;
    throw a && l ? p = ha(c) : l ? p = fa(c) : u ? p = ga(c) : p = ya(c), new R(p, r.clientVersion);
  }
  async function Zp(engineType, config) {
    let binaryTarget = await rr(), searchedLocations = [], dirname = eval("__dirname"), searchLocations = [config.dirname, at.default.resolve(dirname, ".."), config.generator?.output?.value ?? dirname, at.default.resolve(dirname, "../../../.prisma/client"), "/tmp/prisma-engines", config.cwd];
    __filename.includes("resolveEnginePath") && searchLocations.push(zo());
    for (let e of searchLocations) {
      let r = wa(engineType, binaryTarget), t = at.default.join(e, r);
      if (searchedLocations.push(e), Ea.default.existsSync(t))
        return { enginePath: t, searchedLocations };
    }
    return { enginePath: undefined, searchedLocations };
  }
  function wa(e, r) {
    return e === "library" ? It(r, "fs") : `query-engine-${r}${r === "windows" ? ".exe" : ""}`;
  }
  function xa(e) {
    return e ? e.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (r) => `${r[0]}5`) : "";
  }
  function Pa(e) {
    return e.split(`
`).map((r) => r.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
  }
  function Ta({ title: e, user: r = "prisma", repo: t = "prisma", template: n = "bug_report.yml", body: i }) {
    return (0, va.default)({ user: r, repo: t, template: n, title: e, body: i });
  }
  function Ca({ version: e, binaryTarget: r, title: t, description: n, engineVersion: i, database: o, query: s }) {
    let a = go(6000 - (s?.length ?? 0)), l = Pa((0, Li.default)(a)), u = n ? `# Description
\`\`\`
${n}
\`\`\`` : "", c = (0, Li.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${r?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|

${u}

## Logs
\`\`\`
${l}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s ? xa(s) : ""}
\`\`\`
`), p = Ta({ title: t, body: c });
    return `${t}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${ee(p)}

If you want the Prisma team to look into it, please open the link above \uD83D\uDE4F
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  }
  function Ir({ inlineDatasources: e, overrideDatasources: r, env: t, clientVersion: n }) {
    let i, o = Object.keys(e)[0], s = e[o]?.url, a = r[o]?.url;
    if (o === undefined ? i = undefined : a ? i = a : s?.value ? i = s.value : s?.fromEnvVar && (i = t[s.fromEnvVar]), s?.fromEnvVar !== undefined && i === undefined)
      throw new R(`error: Environment variable not found: ${s.fromEnvVar}.`, n);
    if (i === undefined)
      throw new R("error: Missing URL environment variable, value, or override.", n);
    return i;
  }
  function S(e, r) {
    return { ...e, isRetryable: r };
  }
  async function rm(e) {
    let r;
    try {
      r = await e.text();
    } catch {
      return { type: "EmptyError" };
    }
    try {
      let t = JSON.parse(r);
      if (typeof t == "string")
        switch (t) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: t };
          default:
            return { type: "UnknownTextError", body: t };
        }
      if (typeof t == "object" && t !== null) {
        if ("is_panic" in t && "message" in t && "error_code" in t)
          return { type: "QueryEngineError", body: t };
        if ("EngineNotStarted" in t || "InteractiveTransactionMisrouted" in t || "InvalidRequestError" in t) {
          let n = Object.values(t)[0].reason;
          return typeof n == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n) ? { type: "UnknownJsonError", body: t } : { type: "DataProxyError", body: t };
        }
      }
      return { type: "UnknownJsonError", body: t };
    } catch {
      return r === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: r };
    }
  }
  async function Et(e, r) {
    if (e.ok)
      return;
    let t = { clientVersion: r, response: e }, n = await rm(e);
    if (n.type === "QueryEngineError")
      throw new V(n.body.message, { code: n.body.error_code, clientVersion: r });
    if (n.type === "DataProxyError") {
      if (n.body === "InternalDataProxyError")
        throw new kr(t, "Internal Data Proxy error");
      if ("EngineNotStarted" in n.body) {
        if (n.body.EngineNotStarted.reason === "SchemaMissing")
          return new ur(t);
        if (n.body.EngineNotStarted.reason === "EngineVersionNotSupported")
          throw new pt(t);
        if ("EngineStartupError" in n.body.EngineNotStarted.reason) {
          let { msg: i, logs: o } = n.body.EngineNotStarted.reason.EngineStartupError;
          throw new ct(t, i, o);
        }
        if ("KnownEngineStartupError" in n.body.EngineNotStarted.reason) {
          let { msg: i, error_code: o } = n.body.EngineNotStarted.reason.KnownEngineStartupError;
          throw new R(i, r, o);
        }
        if ("HealthcheckTimeout" in n.body.EngineNotStarted.reason) {
          let { logs: i } = n.body.EngineNotStarted.reason.HealthcheckTimeout;
          throw new ut(t, i);
        }
      }
      if ("InteractiveTransactionMisrouted" in n.body) {
        let i = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
        throw new dt(t, i[n.body.InteractiveTransactionMisrouted.reason]);
      }
      if ("InvalidRequestError" in n.body)
        throw new ft(t, n.body.InvalidRequestError.reason);
    }
    if (e.status === 401 || e.status === 403)
      throw new ht(t, Dr($i, n));
    if (e.status === 404)
      return new gt(t, Dr(Fi, n));
    if (e.status === 429)
      throw new yt(t, Dr(qi, n));
    if (e.status === 504)
      throw new mt(t, Dr(Oi, n));
    if (e.status >= 500)
      throw new kr(t, Dr(Mi, n));
    if (e.status >= 400)
      throw new lt(t, Dr(Ni, n));
  }
  function Dr(e, r) {
    return r.type === "EmptyError" ? e : `${e}: ${JSON.stringify(r)}`;
  }
  function Ra(e) {
    let r = Math.pow(2, e) * 50, t = Math.ceil(Math.random() * r) - Math.ceil(r / 2), n = r + t;
    return new Promise((i) => setTimeout(() => i(n), n));
  }
  function Sa(e) {
    let r = new TextEncoder().encode(e), t = "", n = r.byteLength, i = n % 3, o = n - i, s, a, l, u, c;
    for (let p = 0;p < o; p = p + 3)
      c = r[p] << 16 | r[p + 1] << 8 | r[p + 2], s = (c & 16515072) >> 18, a = (c & 258048) >> 12, l = (c & 4032) >> 6, u = c & 63, t += Fe[s] + Fe[a] + Fe[l] + Fe[u];
    return i == 1 ? (c = r[o], s = (c & 252) >> 2, a = (c & 3) << 4, t += Fe[s] + Fe[a] + "==") : i == 2 && (c = r[o] << 8 | r[o + 1], s = (c & 64512) >> 10, a = (c & 1008) >> 4, l = (c & 15) << 2, t += Fe[s] + Fe[a] + Fe[l] + "="), t;
  }
  function Aa(e) {
    if (!!e.generator?.previewFeatures.some((t) => t.toLowerCase().includes("metrics")))
      throw new R("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e.clientVersion);
  }
  function tm(e) {
    return e[0] * 1000 + e[1] / 1e6;
  }
  function Ia(e) {
    return new Date(tm(e));
  }
  async function cr(e, r, t = (n) => n) {
    let n = r.clientVersion;
    try {
      return typeof fetch == "function" ? await t(fetch)(e, r) : await t(Bi)(e, r);
    } catch (i) {
      let o = i.message ?? "Unknown error";
      throw new bt(o, { clientVersion: n });
    }
  }
  function im(e) {
    return { ...e.headers, "Content-Type": "application/json" };
  }
  function om(e) {
    return { method: e.method, headers: im(e) };
  }
  function sm(e, r) {
    return { text: () => Promise.resolve(Buffer.concat(e).toString()), json: () => Promise.resolve().then(() => JSON.parse(Buffer.concat(e).toString())), ok: r.statusCode >= 200 && r.statusCode <= 299, status: r.statusCode, url: r.url, headers: new Vi(r.headers) };
  }
  async function Bi(e, r = {}) {
    let t = am("https"), n = om(r), i = [], { origin: o } = new URL(e);
    return new Promise((s, a) => {
      let l = t.request(e, n, (u) => {
        let { statusCode: c, headers: { location: p } } = u;
        c >= 301 && c <= 399 && p && (p.startsWith("http") === false ? s(Bi(`${o}${p}`, r)) : s(Bi(p, r))), u.on("data", (m) => i.push(m)), u.on("end", () => s(sm(i, u))), u.on("error", a);
      });
      l.on("error", a), l.end(r.body ?? "");
    });
  }
  async function um(e, r) {
    let t = _a["@prisma/engines-version"], n = r.clientVersion ?? "unknown";
    if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
      return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
    if (e.includes("accelerate") && n !== "0.0.0" && n !== "in-memory")
      return n;
    let [i, o] = n?.split("-") ?? [];
    if (o === undefined && lm.test(i))
      return i;
    if (o !== undefined || n === "0.0.0" || n === "in-memory") {
      if (e.startsWith("localhost") || e.startsWith("127.0.0.1"))
        return "0.0.0";
      let [s] = t.split("-") ?? [], [a, l, u] = s.split("."), c = cm(`<=${a}.${l}.${u}`), p = await cr(c, { clientVersion: n });
      if (!p.ok)
        throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text() || "<empty body>"}`);
      let m = await p.text();
      ka("length of body fetched from unpkg.com", m.length);
      let f;
      try {
        f = JSON.parse(m);
      } catch (g) {
        throw console.error("JSON.parse error: body fetched from unpkg.com: ", m), g;
      }
      return f.version;
    }
    throw new lr("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n });
  }
  async function Da(e, r) {
    let t = await um(e, r);
    return ka("version", t), t;
  }
  function cm(e) {
    return encodeURI(`https://unpkg.com/prisma@${e}/package.json`);
  }
  function Na(e) {
    if (e?.kind === "itx")
      return e.options.id;
  }
  function pm() {
    let e = globalThis;
    return e[Qi] === undefined && (e[Qi] = {}), e[Qi];
  }
  function mm(e) {
    let r = pm();
    if (r[e] !== undefined)
      return r[e];
    let t = Oa.default.toNamespacedPath(e), n = { exports: {} }, i = 0;
    return process.platform !== "win32" && (i = Gi.default.constants.dlopen.RTLD_LAZY | Gi.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n, t, i), r[e] = n.exports, n.exports;
  }
  function fm(e) {
    return e.item_type === "query" && "query" in e;
  }
  function gm(e) {
    return "level" in e ? e.level === "error" && e.message === "PANIC" : false;
  }
  function hm(e) {
    return typeof e == "object" && e !== null && e.error_code !== undefined;
  }
  function Hi(e, r) {
    return Ca({ binaryTarget: e.binaryTarget, title: r, version: e.config.clientVersion, engineVersion: e.versionInfo?.commit, database: e.config.activeProvider, query: e.lastQuery });
  }
  function Ba({ copyEngine: e = true }, r) {
    let t;
    try {
      t = Ir({ inlineDatasources: r.inlineDatasources, overrideDatasources: r.overrideDatasources, env: { ...r.env, ...process.env }, clientVersion: r.clientVersion });
    } catch {
    }
    e && t?.startsWith("prisma://") && Hr("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
    let n = Ur(r.generator), i = !!(t?.startsWith("prisma://") || !e), o = !!r.adapter, s = n === "library", a = n === "binary";
    if (i && o || o && false) {
      let l;
      throw e ? t?.startsWith("prisma://") ? l = ["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.", "Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."] : l = ["Prisma Client was configured to use both the `adapter` and Accelerate, please chose one."] : l = ["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.", "Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."], new K(l.join(`
`), { clientVersion: r.clientVersion });
    }
    if (i)
      return new wt(r);
    if (s)
      return new xt(r);
    throw new K("Invalid client engine type, please use `library` or `binary`", { clientVersion: r.clientVersion });
  }
  function bn({ generator: e }) {
    return e?.previewFeatures ?? [];
  }
  function Qa(e, r) {
    let t = Ga(e), n = ym(t), i = bm(n);
    i ? wn(i, r) : r.addErrorMessage(() => "Unknown error");
  }
  function Ga(e) {
    return e.errors.flatMap((r) => r.kind === "Union" ? Ga(r) : [r]);
  }
  function ym(e) {
    let r = new Map, t = [];
    for (let n of e) {
      if (n.kind !== "InvalidArgumentType") {
        t.push(n);
        continue;
      }
      let i = `${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`, o = r.get(i);
      o ? r.set(i, { ...n, argument: { ...n.argument, typeNames: Em(o.argument.typeNames, n.argument.typeNames) } }) : r.set(i, n);
    }
    return t.push(...r.values()), t;
  }
  function Em(e, r) {
    return [...new Set(e.concat(r))];
  }
  function bm(e) {
    return mi(e, (r, t) => {
      let n = ja(r), i = ja(t);
      return n !== i ? n - i : Ua(r) - Ua(t);
    });
  }
  function ja(e) {
    let r = 0;
    return Array.isArray(e.selectionPath) && (r += e.selectionPath.length), Array.isArray(e.argumentPath) && (r += e.argumentPath.length), r;
  }
  function Ua(e) {
    switch (e.kind) {
      case "InvalidArgumentValue":
      case "ValueTooLarge":
        return 20;
      case "InvalidArgumentType":
        return 10;
      case "RequiredArgumentMissing":
        return -10;
      default:
        return 0;
    }
  }
  function wn(e, r) {
    switch (e.kind) {
      case "IncludeAndSelect":
        wm(e, r);
        break;
      case "IncludeOnScalar":
        xm(e, r);
        break;
      case "EmptySelection":
        Pm(e, r);
        break;
      case "UnknownSelectionField":
        vm(e, r);
        break;
      case "UnknownArgument":
        Tm(e, r);
        break;
      case "UnknownInputField":
        Cm(e, r);
        break;
      case "RequiredArgumentMissing":
        Rm(e, r);
        break;
      case "InvalidArgumentType":
        Sm(e, r);
        break;
      case "InvalidArgumentValue":
        Am(e, r);
        break;
      case "ValueTooLarge":
        Im(e, r);
        break;
      case "SomeFieldsMissing":
        _m(e, r);
        break;
      case "TooManyFieldsGiven":
        km(e, r);
        break;
      case "Union":
        Qa(e, r);
        break;
      default:
        throw new Error("not implemented: " + e.kind);
    }
  }
  function wm(e, r) {
    let t = r.arguments.getDeepSubSelectionValue(e.selectionPath);
    t && t instanceof J && (t.getField("include")?.markAsError(), t.getField("select")?.markAsError()), r.addErrorMessage((n) => `Please ${n.bold("either")} use ${n.green("`include`")} or ${n.green("`select`")}, but ${n.red("not both")} at the same time.`);
  }
  function xm(e, r) {
    let [t, n] = Pn(e.selectionPath), i = e.outputType, o = r.arguments.getDeepSelectionParent(t)?.value;
    if (o && (o.getField(n)?.markAsError(), i))
      for (let s of i.fields)
        s.isRelation && o.addSuggestion(new Me(s.name, "true"));
    r.addErrorMessage((s) => {
      let a = `Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;
      return i ? a += ` on model ${s.bold(i.name)}. ${Pt(s)}` : a += ".", a += `
Note that ${s.bold("include")} statements only accept relation fields.`, a;
    });
  }
  function Pm(e, r) {
    let t = e.outputType, n = r.arguments.getDeepSelectionParent(e.selectionPath)?.value, i = n?.isEmpty() ?? false;
    n && (n.removeAllFields(), Ka(n, t)), r.addErrorMessage((o) => i ? `The ${o.red("`select`")} statement for type ${o.bold(t.name)} must not be empty. ${Pt(o)}` : `The ${o.red("`select`")} statement for type ${o.bold(t.name)} needs ${o.bold("at least one truthy value")}.`);
  }
  function vm(e, r) {
    let [t, n] = Pn(e.selectionPath), i = r.arguments.getDeepSelectionParent(t);
    i && (i.value.getField(n)?.markAsError(), Ka(i.value, e.outputType)), r.addErrorMessage((o) => {
      let s = [`Unknown field ${o.red(`\`${n}\``)}`];
      return i && s.push(`for ${o.bold(i.kind)} statement`), s.push(`on model ${o.bold(`\`${e.outputType.name}\``)}.`), s.push(Pt(o)), s.join(" ");
    });
  }
  function Tm(e, r) {
    let t = e.argumentPath[0], n = r.arguments.getDeepSubSelectionValue(e.selectionPath);
    n instanceof J && (n.getField(t)?.markAsError(), Dm(n, e.arguments)), r.addErrorMessage((i) => Ha(i, t, e.arguments.map((o) => o.name)));
  }
  function Cm(e, r) {
    let [t, n] = Pn(e.argumentPath), i = r.arguments.getDeepSubSelectionValue(e.selectionPath);
    if (i instanceof J) {
      i.getDeepField(e.argumentPath)?.markAsError();
      let o = i.getDeepFieldValue(t);
      o instanceof J && za(o, e.inputType);
    }
    r.addErrorMessage((o) => Ha(o, n, e.inputType.fields.map((s) => s.name)));
  }
  function Ha(e, r, t) {
    let n = [`Unknown argument \`${e.red(r)}\`.`], i = Nm(r, t);
    return i && n.push(`Did you mean \`${e.green(i)}\`?`), t.length > 0 && n.push(Pt(e)), n.join(" ");
  }
  function Rm(e, r) {
    let t;
    r.addErrorMessage((l) => t?.value instanceof H && t.value.text === "null" ? `Argument \`${l.green(o)}\` must not be ${l.red("null")}.` : `Argument \`${l.green(o)}\` is missing.`);
    let n = r.arguments.getDeepSubSelectionValue(e.selectionPath);
    if (!(n instanceof J))
      return;
    let [i, o] = Pn(e.argumentPath), s = new xn, a = n.getDeepFieldValue(i);
    if (a instanceof J)
      if (t = a.getField(o), t && a.removeField(o), e.inputTypes.length === 1 && e.inputTypes[0].kind === "object") {
        for (let l of e.inputTypes[0].fields)
          s.addField(l.name, l.typeNames.join(" | "));
        a.addSuggestion(new Me(o, s).makeRequired());
      } else {
        let l = e.inputTypes.map(Wa).join(" | ");
        a.addSuggestion(new Me(o, l).makeRequired());
      }
  }
  function Wa(e) {
    return e.kind === "list" ? `${Wa(e.elementType)}[]` : e.name;
  }
  function Sm(e, r) {
    let t = e.argument.name, n = r.arguments.getDeepSubSelectionValue(e.selectionPath);
    n instanceof J && n.getDeepFieldValue(e.argumentPath)?.markAsError(), r.addErrorMessage((i) => {
      let o = vn("or", e.argument.typeNames.map((s) => i.green(s)));
      return `Argument \`${i.bold(t)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`;
    });
  }
  function Am(e, r) {
    let t = e.argument.name, n = r.arguments.getDeepSubSelectionValue(e.selectionPath);
    n instanceof J && n.getDeepFieldValue(e.argumentPath)?.markAsError(), r.addErrorMessage((i) => {
      let o = [`Invalid value for argument \`${i.bold(t)}\``];
      if (e.underlyingError && o.push(`: ${e.underlyingError}`), o.push("."), e.argument.typeNames.length > 0) {
        let s = vn("or", e.argument.typeNames.map((a) => i.green(a)));
        o.push(` Expected ${s}.`);
      }
      return o.join("");
    });
  }
  function Im(e, r) {
    let t = e.argument.name, n = r.arguments.getDeepSubSelectionValue(e.selectionPath), i;
    if (n instanceof J) {
      let s = n.getDeepField(e.argumentPath)?.value;
      s?.markAsError(), s instanceof H && (i = s.text);
    }
    r.addErrorMessage((o) => {
      let s = ["Unable to fit value"];
      return i && s.push(o.red(i)), s.push(`into a 64-bit signed integer for field \`${o.bold(t)}\``), s.join(" ");
    });
  }
  function _m(e, r) {
    let t = e.argumentPath[e.argumentPath.length - 1], n = r.arguments.getDeepSubSelectionValue(e.selectionPath);
    if (n instanceof J) {
      let i = n.getDeepFieldValue(e.argumentPath);
      i instanceof J && za(i, e.inputType);
    }
    r.addErrorMessage((i) => {
      let o = [`Argument \`${i.bold(t)}\` of type ${i.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 ? e.constraints.requiredFields ? o.push(`${i.green("at least one of")} ${vn("or", e.constraints.requiredFields.map((s) => `\`${i.bold(s)}\``))} arguments.`) : o.push(`${i.green("at least one")} argument.`) : o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`), o.push(Pt(i)), o.join(" ");
    });
  }
  function km(e, r) {
    let t = e.argumentPath[e.argumentPath.length - 1], n = r.arguments.getDeepSubSelectionValue(e.selectionPath), i = [];
    if (n instanceof J) {
      let o = n.getDeepFieldValue(e.argumentPath);
      o instanceof J && (o.markAsError(), i = Object.keys(o.getFields()));
    }
    r.addErrorMessage((o) => {
      let s = [`Argument \`${o.bold(t)}\` of type ${o.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 && e.constraints.maxFieldCount == 1 ? s.push(`${o.green("exactly one")} argument,`) : e.constraints.maxFieldCount == 1 ? s.push(`${o.green("at most one")} argument,`) : s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`), s.push(`but you provided ${vn("and", i.map((a) => o.red(a)))}. Please choose`), e.constraints.maxFieldCount === 1 ? s.push("one.") : s.push(`${e.constraints.maxFieldCount}.`), s.join(" ");
    });
  }
  function Ka(e, r) {
    for (let t of r.fields)
      e.hasField(t.name) || e.addSuggestion(new Me(t.name, "true"));
  }
  function Dm(e, r) {
    for (let t of r)
      e.hasField(t.name) || e.addSuggestion(new Me(t.name, t.typeNames.join(" | ")));
  }
  function za(e, r) {
    if (r.kind === "object")
      for (let t of r.fields)
        e.hasField(t.name) || e.addSuggestion(new Me(t.name, t.typeNames.join(" | ")));
  }
  function Pn(e) {
    let r = [...e], t = r.pop();
    if (!t)
      throw new Error("unexpected empty path");
    return [r, t];
  }
  function Pt({ green: e, enabled: r }) {
    return "Available options are " + (r ? `listed in ${e("green")}` : "marked with ?") + ".";
  }
  function vn(e, r) {
    if (r.length === 1)
      return r[0];
    let t = [...r], n = t.pop();
    return `${t.join(", ")} ${e} ${n}`;
  }
  function Nm(e, r) {
    let t = 1 / 0, n;
    for (let i of r) {
      let o = (0, Ja.default)(e, i);
      o > Lm || o < t && (t = o, n = i);
    }
    return n;
  }
  function Tn({ args: e, errors: r, errorFormat: t, callsite: n, originalMethod: i, clientVersion: o }) {
    let s = an(e);
    for (let p of r)
      wn(p, s);
    let a = t === "pretty" ? Rs : on, l = s.renderAllMessages(a), u = new br(0, { colors: a }).write(s).toString(), c = Ar({ message: l, callsite: n, originalMethod: i, showColors: t === "pretty", callArguments: u });
    throw new K(c, { clientVersion: o });
  }
  function Ya({ modelName: e, action: r, args: t, runtimeDataModel: n, extensions: i, callsite: o, clientMethod: s, errorFormat: a, clientVersion: l }) {
    let u = new Ki({ runtimeDataModel: n, modelName: e, action: r, rootArgs: t, callsite: o, extensions: i, selectionPath: [], argumentPath: [], originalMethod: s, errorFormat: a, clientVersion: l });
    return { modelName: e, action: Om[r], query: zi(t, u) };
  }
  function zi({ select: e, include: r, ...t } = {}, n) {
    return { arguments: Xa(t, n), selection: Fm(e, r, n) };
  }
  function Fm(e, r, t) {
    return e && r && t.throwValidationError({ kind: "IncludeAndSelect", selectionPath: t.getSelectionPath() }), e ? qm(e, t) : Mm(t, r);
  }
  function Mm(e, r) {
    let t = {};
    return e.model && !e.isRawAction() && (t.$composites = true, t.$scalars = true), r && $m(t, r, e), t;
  }
  function $m(e, r, t) {
    for (let [n, i] of Object.entries(r)) {
      let o = t.findField(n);
      o && o?.kind !== "object" && t.throwValidationError({ kind: "IncludeOnScalar", selectionPath: t.getSelectionPath().concat(n), outputType: t.getOutputTypeDescription() }), i === true ? e[n] = true : typeof i == "object" && (e[n] = zi(i, t.nestSelection(n)));
    }
  }
  function qm(e, r) {
    let t = {}, n = r.getComputedFields(), i = la(e, n);
    for (let [o, s] of Object.entries(i)) {
      let a = r.findField(o);
      n?.[o] && !a || (s === true ? t[o] = true : typeof s == "object" && (t[o] = zi(s, r.nestSelection(o))));
    }
    return t;
  }
  function Za(e, r) {
    if (e === null)
      return null;
    if (typeof e == "string" || typeof e == "number" || typeof e == "boolean")
      return e;
    if (typeof e == "bigint")
      return { $type: "BigInt", value: String(e) };
    if (wr(e)) {
      if (Wt(e))
        return { $type: "DateTime", value: e.toISOString() };
      r.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: r.getSelectionPath(), argumentPath: r.getArgumentPath(), argument: { name: r.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
    }
    if (Tr(e))
      return { $type: "FieldRef", value: { _ref: e.name, _container: e.modelName } };
    if (Array.isArray(e))
      return Bm(e, r);
    if (ArrayBuffer.isView(e))
      return { $type: "Bytes", value: Buffer.from(e).toString("base64") };
    if (Vm(e))
      return e.values;
    if (vr(e))
      return { $type: "Decimal", value: e.toFixed() };
    if (e instanceof Ne) {
      if (e !== Gt.instances[e._getName()])
        throw new Error("Invalid ObjectEnumValue");
      return { $type: "Enum", value: e._getName() };
    }
    if (jm(e))
      return e.toJSON();
    if (typeof e == "object")
      return Xa(e, r);
    r.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: r.getSelectionPath(), argumentPath: r.getArgumentPath(), argument: { name: r.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
  }
  function Xa(e, r) {
    if (e.$type)
      return { $type: "Raw", value: e };
    let t = {};
    for (let n in e) {
      let i = e[n];
      i !== undefined && (t[n] = Za(i, r.nestArgument(n)));
    }
    return t;
  }
  function Bm(e, r) {
    let t = [];
    for (let n = 0;n < e.length; n++) {
      let i = r.nestArgument(String(n)), o = e[n];
      o === undefined && r.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i.getSelectionPath(), argumentPath: i.getArgumentPath(), argument: { name: `${r.getArgumentName()}[${n}]`, typeNames: [] }, underlyingError: "Can not use `undefined` value within array. Use `null` or filter out `undefined` values" }), t.push(Za(o, i));
    }
    return t;
  }
  function Vm(e) {
    return typeof e == "object" && e !== null && e.__prismaRawParameters__ === true;
  }
  function jm(e) {
    return typeof e == "object" && e !== null && typeof e.toJSON == "function";
  }
  function vt(e) {
    try {
      return tl(e, "fast");
    } catch {
      return tl(e, "slow");
    }
  }
  function tl(e, r) {
    return JSON.stringify(e.map((t) => Um(t, r)));
  }
  function Um(e, r) {
    return typeof e == "bigint" ? { prisma__type: "bigint", prisma__value: e.toString() } : wr(e) ? { prisma__type: "date", prisma__value: e.toJSON() } : Te.isDecimal(e) ? { prisma__type: "decimal", prisma__value: e.toJSON() } : Buffer.isBuffer(e) ? { prisma__type: "bytes", prisma__value: e.toString("base64") } : Qm(e) || ArrayBuffer.isView(e) ? { prisma__type: "bytes", prisma__value: Buffer.from(e).toString("base64") } : typeof e == "object" && r === "slow" ? il(e) : e;
  }
  function Qm(e) {
    return e instanceof ArrayBuffer || e instanceof SharedArrayBuffer ? true : typeof e == "object" && e !== null ? e[Symbol.toStringTag] === "ArrayBuffer" || e[Symbol.toStringTag] === "SharedArrayBuffer" : false;
  }
  function il(e) {
    if (typeof e != "object" || e === null)
      return e;
    if (typeof e.toJSON == "function")
      return e.toJSON();
    if (Array.isArray(e))
      return e.map(nl);
    let r = {};
    for (let t of Object.keys(e))
      r[t] = nl(e[t]);
    return r;
  }
  function nl(e) {
    return typeof e == "bigint" ? e.toString() : il(e);
  }
  function Yi(e, r, t, n) {
    if (!(e !== "postgresql" && e !== "cockroachdb") && t.length > 0 && Gm.exec(r))
      throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
  }
  function Xi(e) {
    return function(t) {
      let n, i = (o = e) => {
        try {
          return o === undefined || o?.kind === "itx" ? n ?? (n = ll(t(o))) : ll(t(o));
        } catch (s) {
          return Promise.reject(s);
        }
      };
      return { then(o, s) {
        return i().then(o, s);
      }, catch(o) {
        return i().catch(o);
      }, finally(o) {
        return i().finally(o);
      }, requestTransaction(o) {
        let s = i(o);
        return s.requestTransaction ? s.requestTransaction(o) : s;
      }, [Symbol.toStringTag]: "PrismaPromise" };
    };
  }
  function ll(e) {
    return typeof e.then == "function" ? e : Promise.resolve(e);
  }
  function cl(e) {
    return e.includes("tracing") ? new eo : ul;
  }
  function pl(e, r = () => {
  }) {
    let t, n = new Promise((i) => t = i);
    return { then(i) {
      return --e === 0 && t(r()), i?.(n);
    } };
  }
  function dl(e) {
    return typeof e == "string" ? e : e.reduce((r, t) => {
      let n = typeof t == "string" ? t : t.level;
      return n === "query" ? r : r && (t === "info" || r === "info") ? "info" : n;
    }, undefined);
  }
  function Rn(e) {
    return typeof e.batchRequestIdx == "number";
  }
  function Sn(e) {
    return e === null ? e : Array.isArray(e) ? e.map(Sn) : typeof e == "object" ? Hm(e) ? Wm(e) : hr(e, Sn) : e;
  }
  function Hm(e) {
    return e !== null && typeof e == "object" && typeof e.$type == "string";
  }
  function Wm({ $type: e, value: r }) {
    switch (e) {
      case "BigInt":
        return BigInt(r);
      case "Bytes":
        return Buffer.from(r, "base64");
      case "DateTime":
        return new Date(r);
      case "Decimal":
        return new Te(r);
      case "Json":
        return JSON.parse(r);
      default:
        tr(r, "Unknown tagged value");
    }
  }
  function fl(e) {
    if (e.action !== "findUnique" && e.action !== "findUniqueOrThrow")
      return;
    let r = [];
    return e.modelName && r.push(e.modelName), e.query.arguments && r.push(ro(e.query.arguments)), r.push(ro(e.query.selection)), r.join("");
  }
  function ro(e) {
    return `(${Object.keys(e).sort().map((t) => {
      let n = e[t];
      return typeof n == "object" && n !== null ? `(${t} ${ro(n)})` : t;
    }).join(" ")})`;
  }
  function to(e) {
    return Km[e];
  }
  function Ym(e) {
    if (e) {
      if (e.kind === "batch")
        return { kind: "batch", options: { isolationLevel: e.isolationLevel } };
      if (e.kind === "itx")
        return { kind: "itx", options: hl(e) };
      tr(e, "Unknown transaction kind");
    }
  }
  function hl(e) {
    return { id: e.id, payload: e.payload };
  }
  function Zm(e, r) {
    return Rn(e) && r?.kind === "batch" && e.batchRequestIdx !== r.index;
  }
  function Xm(e) {
    return e.code === "P2009" || e.code === "P2012";
  }
  function yl(e) {
    if (e.kind === "Union")
      return { kind: "Union", errors: e.errors.map(yl) };
    if (Array.isArray(e.selectionPath)) {
      let [, ...r] = e.selectionPath;
      return { ...e, selectionPath: r };
    }
    return e;
  }
  function wl(e) {
    return e.map((r) => {
      let t = {};
      for (let n of Object.keys(r))
        t[n] = xl(r[n]);
      return t;
    });
  }
  function xl({ prisma__type: e, prisma__value: r }) {
    switch (e) {
      case "bigint":
        return BigInt(r);
      case "bytes":
        return Buffer.from(r, "base64");
      case "decimal":
        return new Te(r);
      case "datetime":
      case "date":
        return new Date(r);
      case "time":
        return new Date(`1970-01-01T${r}Z`);
      case "array":
        return r.map(xl);
      default:
        return r;
    }
  }
  function Rl(e, r) {
    for (let [t, n] of Object.entries(e)) {
      if (!Pl.includes(t)) {
        let i = Lr(t, Pl);
        throw new q(`Unknown property ${t} provided to PrismaClient constructor.${i}`);
      }
      rd[t](n, r);
    }
    if (e.datasourceUrl && e.datasources)
      throw new q('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
  }
  function Lr(e, r) {
    if (r.length === 0 || typeof e != "string")
      return "";
    let t = td(e, r);
    return t ? ` Did you mean "${t}"?` : "";
  }
  function td(e, r) {
    if (r.length === 0)
      return null;
    let t = r.map((i) => ({ value: i, distance: (0, Cl.default)(e, i) }));
    t.sort((i, o) => i.distance < o.distance ? -1 : 1);
    let n = t[0];
    return n.distance < 3 ? n.value : null;
  }
  function Sl(e) {
    return e.length === 0 ? Promise.resolve([]) : new Promise((r, t) => {
      let n = new Array(e.length), i = null, o = false, s = 0, a = () => {
        o || (s++, s === e.length && (o = true, i ? t(i) : r(n)));
      }, l = (u) => {
        o || (o = true, t(u));
      };
      for (let u = 0;u < e.length; u++)
        e[u].then((c) => {
          n[u] = c, a();
        }, (c) => {
          if (!Rn(c)) {
            l(c);
            return;
          }
          c.batchRequestIdx === u ? l(c) : (i || (i = c), a());
        });
    });
  }
  function Ll(e) {

    class r {
      constructor(n) {
        this._originalClient = this;
        this._middlewares = new Cn;
        this._createPrismaPromise = Xi();
        this.$extends = Ks;
        e = n?.__internal?.configOverride?.(e) ?? e, pa(e), n && Rl(n, e);
        let i = n?.adapter ? yi(n.adapter) : undefined, o = new kl.EventEmitter().on("error", () => {
        });
        this._extensions = dn.empty(), this._previewFeatures = bn(e), this._clientVersion = e.clientVersion ?? bl, this._activeProvider = e.activeProvider, this._tracingHelper = cl(this._previewFeatures);
        let s = { rootEnvPath: e.relativeEnvPaths.rootEnvPath && Tt.default.resolve(e.dirname, e.relativeEnvPaths.rootEnvPath), schemaEnvPath: e.relativeEnvPaths.schemaEnvPath && Tt.default.resolve(e.dirname, e.relativeEnvPaths.schemaEnvPath) }, a = !i && jr(s, { conflictCheck: "none" }) || e.injectableEdgeEnv?.();
        try {
          let l = n ?? {}, u = l.__internal ?? {}, c = u.debug === true;
          c && N.enable("prisma:client");
          let p = Tt.default.resolve(e.dirname, e.relativePath);
          Dl.default.existsSync(p) || (p = e.dirname), Ye("dirname", e.dirname), Ye("relativePath", e.relativePath), Ye("cwd", p);
          let m = u.engine || {};
          if (l.errorFormat ? this._errorFormat = l.errorFormat : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e.runtimeDataModel, this._engineConfig = { cwd: p, dirname: e.dirname, enableDebugLogs: c, allowTriggerPanic: m.allowTriggerPanic, datamodelPath: Tt.default.join(e.dirname, e.filename ?? "schema.prisma"), prismaPath: m.binaryPath ?? undefined, engineEndpoint: m.endpoint, generator: e.generator, showColors: this._errorFormat === "pretty", logLevel: l.log && dl(l.log), logQueries: l.log && !!(typeof l.log == "string" ? l.log === "query" : l.log.find((f) => typeof f == "string" ? f === "query" : f.level === "query")), env: a?.parsed ?? {}, flags: [], engineWasm: e.engineWasm, clientVersion: e.clientVersion, engineVersion: e.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e.activeProvider, inlineSchema: e.inlineSchema, overrideDatasources: ma(l, e.datasourceNames), inlineDatasources: e.inlineDatasources, inlineSchemaHash: e.inlineSchemaHash, tracingHelper: this._tracingHelper, transactionOptions: { maxWait: l.transactionOptions?.maxWait ?? 2000, timeout: l.transactionOptions?.timeout ?? 5000, isolationLevel: l.transactionOptions?.isolationLevel }, logEmitter: o, isBundled: e.isBundled, adapter: i }, this._accelerateEngineConfig = { ...this._engineConfig, accelerateUtils: { resolveDatasourceUrl: Ir, getBatchRequestPayload: Er, prismaGraphQLToJSError: sr, PrismaClientUnknownRequestError: j, PrismaClientInitializationError: R, PrismaClientKnownRequestError: V, debug: N("prisma:client:accelerateEngine"), engineVersion: Il.version, clientVersion: e.clientVersion } }, Ye("clientVersion", e.clientVersion), this._engine = Ba(e, this._engineConfig), this._requestHandler = new In(this, o), l.log)
            for (let f of l.log) {
              let g = typeof f == "string" ? f : f.emit === "stdout" ? f.level : null;
              g && this.$on(g, (h) => {
                Jr.log(`${Jr.tags[g] ?? ""}`, h.message || h.query);
              });
            }
          this._metrics = new yr(this._engine);
        } catch (l) {
          throw l.clientVersion = this._clientVersion, l;
        }
        return this._appliedParent = ot(this);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClient";
      }
      $use(n) {
        this._middlewares.use(n);
      }
      $on(n, i) {
        n === "beforeExit" ? this._engine.onBeforeExit(i) : n && this._engineConfig.logEmitter.on(n, i);
      }
      $connect() {
        try {
          return this._engine.start();
        } catch (n) {
          throw n.clientVersion = this._clientVersion, n;
        }
      }
      async $disconnect() {
        try {
          await this._engine.stop();
        } catch (n) {
          throw n.clientVersion = this._clientVersion, n;
        } finally {
          ho();
        }
      }
      $executeRawInternal(n, i, o, s) {
        let a = this._activeProvider;
        return this._request({ action: "executeRaw", args: o, transaction: n, clientMethod: i, argsMapper: Zi({ clientMethod: i, activeProvider: a }), callsite: We(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
      }
      $executeRaw(n, ...i) {
        return this._createPrismaPromise((o) => {
          if (n.raw !== undefined || n.sql !== undefined) {
            let [s, a] = Al(n, i);
            return Yi(this._activeProvider, s.text, s.values, Array.isArray(n) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o, "$executeRaw", s, a);
          }
          throw new K("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
        });
      }
      $executeRawUnsafe(n, ...i) {
        return this._createPrismaPromise((o) => (Yi(this._activeProvider, n, i, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o, "$executeRawUnsafe", [n, ...i])));
      }
      $runCommandRaw(n) {
        if (e.activeProvider !== "mongodb")
          throw new K(`The ${e.activeProvider} provider does not support \$runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
        return this._createPrismaPromise((i) => this._request({ args: n, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: el, callsite: We(this._errorFormat), transaction: i }));
      }
      async $queryRawInternal(n, i, o, s) {
        let a = this._activeProvider;
        return this._request({ action: "queryRaw", args: o, transaction: n, clientMethod: i, argsMapper: Zi({ clientMethod: i, activeProvider: a }), callsite: We(this._errorFormat), dataPath: [], middlewareArgsMapper: s }).then(wl);
      }
      $queryRaw(n, ...i) {
        return this._createPrismaPromise((o) => {
          if (n.raw !== undefined || n.sql !== undefined)
            return this.$queryRawInternal(o, "$queryRaw", ...Al(n, i));
          throw new K("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
        });
      }
      $queryRawUnsafe(n, ...i) {
        return this._createPrismaPromise((o) => this.$queryRawInternal(o, "$queryRawUnsafe", [n, ...i]));
      }
      _transactionWithArray({ promises: n, options: i }) {
        let o = od.nextId(), s = pl(n.length), a = n.map((l, u) => {
          if (l?.[Symbol.toStringTag] !== "PrismaPromise")
            throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
          let c = i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel, p = { kind: "batch", id: o, index: u, isolationLevel: c, lock: s };
          return l.requestTransaction?.(p) ?? l;
        });
        return Sl(a);
      }
      async _transactionWithCallback({ callback: n, options: i }) {
        let o = { traceparent: this._tracingHelper.getTraceParent() }, s = { maxWait: i?.maxWait ?? this._engineConfig.transactionOptions.maxWait, timeout: i?.timeout ?? this._engineConfig.transactionOptions.timeout, isolationLevel: i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel }, a = await this._engine.transaction("start", o, s), l;
        try {
          let u = { kind: "itx", ...a };
          l = await n(this._createItxClient(u)), await this._engine.transaction("commit", o, a);
        } catch (u) {
          throw await this._engine.transaction("rollback", o, a).catch(() => {
          }), u;
        }
        return l;
      }
      _createItxClient(n) {
        return ot(Pe(Ws(this), [ne("_appliedParent", () => this._appliedParent._createItxClient(n)), ne("_createPrismaPromise", () => Xi(n)), ne(id, () => n.id), rt(ml)]));
      }
      $transaction(n, i) {
        let o;
        typeof n == "function" ? o = () => this._transactionWithCallback({ callback: n, options: i }) : o = () => this._transactionWithArray({ promises: n, options: i });
        let s = { name: "transaction", attributes: { method: "$transaction" } };
        return this._tracingHelper.runInChildSpan(s, o);
      }
      _request(n) {
        n.otelParentCtx = this._tracingHelper.getActiveContext();
        let i = n.middlewareArgsMapper ?? nd, o = { args: i.requestArgsToMiddlewareArgs(n.args), dataPath: n.dataPath, runInTransaction: !!n.transaction, action: n.action, model: n.model }, s = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: o.action, model: o.model, name: o.model ? `${o.model}.${o.action}` : o.action } } }, a = -1, l = async (u) => {
          let c = this._middlewares.get(++a);
          if (c)
            return this._tracingHelper.runInChildSpan(s.middleware, (A) => c(u, (T) => (A?.end(), l(T))));
          let { runInTransaction: p, args: m, ...f } = u, g = { ...n, ...f };
          m && (g.args = i.middlewareArgsToRequestArgs(m)), n.transaction !== undefined && p === false && delete g.transaction;
          let h = await ta(this, g);
          return g.model ? Zs({ result: h, modelName: g.model, args: g.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel }) : h;
        };
        return this._tracingHelper.runInChildSpan(s.operation, () => new _l.AsyncResource("prisma-client-request").runInAsyncScope(() => l(o)));
      }
      async _executeRequest({ args: n, clientMethod: i, dataPath: o, callsite: s, action: a, model: l, argsMapper: u, transaction: c, unpacker: p, otelParentCtx: m, customDataProxyFetch: f }) {
        try {
          n = u ? u(n) : n;
          let g = { name: "serialize" }, h = this._tracingHelper.runInChildSpan(g, () => Ya({ modelName: l, runtimeDataModel: this._runtimeDataModel, action: a, args: n, clientMethod: i, callsite: s, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion }));
          return N.enabled("prisma:client") && (Ye("Prisma Client call:"), Ye(`prisma.${i}(${_s(n)})`), Ye("Generated request:"), Ye(JSON.stringify(h, null, 2) + `
`)), c?.kind === "batch" && await c.lock, this._requestHandler.request({ protocolQuery: h, modelName: l, action: a, clientMethod: i, dataPath: o, callsite: s, args: n, extensions: this._extensions, transaction: c, unpacker: p, otelParentCtx: m, otelChildCtx: this._tracingHelper.getActiveContext(), customDataProxyFetch: f });
        } catch (g) {
          throw g.clientVersion = this._clientVersion, g;
        }
      }
      get $metrics() {
        if (!this._hasPreviewFlag("metrics"))
          throw new K("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
        return this._metrics;
      }
      _hasPreviewFlag(n) {
        return !!this._engineConfig.previewFeatures?.includes(n);
      }
    }
    return r;
  }
  function Al(e, r) {
    return sd(e) ? [new oe(e, r), sl] : [e, al];
  }
  function sd(e) {
    return Array.isArray(e) && Array.isArray(e.raw);
  }
  function Nl(e) {
    return new Proxy(e, { get(r, t) {
      if (t in r)
        return r[t];
      if (!ad.has(t))
        throw new TypeError(`Invalid enum value: ${String(t)}`);
    } });
  }
  function Ol(e) {
    jr(e, { conflictCheck: "warn" });
  }
  var __dirname = "/home/ujjujjuj/code/projects/switcher-freelance/tstrack/tracker/node_modules/@prisma/client/runtime", __filename = "/home/ujjujjuj/code/projects/switcher-freelance/tstrack/tracker/node_modules/@prisma/client/runtime/library.js";
  var Fl = Object.create;
  var Rt = Object.defineProperty;
  var Ml = Object.getOwnPropertyDescriptor;
  var $l = Object.getOwnPropertyNames;
  var ql = Object.getPrototypeOf;
  var Bl = Object.prototype.hasOwnProperty;
  var X = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
  var Or = (e, r) => {
    for (var t in r)
      Rt(e, t, { get: r[t], enumerable: true });
  };
  var no = (e, r, t, n) => {
    if (r && typeof r == "object" || typeof r == "function")
      for (let i of $l(r))
        !Bl.call(e, i) && i !== t && Rt(e, i, { get: () => r[i], enumerable: !(n = Ml(r, i)) || n.enumerable });
    return e;
  };
  var _ = (e, r, t) => (t = e != null ? Fl(ql(e)) : {}, no(r || !e || !e.__esModule ? Rt(t, "default", { value: e, enumerable: true }) : t, e));
  var Vl = (e) => no(Rt({}, "__esModule", { value: true }), e);
  var Ao = X((Od, Un) => {
    var v = Un.exports;
    Un.exports.default = v;
    var D = "\x1B[", Br = "\x1B]", dr = "\x07", Ft = ";", So = false;
    v.cursorTo = (e, r) => {
      if (typeof e != "number")
        throw new TypeError("The `x` argument is required");
      return typeof r != "number" ? D + (e + 1) + "G" : D + (r + 1) + ";" + (e + 1) + "H";
    };
    v.cursorMove = (e, r) => {
      if (typeof e != "number")
        throw new TypeError("The `x` argument is required");
      let t = "";
      return e < 0 ? t += D + -e + "D" : e > 0 && (t += D + e + "C"), r < 0 ? t += D + -r + "A" : r > 0 && (t += D + r + "B"), t;
    };
    v.cursorUp = (e = 1) => D + e + "A";
    v.cursorDown = (e = 1) => D + e + "B";
    v.cursorForward = (e = 1) => D + e + "C";
    v.cursorBackward = (e = 1) => D + e + "D";
    v.cursorLeft = D + "G";
    v.cursorSavePosition = So ? "\x1B7" : D + "s";
    v.cursorRestorePosition = So ? "\x1B8" : D + "u";
    v.cursorGetPosition = D + "6n";
    v.cursorNextLine = D + "E";
    v.cursorPrevLine = D + "F";
    v.cursorHide = D + "?25l";
    v.cursorShow = D + "?25h";
    v.eraseLines = (e) => {
      let r = "";
      for (let t = 0;t < e; t++)
        r += v.eraseLine + (t < e - 1 ? v.cursorUp() : "");
      return e && (r += v.cursorLeft), r;
    };
    v.eraseEndLine = D + "K";
    v.eraseStartLine = D + "1K";
    v.eraseLine = D + "2K";
    v.eraseDown = D + "J";
    v.eraseUp = D + "1J";
    v.eraseScreen = D + "2J";
    v.scrollUp = D + "S";
    v.scrollDown = D + "T";
    v.clearScreen = "\x1Bc";
    v.clearTerminal = process.platform === "win32" ? `${v.eraseScreen}${D}0f` : `${v.eraseScreen}${D}3J${D}H`;
    v.beep = dr;
    v.link = (e, r) => [Br, "8", Ft, Ft, r, dr, e, Br, "8", Ft, Ft, dr].join("");
    v.image = (e, r = {}) => {
      let t = `${Br}1337;File=inline=1`;
      return r.width && (t += `;width=${r.width}`), r.height && (t += `;height=${r.height}`), r.preserveAspectRatio === false && (t += ";preserveAspectRatio=0"), t + ":" + e.toString("base64") + dr;
    };
    v.iTerm = { setCwd: (e = process.cwd()) => `${Br}50;CurrentDir=${e}${dr}`, annotation: (e, r = {}) => {
      let t = `${Br}1337;`, n = typeof r.x < "u", i = typeof r.y < "u";
      if ((n || i) && !(n && i && typeof r.length < "u"))
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      return e = e.replace(/\|/g, ""), t += r.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", r.length > 0 ? t += (n ? [e, r.length, r.x, r.y] : [r.length, e]).join("|") : t += e, t + dr;
    } };
  });
  var Qn = X((Fd, Io) => {
    Io.exports = (e, r = process.argv) => {
      let t = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = r.indexOf(t + e), i = r.indexOf("--");
      return n !== -1 && (i === -1 || n < i);
    };
  });
  var Do = X((Md, ko) => {
    var Ru = import.meta.require("os"), _o = import.meta.require("tty"), pe = Qn(), { env: G } = process, je;
    pe("no-color") || pe("no-colors") || pe("color=false") || pe("color=never") ? je = 0 : (pe("color") || pe("colors") || pe("color=true") || pe("color=always")) && (je = 1);
    "FORCE_COLOR" in G && (G.FORCE_COLOR === "true" ? je = 1 : G.FORCE_COLOR === "false" ? je = 0 : je = G.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(G.FORCE_COLOR, 10), 3));
    function Gn(e) {
      return e === 0 ? false : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 };
    }
    function Jn(e, r) {
      if (je === 0)
        return 0;
      if (pe("color=16m") || pe("color=full") || pe("color=truecolor"))
        return 3;
      if (pe("color=256"))
        return 2;
      if (e && !r && je === undefined)
        return 0;
      let t = je || 0;
      if (G.TERM === "dumb")
        return t;
      if (process.platform === "win32") {
        let n = Ru.release().split(".");
        return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? Number(n[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in G)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n) => (n in G)) || G.CI_NAME === "codeship" ? 1 : t;
      if ("TEAMCITY_VERSION" in G)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(G.TEAMCITY_VERSION) ? 1 : 0;
      if (G.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in G) {
        let n = parseInt((G.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (G.TERM_PROGRAM) {
          case "iTerm.app":
            return n >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(G.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(G.TERM) || ("COLORTERM" in G) ? 1 : t;
    }
    function Su(e) {
      let r = Jn(e, e && e.isTTY);
      return Gn(r);
    }
    ko.exports = { supportsColor: Su, stdout: Gn(Jn(true, _o.isatty(1))), stderr: Gn(Jn(true, _o.isatty(2))) };
  });
  var Oo = X(($d, No) => {
    var Au = Do(), fr = Qn();
    function Lo(e) {
      if (/^\d{3,4}$/.test(e)) {
        let t = /(\d{1,2})(\d{2})/.exec(e);
        return { major: 0, minor: parseInt(t[1], 10), patch: parseInt(t[2], 10) };
      }
      let r = (e || "").split(".").map((t) => parseInt(t, 10));
      return { major: r[0], minor: r[1], patch: r[2] };
    }
    function Hn(e) {
      let { env: r } = process;
      if ("FORCE_HYPERLINK" in r)
        return !(r.FORCE_HYPERLINK.length > 0 && parseInt(r.FORCE_HYPERLINK, 10) === 0);
      if (fr("no-hyperlink") || fr("no-hyperlinks") || fr("hyperlink=false") || fr("hyperlink=never"))
        return false;
      if (fr("hyperlink=true") || fr("hyperlink=always") || "NETLIFY" in r)
        return true;
      if (!Au.supportsColor(e) || e && !e.isTTY || process.platform === "win32" || "CI" in r || "TEAMCITY_VERSION" in r)
        return false;
      if ("TERM_PROGRAM" in r) {
        let t = Lo(r.TERM_PROGRAM_VERSION);
        switch (r.TERM_PROGRAM) {
          case "iTerm.app":
            return t.major === 3 ? t.minor >= 1 : t.major > 3;
          case "WezTerm":
            return t.major >= 20200620;
          case "vscode":
            return t.major > 1 || t.major === 1 && t.minor >= 72;
        }
      }
      if ("VTE_VERSION" in r) {
        if (r.VTE_VERSION === "0.50.0")
          return false;
        let t = Lo(r.VTE_VERSION);
        return t.major > 0 || t.minor >= 50;
      }
      return false;
    }
    No.exports = { supportsHyperlink: Hn, stdout: Hn(process.stdout), stderr: Hn(process.stderr) };
  });
  var Mo = X((qd, Vr) => {
    var Iu = Ao(), Wn = Oo(), Fo = (e, r, { target: t = "stdout", ...n } = {}) => Wn[t] ? Iu.link(e, r) : n.fallback === false ? e : typeof n.fallback == "function" ? n.fallback(e, r) : `${e} (\u200B${r}\u200B)`;
    Vr.exports = (e, r, t = {}) => Fo(e, r, t);
    Vr.exports.stderr = (e, r, t = {}) => Fo(e, r, { target: "stderr", ...t });
    Vr.exports.isSupported = Wn.stdout;
    Vr.exports.stderr.isSupported = Wn.stderr;
  });
  var qo = X((Kd, _u) => {
    _u.exports = { name: "dotenv", version: "16.0.3", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { require: "./lib/main.js", types: "./lib/main.d.ts", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", "lint-readme": "standard-markdown", pretest: "npm run lint && npm run dts-check", test: "tap tests/*.js --100 -Rspec", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^17.0.9", decache: "^4.6.1", dtslint: "^3.7.0", sinon: "^12.0.1", standard: "^16.0.4", "standard-markdown": "^7.1.0", "standard-version": "^9.3.2", tap: "^15.1.6", tar: "^6.1.11", typescript: "^4.5.4" }, engines: { node: ">=12" } };
  });
  var Vo = X((zd, $t) => {
    var ku = import.meta.require("fs"), Bo = import.meta.require("path"), Du = import.meta.require("os"), Lu = qo(), Nu = Lu.version, Ou = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function Fu(e) {
      let r = {}, t = e.toString();
      t = t.replace(/\r\n?/mg, `
`);
      let n;
      for (;(n = Ou.exec(t)) != null; ) {
        let i = n[1], o = n[2] || "";
        o = o.trim();
        let s = o[0];
        o = o.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (o = o.replace(/\\n/g, `
`), o = o.replace(/\\r/g, "\r")), r[i] = o;
      }
      return r;
    }
    function zn(e) {
      console.log(`[dotenv@${Nu}][DEBUG] ${e}`);
    }
    function Mu(e) {
      return e[0] === "~" ? Bo.join(Du.homedir(), e.slice(1)) : e;
    }
    function $u(e) {
      let r = Bo.resolve(process.cwd(), ".env"), t = "utf8", n = !!(e && e.debug), i = !!(e && e.override);
      e && (e.path != null && (r = Mu(e.path)), e.encoding != null && (t = e.encoding));
      try {
        let o = Mt.parse(ku.readFileSync(r, { encoding: t }));
        return Object.keys(o).forEach(function(s) {
          Object.prototype.hasOwnProperty.call(process.env, s) ? (i === true && (process.env[s] = o[s]), n && zn(i === true ? `"${s}" is already defined in \`process.env\` and WAS overwritten` : `"${s}" is already defined in \`process.env\` and was NOT overwritten`)) : process.env[s] = o[s];
        }), { parsed: o };
      } catch (o) {
        return n && zn(`Failed to load ${r} ${o.message}`), { error: o };
      }
    }
    var Mt = { config: $u, parse: Fu };
    $t.exports.config = Mt.config;
    $t.exports.parse = Mt.parse;
    $t.exports = Mt;
  });
  var Ho = X((nf, Jo) => {
    Jo.exports = (e) => {
      let r = e.match(/^[ \t]*(?=\S)/gm);
      return r ? r.reduce((t, n) => Math.min(t, n.length), 1 / 0) : 0;
    };
  });
  var Ko = X((of, Wo) => {
    var ju = Ho();
    Wo.exports = (e) => {
      let r = ju(e);
      if (r === 0)
        return e;
      let t = new RegExp(`^[ \\t]{${r}}`, "gm");
      return e.replace(t, "");
    };
  });
  var Xn = X((sf, Uu) => {
    Uu.exports = { name: "@prisma/engines-version", version: "5.11.0-15.efd2449663b3d73d637ea1fd226bafbcf45b3102", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "efd2449663b3d73d637ea1fd226bafbcf45b3102" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.19.22", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
  });
  var ei = X((Bt) => {
    Object.defineProperty(Bt, "__esModule", { value: true });
    Bt.enginesVersion = undefined;
    Bt.enginesVersion = Xn().prisma.enginesVersion;
  });
  var oi = X((_f, Zo) => {
    Zo.exports = (e, r = 1, t) => {
      if (t = { indent: " ", includeEmptyLines: false, ...t }, typeof e != "string")
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);
      if (typeof r != "number")
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof r}\``);
      if (typeof t.indent != "string")
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof t.indent}\``);
      if (r === 0)
        return e;
      let n = t.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return e.replace(n, t.indent.repeat(r));
    };
  });
  var ts = X((Lf, rs) => {
    rs.exports = ({ onlyFirst: e = false } = {}) => {
      let r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(r, e ? undefined : "g");
    };
  });
  var ui = X((Nf, ns) => {
    var Xu = ts();
    ns.exports = (e) => typeof e == "string" ? e.replace(Xu(), "") : e;
  });
  var is = X((Mf, jt) => {
    jt.exports = (e = {}) => {
      let r;
      if (e.repoUrl)
        r = e.repoUrl;
      else if (e.user && e.repo)
        r = `https://github.com/${e.user}/${e.repo}`;
      else
        throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
      let t = new URL(`${r}/issues/new`), n = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
      for (let i of n) {
        let o = e[i];
        if (o !== undefined) {
          if (i === "labels" || i === "projects") {
            if (!Array.isArray(o))
              throw new TypeError(`The \`${i}\` option should be an array`);
            o = o.join(",");
          }
          t.searchParams.set(i, o);
        }
      }
      return t.toString();
    };
    jt.exports.default = jt.exports;
  });
  var Wi = X((C0, Va) => {
    Va.exports = function() {
      function e(r, t, n, i, o) {
        return r < t || n < t ? r > n ? n + 1 : r + 1 : i === o ? t : t + 1;
      }
      return function(r, t) {
        if (r === t)
          return 0;
        if (r.length > t.length) {
          var n = r;
          r = t, t = n;
        }
        for (var i = r.length, o = t.length;i > 0 && r.charCodeAt(i - 1) === t.charCodeAt(o - 1); )
          i--, o--;
        for (var s = 0;s < i && r.charCodeAt(s) === t.charCodeAt(s); )
          s++;
        if (i -= s, o -= s, i === 0 || o < 3)
          return o;
        var a = 0, l, u, c, p, m, f, g, h, A, T, C, E, I = [];
        for (l = 0;l < i; l++)
          I.push(l + 1), I.push(r.charCodeAt(s + l));
        for (var me = I.length - 1;a < o - 3; )
          for (A = t.charCodeAt(s + (u = a)), T = t.charCodeAt(s + (c = a + 1)), C = t.charCodeAt(s + (p = a + 2)), E = t.charCodeAt(s + (m = a + 3)), f = a += 4, l = 0;l < me; l += 2)
            g = I[l], h = I[l + 1], u = e(g, u, c, A, h), c = e(u, c, p, T, h), p = e(c, p, m, C, h), f = e(p, m, f, E, h), I[l] = f, m = p, p = c, c = u, u = g;
        for (;a < o; )
          for (A = t.charCodeAt(s + (u = a)), f = ++a, l = 0;l < me; l += 2)
            g = I[l], I[l] = f = e(g, u, f, A, I[l + 1]), u = g;
        return f;
      };
    }();
  });
  var ld = {};
  Or(ld, { Debug: () => On, Decimal: () => Te, Extensions: () => kn, MetricsClient: () => yr, NotFoundError: () => Le, PrismaClientInitializationError: () => R, PrismaClientKnownRequestError: () => V, PrismaClientRustPanicError: () => ue, PrismaClientUnknownRequestError: () => j, PrismaClientValidationError: () => K, Public: () => Dn, Sql: () => oe, defineDmmfProperty: () => ss, empty: () => ls, getPrismaClient: () => Ll, getRuntime: () => fn, join: () => as, makeStrictEnum: () => Nl, objectEnumValues: () => Gt, raw: () => Ei, sqltag: () => bi, warnEnvConflicts: () => Ol, warnOnce: () => Hr });
  module.exports = Vl(ld);
  var kn = {};
  Or(kn, { defineExtension: () => io, getExtensionContext: () => oo });
  var Dn = {};
  Or(Dn, { validator: () => so });
  var St = {};
  Or(St, { $: () => po, bgBlack: () => Yl, bgBlue: () => ru, bgCyan: () => nu, bgGreen: () => Xl, bgMagenta: () => tu, bgRed: () => Zl, bgWhite: () => iu, bgYellow: () => eu, black: () => Hl, blue: () => Ze, bold: () => W, cyan: () => _e, dim: () => Ie, gray: () => Fr, green: () => $e, grey: () => zl, hidden: () => Gl, inverse: () => Ql, italic: () => Ul, magenta: () => Wl, red: () => ce, reset: () => jl, strikethrough: () => Jl, underline: () => ee, white: () => Kl, yellow: () => de });
  var Ln;
  var ao;
  var lo;
  var uo;
  var co = true;
  typeof process < "u" && ({ FORCE_COLOR: Ln, NODE_DISABLE_COLORS: ao, NO_COLOR: lo, TERM: uo } = process.env || {}, co = process.stdout && process.stdout.isTTY);
  var po = { enabled: !ao && lo == null && uo !== "dumb" && (Ln != null && Ln !== "0" || co) };
  var jl = F(0, 0);
  var W = F(1, 22);
  var Ie = F(2, 22);
  var Ul = F(3, 23);
  var ee = F(4, 24);
  var Ql = F(7, 27);
  var Gl = F(8, 28);
  var Jl = F(9, 29);
  var Hl = F(30, 39);
  var ce = F(31, 39);
  var $e = F(32, 39);
  var de = F(33, 39);
  var Ze = F(34, 39);
  var Wl = F(35, 39);
  var _e = F(36, 39);
  var Kl = F(37, 39);
  var Fr = F(90, 39);
  var zl = F(90, 39);
  var Yl = F(40, 49);
  var Zl = F(41, 49);
  var Xl = F(42, 49);
  var eu = F(43, 49);
  var ru = F(44, 49);
  var tu = F(45, 49);
  var nu = F(46, 49);
  var iu = F(47, 49);
  var ou = 100;
  var mo = ["green", "yellow", "blue", "magenta", "cyan", "red"];
  var Mr = [];
  var fo = Date.now();
  var su = 0;
  var Nn = typeof process < "u" ? process.env : {};
  globalThis.DEBUG ?? (globalThis.DEBUG = Nn.DEBUG ?? "");
  globalThis.DEBUG_COLORS ?? (globalThis.DEBUG_COLORS = Nn.DEBUG_COLORS ? Nn.DEBUG_COLORS === "true" : true);
  var $r = { enable(e) {
    typeof e == "string" && (globalThis.DEBUG = e);
  }, disable() {
    let e = globalThis.DEBUG;
    return globalThis.DEBUG = "", e;
  }, enabled(e) {
    let r = globalThis.DEBUG.split(",").map((i) => i.replace(/[.+?^${}()|[\]\\]/g, "\\$&")), t = r.some((i) => i === "" || i[0] === "-" ? false : e.match(RegExp(i.split("*").join(".*") + "$"))), n = r.some((i) => i === "" || i[0] !== "-" ? false : e.match(RegExp(i.slice(1).split("*").join(".*") + "$")));
    return t && !n;
  }, log: (...e) => {
    let [r, t, ...n] = e, i;
    typeof import.meta.require == "function" && typeof process < "u" && typeof process.stderr < "u" && typeof process.stderr.write == "function" ? i = (...o) => {
      let s = import.meta.require("util");
      process.stderr.write(s.format(...o) + `
`);
    } : i = console.warn ?? console.log, i(`${r} ${t}`, ...n);
  }, formatters: {} };
  var On = new Proxy(au, { get: (e, r) => $r[r], set: (e, r, t) => $r[r] = t });
  var N = On;
  var yo = _(import.meta.require("fs"));
  var Mn = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "freebsd14", "freebsd15", "openbsd", "netbsd", "arm"];
  var At = "libquery_engine";
  var xo = _(import.meta.require("child_process"));
  var Vn = _(import.meta.require("fs/promises"));
  var Nt = _(import.meta.require("os"));
  var ke = Symbol.for("@ts-pattern/matcher");
  var uu = Symbol.for("@ts-pattern/isVariadic");
  var kt = "@ts-pattern/anonymous-select-key";
  var $n = (e) => !!(e && typeof e == "object");
  var _t = (e) => e && !!e[ke];
  var we = (e, r, t) => {
    if (_t(e)) {
      let n = e[ke](), { matched: i, selections: o } = n.match(r);
      return i && o && Object.keys(o).forEach((s) => t(s, o[s])), i;
    }
    if ($n(e)) {
      if (!$n(r))
        return false;
      if (Array.isArray(e)) {
        if (!Array.isArray(r))
          return false;
        let n = [], i = [], o = [];
        for (let s of e.keys()) {
          let a = e[s];
          _t(a) && a[uu] ? o.push(a) : o.length ? i.push(a) : n.push(a);
        }
        if (o.length) {
          if (o.length > 1)
            throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");
          if (r.length < n.length + i.length)
            return false;
          let s = r.slice(0, n.length), a = i.length === 0 ? [] : r.slice(-i.length), l = r.slice(n.length, i.length === 0 ? 1 / 0 : -i.length);
          return n.every((u, c) => we(u, s[c], t)) && i.every((u, c) => we(u, a[c], t)) && (o.length === 0 || we(o[0], l, t));
        }
        return e.length === r.length && e.every((s, a) => we(s, r[a], t));
      }
      return Object.keys(e).every((n) => {
        let i = e[n];
        return ((n in r) || _t(o = i) && o[ke]().matcherType === "optional") && we(i, r[n], t);
        var o;
      });
    }
    return Object.is(r, e);
  };
  var Ve = (e) => {
    var r, t, n;
    return $n(e) ? _t(e) ? (r = (t = (n = e[ke]()).getSelectionKeys) == null ? undefined : t.call(n)) != null ? r : [] : Array.isArray(e) ? qr(e, Ve) : qr(Object.values(e), Ve) : [];
  };
  var qr = (e, r) => e.reduce((t, n) => t.concat(r(n)), []);
  var xd = fe(k(function(e) {
    return true;
  }));
  var er = (e) => Object.assign(fe(e), { startsWith: (r) => {
    return er(B(e, (t = r, k((n) => Xe(n) && n.startsWith(t)))));
    var t;
  }, endsWith: (r) => {
    return er(B(e, (t = r, k((n) => Xe(n) && n.endsWith(t)))));
    var t;
  }, minLength: (r) => er(B(e, ((t) => k((n) => Xe(n) && n.length >= t))(r))), maxLength: (r) => er(B(e, ((t) => k((n) => Xe(n) && n.length <= t))(r))), includes: (r) => {
    return er(B(e, (t = r, k((n) => Xe(n) && n.includes(t)))));
    var t;
  }, regex: (r) => {
    return er(B(e, (t = r, k((n) => Xe(n) && !!n.match(t)))));
    var t;
  } });
  var Pd = er(k(Xe));
  var be = (e) => Object.assign(fe(e), { between: (r, t) => be(B(e, ((n, i) => k((o) => Ee(o) && n <= o && i >= o))(r, t))), lt: (r) => be(B(e, ((t) => k((n) => Ee(n) && n < t))(r))), gt: (r) => be(B(e, ((t) => k((n) => Ee(n) && n > t))(r))), lte: (r) => be(B(e, ((t) => k((n) => Ee(n) && n <= t))(r))), gte: (r) => be(B(e, ((t) => k((n) => Ee(n) && n >= t))(r))), int: () => be(B(e, k((r) => Ee(r) && Number.isInteger(r)))), finite: () => be(B(e, k((r) => Ee(r) && Number.isFinite(r)))), positive: () => be(B(e, k((r) => Ee(r) && r > 0))), negative: () => be(B(e, k((r) => Ee(r) && r < 0))) });
  var vd = be(k(Ee));
  var Be = (e) => Object.assign(fe(e), { between: (r, t) => Be(B(e, ((n, i) => k((o) => qe(o) && n <= o && i >= o))(r, t))), lt: (r) => Be(B(e, ((t) => k((n) => qe(n) && n < t))(r))), gt: (r) => Be(B(e, ((t) => k((n) => qe(n) && n > t))(r))), lte: (r) => Be(B(e, ((t) => k((n) => qe(n) && n <= t))(r))), gte: (r) => Be(B(e, ((t) => k((n) => qe(n) && n >= t))(r))), positive: () => Be(B(e, k((r) => qe(r) && r > 0))), negative: () => Be(B(e, k((r) => qe(r) && r < 0))) });
  var Td = Be(k(qe));
  var Cd = fe(k(function(e) {
    return typeof e == "boolean";
  }));
  var Rd = fe(k(function(e) {
    return typeof e == "symbol";
  }));
  var Sd = fe(k(function(e) {
    return e == null;
  }));
  var qn = { matched: false, value: undefined };
  var Bn = class e {
    constructor(r, t) {
      this.input = undefined, this.state = undefined, this.input = r, this.state = t;
    }
    with(...r) {
      if (this.state.matched)
        return this;
      let t = r[r.length - 1], n = [r[0]], i;
      r.length === 3 && typeof r[1] == "function" ? i = r[1] : r.length > 2 && n.push(...r.slice(1, r.length - 1));
      let o = false, s = {}, a = (u, c) => {
        o = true, s[u] = c;
      }, l = !n.some((u) => we(u, this.input, a)) || i && !i(this.input) ? qn : { matched: true, value: t(o ? kt in s ? s[kt] : s : this.input, this.input) };
      return new e(this.input, l);
    }
    when(r, t) {
      if (this.state.matched)
        return this;
      let n = !!r(this.input);
      return new e(this.input, n ? { matched: true, value: t(this.input, this.input) } : qn);
    }
    otherwise(r) {
      return this.state.matched ? this.state.value : r(this.input);
    }
    exhaustive() {
      if (this.state.matched)
        return this.state.value;
      let r;
      try {
        r = JSON.stringify(this.input);
      } catch {
        r = this.input;
      }
      throw new Error(`Pattern matching error: no pattern matches value ${r}`);
    }
    run() {
      return this.exhaustive();
    }
    returnType() {
      return this;
    }
  };
  var Po = import.meta.require("util");
  var mu = { warn: de("prisma:warn") };
  var du = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var fu = (0, Po.promisify)(xo.default.exec);
  var te = N("prisma:get-platform");
  var gu = ["1.0.x", "1.1.x", "3.0.x"];
  var Lt = {};
  var $o = _(Mo());
  var Zn = _(Vo());
  var qt = _(import.meta.require("fs"));
  var gr = _(import.meta.require("path"));
  var Yn = N("prisma:tryLoadEnv");
  var Go = "library";
  var Qu = _(ei());
  var M = _(import.meta.require("path"));
  var Gu = _(ei());
  var hf = N("prisma:engines");
  var yf = "libquery-engine";
  M.default.join(__dirname, "../query-engine-darwin");
  M.default.join(__dirname, "../query-engine-darwin-arm64");
  M.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
  M.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
  M.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
  M.default.join(__dirname, "../query-engine-linux-static-x64");
  M.default.join(__dirname, "../query-engine-linux-static-arm64");
  M.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
  M.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
  M.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
  M.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
  M.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
  M.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
  M.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
  M.default.join(__dirname, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
  M.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
  M.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
  M.default.join(__dirname, "../query_engine-windows.dll.node");
  var ri = _(import.meta.require("fs"));
  var Yo = N("chmodPlusX");
  var De;
  ((r) => {
    let e;
    ((E) => (E.findUnique = "findUnique", E.findUniqueOrThrow = "findUniqueOrThrow", E.findFirst = "findFirst", E.findFirstOrThrow = "findFirstOrThrow", E.findMany = "findMany", E.create = "create", E.createMany = "createMany", E.update = "update", E.updateMany = "updateMany", E.upsert = "upsert", E.delete = "delete", E.deleteMany = "deleteMany", E.groupBy = "groupBy", E.count = "count", E.aggregate = "aggregate", E.findRaw = "findRaw", E.aggregateRaw = "aggregateRaw"))(e = r.ModelAction || (r.ModelAction = {}));
  })(De || (De = {}));
  var Qr = _(import.meta.require("path"));
  var Xo = _(oi());
  var si = class {
    constructor(r) {
      this.config = r;
    }
    toString() {
      let { config: r } = this, t = r.provider.fromEnvVar ? `env("${r.provider.fromEnvVar}")` : r.provider.value, n = JSON.parse(JSON.stringify({ provider: t, binaryTargets: Ju(r.binaryTargets) }));
      return `generator ${r.name} {
${(0, Xo.default)(Hu(n), 2)}
}`;
    }
  };
  var Jr = {};
  Or(Jr, { error: () => Yu, info: () => zu, log: () => Ku, query: () => Zu, should: () => es, tags: () => Gr, warn: () => li });
  var Gr = { error: ce("prisma:error"), warn: de("prisma:warn"), info: _e("prisma:info"), query: Ze("prisma:query") };
  var es = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var pi = (e, r) => e.reduce((t, n) => (t[r(n)] = n, t), {});
  var os = new Set;
  var Hr = (e, r, ...t) => {
    os.has(e) || (os.add(e), li(r, ...t));
  };
  var V = class extends Error {
    constructor(r, { code: t, clientVersion: n, meta: i, batchRequestIdx: o }) {
      super(r), this.name = "PrismaClientKnownRequestError", this.code = t, this.clientVersion = n, this.meta = i, Object.defineProperty(this, "batchRequestIdx", { value: o, enumerable: false, writable: true });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
  w(V, "PrismaClientKnownRequestError");
  var Le = class extends V {
    constructor(r, t) {
      super(r, { code: "P2025", clientVersion: t }), this.name = "NotFoundError";
    }
  };
  w(Le, "NotFoundError");
  var R = class e extends Error {
    constructor(r, t, n) {
      super(r), this.name = "PrismaClientInitializationError", this.clientVersion = t, this.errorCode = n, Error.captureStackTrace(e);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
  w(R, "PrismaClientInitializationError");
  var ue = class extends Error {
    constructor(r, t) {
      super(r), this.name = "PrismaClientRustPanicError", this.clientVersion = t;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
  w(ue, "PrismaClientRustPanicError");
  var j = class extends Error {
    constructor(r, { clientVersion: t, batchRequestIdx: n }) {
      super(r), this.name = "PrismaClientUnknownRequestError", this.clientVersion = t, Object.defineProperty(this, "batchRequestIdx", { value: n, writable: true, enumerable: false });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
  w(j, "PrismaClientUnknownRequestError");
  var K = class extends Error {
    constructor(t, { clientVersion: n }) {
      super(t);
      this.name = "PrismaClientValidationError";
      this.clientVersion = n;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientValidationError";
    }
  };
  w(K, "PrismaClientValidationError");
  var yr = class {
    constructor(r) {
      this._engine = r;
    }
    prometheus(r) {
      return this._engine.metrics({ format: "prometheus", ...r });
    }
    json(r) {
      return this._engine.metrics({ format: "json", ...r });
    }
  };
  var Qt = Symbol();
  var fi = new WeakMap;
  var Ne = class {
    constructor(r) {
      r === Qt ? fi.set(this, `Prisma.${this._getName()}`) : fi.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
    }
    _getName() {
      return this.constructor.name;
    }
    toString() {
      return fi.get(this);
    }
  };
  var Kr = class extends Ne {
    _getNamespace() {
      return "NullTypes";
    }
  };
  var zr = class extends Kr {
  };
  gi(zr, "DbNull");
  var Yr = class extends Kr {
  };
  gi(Yr, "JsonNull");
  var Zr = class extends Kr {
  };
  gi(Zr, "AnyNull");
  var Gt = { classes: { DbNull: zr, JsonNull: Yr, AnyNull: Zr }, instances: { DbNull: new zr(Qt), JsonNull: new Yr(Qt), AnyNull: new Zr(Qt) } };
  var hi = class {
    constructor() {
      this.registeredErrors = [];
    }
    consumeError(r) {
      return this.registeredErrors[r];
    }
    registerNewError(r) {
      let t = 0;
      for (;this.registeredErrors[t] !== undefined; )
        t++;
      return this.registeredErrors[t] = { error: r }, t;
    }
  };
  var yi = (e) => {
    let r = new hi, t = nr(r, e.startTransaction.bind(e)), n = { errorRegistry: r, queryRaw: nr(r, e.queryRaw.bind(e)), executeRaw: nr(r, e.executeRaw.bind(e)), provider: e.provider, startTransaction: async (...i) => (await t(...i)).map((s) => rc(r, s)) };
    return e.getConnectionInfo && (n.getConnectionInfo = tc(r, e.getConnectionInfo.bind(e))), n;
  };
  var rc = (e, r) => ({ provider: r.provider, options: r.options, queryRaw: nr(e, r.queryRaw.bind(r)), executeRaw: nr(e, r.executeRaw.bind(r)), commit: nr(e, r.commit.bind(r)), rollback: nr(e, r.rollback.bind(r)) });
  var Il = _(Xn());
  var _l = import.meta.require("async_hooks");
  var kl = import.meta.require("events");
  var Dl = _(import.meta.require("fs"));
  var Tt = _(import.meta.require("path"));
  var oe = class e {
    constructor(r, t) {
      if (r.length - 1 !== t.length)
        throw r.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${r.length} strings to have ${r.length - 1} values`);
      let n = t.reduce((s, a) => s + (a instanceof e ? a.values.length : 1), 0);
      this.values = new Array(n), this.strings = new Array(n + 1), this.strings[0] = r[0];
      let i = 0, o = 0;
      for (;i < t.length; ) {
        let s = t[i++], a = r[i];
        if (s instanceof e) {
          this.strings[o] += s.strings[0];
          let l = 0;
          for (;l < s.values.length; )
            this.values[o++] = s.values[l++], this.strings[o] = s.strings[l];
          this.strings[o] += a;
        } else
          this.values[o++] = s, this.strings[o] = a;
      }
    }
    get text() {
      let r = this.strings.length, t = 1, n = this.strings[0];
      for (;t < r; )
        n += `\$${t}${this.strings[t++]}`;
      return n;
    }
    get sql() {
      let r = this.strings.length, t = 1, n = this.strings[0];
      for (;t < r; )
        n += `?${this.strings[t++]}`;
      return n;
    }
    get statement() {
      let r = this.strings.length, t = 1, n = this.strings[0];
      for (;t < r; )
        n += `:${t}${this.strings[t++]}`;
      return n;
    }
    inspect() {
      return { text: this.text, sql: this.sql, values: this.values };
    }
  };
  var ls = Ei("");
  var xe = class {
    constructor() {
      this._map = new Map;
    }
    get(r) {
      return this._map.get(r)?.value;
    }
    set(r, t) {
      this._map.set(r, { value: t });
    }
    getOrCreate(r, t) {
      let n = this._map.get(r);
      if (n)
        return n.value;
      let i = t();
      return this.set(r, i), i;
    }
  };
  var Jt = { enumerable: true, configurable: true, writable: true };
  var us = Symbol.for("nodejs.util.inspect.custom");
  var br = class {
    constructor(r = 0, t) {
      this.context = t;
      this.lines = [];
      this.currentLine = "";
      this.currentIndent = 0;
      this.currentIndent = r;
    }
    write(r) {
      return typeof r == "string" ? this.currentLine += r : r.write(this), this;
    }
    writeJoined(r, t) {
      let n = t.length - 1;
      for (let i = 0;i < t.length; i++)
        this.write(t[i]), i !== n && this.write(r);
      return this;
    }
    writeLine(r) {
      return this.write(r).newLine();
    }
    newLine() {
      this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = undefined;
      let r = this.afterNextNewLineCallback;
      return this.afterNextNewLineCallback = undefined, r?.(), this;
    }
    withIndent(r) {
      return this.indent(), r(this), this.unindent(), this;
    }
    afterNextNewline(r) {
      return this.afterNextNewLineCallback = r, this;
    }
    indent() {
      return this.currentIndent++, this;
    }
    unindent() {
      return this.currentIndent > 0 && this.currentIndent--, this;
    }
    addMarginSymbol(r) {
      return this.marginSymbol = r, this;
    }
    toString() {
      return this.lines.concat(this.indentedCurrentLine()).join(`
`);
    }
    getCurrentLineLength() {
      return this.currentLine.length;
    }
    indentedCurrentLine() {
      let r = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
      return this.marginSymbol ? this.marginSymbol + r.slice(1) : r;
    }
  };
  var xr = 9000000000000000;
  var Je = 1e9;
  var wi = "0123456789abcdef";
  var zt = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var Yt = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var xi = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -xr, maxE: xr, crypto: false };
  var gs;
  var Oe;
  var x = true;
  var Xt = "[DecimalError] ";
  var Ge = Xt + "Invalid argument: ";
  var hs = Xt + "Precision limit exceeded";
  var ys = Xt + "crypto unavailable";
  var Es = "[object Decimal]";
  var re = Math.floor;
  var Q = Math.pow;
  var ic = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var oc = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var sc = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var bs = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var he = 1e7;
  var b = 7;
  var ac = 9007199254740991;
  var lc = zt.length - 1;
  var Pi = Yt.length - 1;
  var d = { toStringTag: Es };
  d.absoluteValue = d.abs = function() {
    var e = new this.constructor(this);
    return e.s < 0 && (e.s = 1), y(e);
  };
  d.ceil = function() {
    return y(new this.constructor(this), this.e + 1, 2);
  };
  d.clampedTo = d.clamp = function(e, r) {
    var t, n = this, i = n.constructor;
    if (e = new i(e), r = new i(r), !e.s || !r.s)
      return new i(NaN);
    if (e.gt(r))
      throw Error(Ge + r);
    return t = n.cmp(e), t < 0 ? e : n.cmp(r) > 0 ? r : new i(n);
  };
  d.comparedTo = d.cmp = function(e) {
    var r, t, n, i, o = this, s = o.d, a = (e = new o.constructor(e)).d, l = o.s, u = e.s;
    if (!s || !a)
      return !l || !u ? NaN : l !== u ? l : s === a ? 0 : !s ^ l < 0 ? 1 : -1;
    if (!s[0] || !a[0])
      return s[0] ? l : a[0] ? -u : 0;
    if (l !== u)
      return l;
    if (o.e !== e.e)
      return o.e > e.e ^ l < 0 ? 1 : -1;
    for (n = s.length, i = a.length, r = 0, t = n < i ? n : i;r < t; ++r)
      if (s[r] !== a[r])
        return s[r] > a[r] ^ l < 0 ? 1 : -1;
    return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
  };
  d.cosine = d.cos = function() {
    var e, r, t = this, n = t.constructor;
    return t.d ? t.d[0] ? (e = n.precision, r = n.rounding, n.precision = e + Math.max(t.e, t.sd()) + b, n.rounding = 1, t = uc(n, Ts(n, t)), n.precision = e, n.rounding = r, y(Oe == 2 || Oe == 3 ? t.neg() : t, e, r, true)) : new n(1) : new n(NaN);
  };
  d.cubeRoot = d.cbrt = function() {
    var e, r, t, n, i, o, s, a, l, u, c = this, p = c.constructor;
    if (!c.isFinite() || c.isZero())
      return new p(c);
    for (x = false, o = c.s * Q(c.s * c, 1 / 3), !o || Math.abs(o) == 1 / 0 ? (t = z(c.d), e = c.e, (o = (e - t.length + 1) % 3) && (t += o == 1 || o == -2 ? "0" : "00"), o = Q(t, 1 / 3), e = re((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), o == 1 / 0 ? t = "5e" + e : (t = o.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + e), n = new p(t), n.s = c.s) : n = new p(o.toString()), s = (e = p.precision) + 3;; )
      if (a = n, l = a.times(a).times(a), u = l.plus(c), n = O(u.plus(c).times(a), u.plus(l), s + 2, 1), z(a.d).slice(0, s) === (t = z(n.d)).slice(0, s))
        if (t = t.slice(s - 3, s + 1), t == "9999" || !i && t == "4999") {
          if (!i && (y(a, e + 1, 0), a.times(a).times(a).eq(c))) {
            n = a;
            break;
          }
          s += 4, i = 1;
        } else {
          (!+t || !+t.slice(1) && t.charAt(0) == "5") && (y(n, e + 1, 1), r = !n.times(n).times(n).eq(c));
          break;
        }
    return x = true, y(n, e, p.rounding, r);
  };
  d.decimalPlaces = d.dp = function() {
    var e, r = this.d, t = NaN;
    if (r) {
      if (e = r.length - 1, t = (e - re(this.e / b)) * b, e = r[e], e)
        for (;e % 10 == 0; e /= 10)
          t--;
      t < 0 && (t = 0);
    }
    return t;
  };
  d.dividedBy = d.div = function(e) {
    return O(this, new this.constructor(e));
  };
  d.dividedToIntegerBy = d.divToInt = function(e) {
    var r = this, t = r.constructor;
    return y(O(r, new t(e), 0, 1, 1), t.precision, t.rounding);
  };
  d.equals = d.eq = function(e) {
    return this.cmp(e) === 0;
  };
  d.floor = function() {
    return y(new this.constructor(this), this.e + 1, 3);
  };
  d.greaterThan = d.gt = function(e) {
    return this.cmp(e) > 0;
  };
  d.greaterThanOrEqualTo = d.gte = function(e) {
    var r = this.cmp(e);
    return r == 1 || r === 0;
  };
  d.hyperbolicCosine = d.cosh = function() {
    var e, r, t, n, i, o = this, s = o.constructor, a = new s(1);
    if (!o.isFinite())
      return new s(o.s ? 1 / 0 : NaN);
    if (o.isZero())
      return a;
    t = s.precision, n = s.rounding, s.precision = t + Math.max(o.e, o.sd()) + 4, s.rounding = 1, i = o.d.length, i < 32 ? (e = Math.ceil(i / 3), r = (1 / rn(4, e)).toString()) : (e = 16, r = "2.3283064365386962890625e-10"), o = Pr(s, 1, o.times(r), new s(1), true);
    for (var l, u = e, c = new s(8);u--; )
      l = o.times(o), o = a.minus(l.times(c.minus(l.times(c))));
    return y(o, s.precision = t, s.rounding = n, true);
  };
  d.hyperbolicSine = d.sinh = function() {
    var e, r, t, n, i = this, o = i.constructor;
    if (!i.isFinite() || i.isZero())
      return new o(i);
    if (r = o.precision, t = o.rounding, o.precision = r + Math.max(i.e, i.sd()) + 4, o.rounding = 1, n = i.d.length, n < 3)
      i = Pr(o, 2, i, i, true);
    else {
      e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, i = i.times(1 / rn(5, e)), i = Pr(o, 2, i, i, true);
      for (var s, a = new o(5), l = new o(16), u = new o(20);e--; )
        s = i.times(i), i = i.times(a.plus(s.times(l.times(s).plus(u))));
    }
    return o.precision = r, o.rounding = t, y(i, r, t, true);
  };
  d.hyperbolicTangent = d.tanh = function() {
    var e, r, t = this, n = t.constructor;
    return t.isFinite() ? t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + 7, n.rounding = 1, O(t.sinh(), t.cosh(), n.precision = e, n.rounding = r)) : new n(t.s);
  };
  d.inverseCosine = d.acos = function() {
    var e, r = this, t = r.constructor, n = r.abs().cmp(1), i = t.precision, o = t.rounding;
    return n !== -1 ? n === 0 ? r.isNeg() ? ge(t, i, o) : new t(0) : new t(NaN) : r.isZero() ? ge(t, i + 4, o).times(0.5) : (t.precision = i + 6, t.rounding = 1, r = r.asin(), e = ge(t, i + 4, o).times(0.5), t.precision = i, t.rounding = o, e.minus(r));
  };
  d.inverseHyperbolicCosine = d.acosh = function() {
    var e, r, t = this, n = t.constructor;
    return t.lte(1) ? new n(t.eq(1) ? 0 : NaN) : t.isFinite() ? (e = n.precision, r = n.rounding, n.precision = e + Math.max(Math.abs(t.e), t.sd()) + 4, n.rounding = 1, x = false, t = t.times(t).minus(1).sqrt().plus(t), x = true, n.precision = e, n.rounding = r, t.ln()) : new n(t);
  };
  d.inverseHyperbolicSine = d.asinh = function() {
    var e, r, t = this, n = t.constructor;
    return !t.isFinite() || t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + 2 * Math.max(Math.abs(t.e), t.sd()) + 6, n.rounding = 1, x = false, t = t.times(t).plus(1).sqrt().plus(t), x = true, n.precision = e, n.rounding = r, t.ln());
  };
  d.inverseHyperbolicTangent = d.atanh = function() {
    var e, r, t, n, i = this, o = i.constructor;
    return i.isFinite() ? i.e >= 0 ? new o(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = o.precision, r = o.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? y(new o(i), e, r, true) : (o.precision = t = n - i.e, i = O(i.plus(1), new o(1).minus(i), t + e, 1), o.precision = e + 4, o.rounding = 1, i = i.ln(), o.precision = e, o.rounding = r, i.times(0.5))) : new o(NaN);
  };
  d.inverseSine = d.asin = function() {
    var e, r, t, n, i = this, o = i.constructor;
    return i.isZero() ? new o(i) : (r = i.abs().cmp(1), t = o.precision, n = o.rounding, r !== -1 ? r === 0 ? (e = ge(o, t + 4, n).times(0.5), e.s = i.s, e) : new o(NaN) : (o.precision = t + 6, o.rounding = 1, i = i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(), o.precision = t, o.rounding = n, i.times(2)));
  };
  d.inverseTangent = d.atan = function() {
    var e, r, t, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, m = c.rounding;
    if (u.isFinite()) {
      if (u.isZero())
        return new c(u);
      if (u.abs().eq(1) && p + 4 <= Pi)
        return s = ge(c, p + 4, m).times(0.25), s.s = u.s, s;
    } else {
      if (!u.s)
        return new c(NaN);
      if (p + 4 <= Pi)
        return s = ge(c, p + 4, m).times(0.5), s.s = u.s, s;
    }
    for (c.precision = a = p + 10, c.rounding = 1, t = Math.min(28, a / b + 2 | 0), e = t;e; --e)
      u = u.div(u.times(u).plus(1).sqrt().plus(1));
    for (x = false, r = Math.ceil(a / b), n = 1, l = u.times(u), s = new c(u), i = u;e !== -1; )
      if (i = i.times(l), o = s.minus(i.div(n += 2)), i = i.times(l), s = o.plus(i.div(n += 2)), s.d[r] !== undefined)
        for (e = r;s.d[e] === o.d[e] && e--; )
          ;
    return t && (s = s.times(2 << t - 1)), x = true, y(s, c.precision = p, c.rounding = m, true);
  };
  d.isFinite = function() {
    return !!this.d;
  };
  d.isInteger = d.isInt = function() {
    return !!this.d && re(this.e / b) > this.d.length - 2;
  };
  d.isNaN = function() {
    return !this.s;
  };
  d.isNegative = d.isNeg = function() {
    return this.s < 0;
  };
  d.isPositive = d.isPos = function() {
    return this.s > 0;
  };
  d.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  d.lessThan = d.lt = function(e) {
    return this.cmp(e) < 0;
  };
  d.lessThanOrEqualTo = d.lte = function(e) {
    return this.cmp(e) < 1;
  };
  d.logarithm = d.log = function(e) {
    var r, t, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, m = c.rounding, f = 5;
    if (e == null)
      e = new c(10), r = true;
    else {
      if (e = new c(e), t = e.d, e.s < 0 || !t || !t[0] || e.eq(1))
        return new c(NaN);
      r = e.eq(10);
    }
    if (t = u.d, u.s < 0 || !t || !t[0] || u.eq(1))
      return new c(t && !t[0] ? -1 / 0 : u.s != 1 ? NaN : t ? 0 : 1 / 0);
    if (r)
      if (t.length > 1)
        o = true;
      else {
        for (i = t[0];i % 10 === 0; )
          i /= 10;
        o = i !== 1;
      }
    if (x = false, a = p + f, s = Qe(u, a), n = r ? Zt(c, a + 10) : Qe(e, a), l = O(s, n, a, 1), tt(l.d, i = p, m))
      do
        if (a += 10, s = Qe(u, a), n = r ? Zt(c, a + 10) : Qe(e, a), l = O(s, n, a, 1), !o) {
          +z(l.d).slice(i + 1, i + 15) + 1 == 100000000000000 && (l = y(l, p + 1, 0));
          break;
        }
      while (tt(l.d, i += 10, m));
    return x = true, y(l, p, m);
  };
  d.minus = d.sub = function(e) {
    var r, t, n, i, o, s, a, l, u, c, p, m, f = this, g = f.constructor;
    if (e = new g(e), !f.d || !e.d)
      return !f.s || !e.s ? e = new g(NaN) : f.d ? e.s = -e.s : e = new g(e.d || f.s !== e.s ? f : NaN), e;
    if (f.s != e.s)
      return e.s = -e.s, f.plus(e);
    if (u = f.d, m = e.d, a = g.precision, l = g.rounding, !u[0] || !m[0]) {
      if (m[0])
        e.s = -e.s;
      else if (u[0])
        e = new g(f);
      else
        return new g(l === 3 ? -0 : 0);
      return x ? y(e, a, l) : e;
    }
    if (t = re(e.e / b), c = re(f.e / b), u = u.slice(), o = c - t, o) {
      for (p = o < 0, p ? (r = u, o = -o, s = m.length) : (r = m, t = c, s = u.length), n = Math.max(Math.ceil(a / b), s) + 2, o > n && (o = n, r.length = 1), r.reverse(), n = o;n--; )
        r.push(0);
      r.reverse();
    } else {
      for (n = u.length, s = m.length, p = n < s, p && (s = n), n = 0;n < s; n++)
        if (u[n] != m[n]) {
          p = u[n] < m[n];
          break;
        }
      o = 0;
    }
    for (p && (r = u, u = m, m = r, e.s = -e.s), s = u.length, n = m.length - s;n > 0; --n)
      u[s++] = 0;
    for (n = m.length;n > o; ) {
      if (u[--n] < m[n]) {
        for (i = n;i && u[--i] === 0; )
          u[i] = he - 1;
        --u[i], u[n] += he;
      }
      u[n] -= m[n];
    }
    for (;u[--s] === 0; )
      u.pop();
    for (;u[0] === 0; u.shift())
      --t;
    return u[0] ? (e.d = u, e.e = en(u, t), x ? y(e, a, l) : e) : new g(l === 3 ? -0 : 0);
  };
  d.modulo = d.mod = function(e) {
    var r, t = this, n = t.constructor;
    return e = new n(e), !t.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || t.d && !t.d[0] ? y(new n(t), n.precision, n.rounding) : (x = false, n.modulo == 9 ? (r = O(t, e.abs(), 0, 3, 1), r.s *= e.s) : r = O(t, e, 0, n.modulo, 1), r = r.times(e), x = true, t.minus(r));
  };
  d.naturalExponential = d.exp = function() {
    return vi(this);
  };
  d.naturalLogarithm = d.ln = function() {
    return Qe(this);
  };
  d.negated = d.neg = function() {
    var e = new this.constructor(this);
    return e.s = -e.s, y(e);
  };
  d.plus = d.add = function(e) {
    var r, t, n, i, o, s, a, l, u, c, p = this, m = p.constructor;
    if (e = new m(e), !p.d || !e.d)
      return !p.s || !e.s ? e = new m(NaN) : p.d || (e = new m(e.d || p.s === e.s ? p : NaN)), e;
    if (p.s != e.s)
      return e.s = -e.s, p.minus(e);
    if (u = p.d, c = e.d, a = m.precision, l = m.rounding, !u[0] || !c[0])
      return c[0] || (e = new m(p)), x ? y(e, a, l) : e;
    if (o = re(p.e / b), n = re(e.e / b), u = u.slice(), i = o - n, i) {
      for (i < 0 ? (t = u, i = -i, s = c.length) : (t = c, n = o, s = u.length), o = Math.ceil(a / b), s = o > s ? o + 1 : s + 1, i > s && (i = s, t.length = 1), t.reverse();i--; )
        t.push(0);
      t.reverse();
    }
    for (s = u.length, i = c.length, s - i < 0 && (i = s, t = c, c = u, u = t), r = 0;i; )
      r = (u[--i] = u[i] + c[i] + r) / he | 0, u[i] %= he;
    for (r && (u.unshift(r), ++n), s = u.length;u[--s] == 0; )
      u.pop();
    return e.d = u, e.e = en(u, n), x ? y(e, a, l) : e;
  };
  d.precision = d.sd = function(e) {
    var r, t = this;
    if (e !== undefined && e !== !!e && e !== 1 && e !== 0)
      throw Error(Ge + e);
    return t.d ? (r = ws(t.d), e && t.e + 1 > r && (r = t.e + 1)) : r = NaN, r;
  };
  d.round = function() {
    var e = this, r = e.constructor;
    return y(new r(e), e.e + 1, r.rounding);
  };
  d.sine = d.sin = function() {
    var e, r, t = this, n = t.constructor;
    return t.isFinite() ? t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + Math.max(t.e, t.sd()) + b, n.rounding = 1, t = pc(n, Ts(n, t)), n.precision = e, n.rounding = r, y(Oe > 2 ? t.neg() : t, e, r, true)) : new n(NaN);
  };
  d.squareRoot = d.sqrt = function() {
    var e, r, t, n, i, o, s = this, a = s.d, l = s.e, u = s.s, c = s.constructor;
    if (u !== 1 || !a || !a[0])
      return new c(!u || u < 0 && (!a || a[0]) ? NaN : a ? s : 1 / 0);
    for (x = false, u = Math.sqrt(+s), u == 0 || u == 1 / 0 ? (r = z(a), (r.length + l) % 2 == 0 && (r += "0"), u = Math.sqrt(r), l = re((l + 1) / 2) - (l < 0 || l % 2), u == 1 / 0 ? r = "5e" + l : (r = u.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + l), n = new c(r)) : n = new c(u.toString()), t = (l = c.precision) + 3;; )
      if (o = n, n = o.plus(O(s, o, t + 2, 1)).times(0.5), z(o.d).slice(0, t) === (r = z(n.d)).slice(0, t))
        if (r = r.slice(t - 3, t + 1), r == "9999" || !i && r == "4999") {
          if (!i && (y(o, l + 1, 0), o.times(o).eq(s))) {
            n = o;
            break;
          }
          t += 4, i = 1;
        } else {
          (!+r || !+r.slice(1) && r.charAt(0) == "5") && (y(n, l + 1, 1), e = !n.times(n).eq(s));
          break;
        }
    return x = true, y(n, l, c.rounding, e);
  };
  d.tangent = d.tan = function() {
    var e, r, t = this, n = t.constructor;
    return t.isFinite() ? t.isZero() ? new n(t) : (e = n.precision, r = n.rounding, n.precision = e + 10, n.rounding = 1, t = t.sin(), t.s = 1, t = O(t, new n(1).minus(t.times(t)).sqrt(), e + 10, 0), n.precision = e, n.rounding = r, y(Oe == 2 || Oe == 4 ? t.neg() : t, e, r, true)) : new n(NaN);
  };
  d.times = d.mul = function(e) {
    var r, t, n, i, o, s, a, l, u, c = this, p = c.constructor, m = c.d, f = (e = new p(e)).d;
    if (e.s *= c.s, !m || !m[0] || !f || !f[0])
      return new p(!e.s || m && !m[0] && !f || f && !f[0] && !m ? NaN : !m || !f ? e.s / 0 : e.s * 0);
    for (t = re(c.e / b) + re(e.e / b), l = m.length, u = f.length, l < u && (o = m, m = f, f = o, s = l, l = u, u = s), o = [], s = l + u, n = s;n--; )
      o.push(0);
    for (n = u;--n >= 0; ) {
      for (r = 0, i = l + n;i > n; )
        a = o[i] + f[n] * m[i - n - 1] + r, o[i--] = a % he | 0, r = a / he | 0;
      o[i] = (o[i] + r) % he | 0;
    }
    for (;!o[--s]; )
      o.pop();
    return r ? ++t : o.shift(), e.d = o, e.e = en(o, t), x ? y(e, p.precision, p.rounding) : e;
  };
  d.toBinary = function(e, r) {
    return Ci(this, 2, e, r);
  };
  d.toDecimalPlaces = d.toDP = function(e, r) {
    var t = this, n = t.constructor;
    return t = new n(t), e === undefined ? t : (se(e, 0, Je), r === undefined ? r = n.rounding : se(r, 0, 8), y(t, e + t.e + 1, r));
  };
  d.toExponential = function(e, r) {
    var t, n = this, i = n.constructor;
    return e === undefined ? t = ve(n, true) : (se(e, 0, Je), r === undefined ? r = i.rounding : se(r, 0, 8), n = y(new i(n), e + 1, r), t = ve(n, true, e + 1)), n.isNeg() && !n.isZero() ? "-" + t : t;
  };
  d.toFixed = function(e, r) {
    var t, n, i = this, o = i.constructor;
    return e === undefined ? t = ve(i) : (se(e, 0, Je), r === undefined ? r = o.rounding : se(r, 0, 8), n = y(new o(i), e + i.e + 1, r), t = ve(n, false, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + t : t;
  };
  d.toFraction = function(e) {
    var r, t, n, i, o, s, a, l, u, c, p, m, f = this, g = f.d, h = f.constructor;
    if (!g)
      return new h(f);
    if (u = t = new h(1), n = l = new h(0), r = new h(n), o = r.e = ws(g) - f.e - 1, s = o % b, r.d[0] = Q(10, s < 0 ? b + s : s), e == null)
      e = o > 0 ? r : u;
    else {
      if (a = new h(e), !a.isInt() || a.lt(u))
        throw Error(Ge + a);
      e = a.gt(r) ? o > 0 ? r : u : a;
    }
    for (x = false, a = new h(z(g)), c = h.precision, h.precision = o = g.length * b * 2;p = O(a, r, 0, 1, 1), i = t.plus(p.times(n)), i.cmp(e) != 1; )
      t = n, n = i, i = u, u = l.plus(p.times(i)), l = i, i = r, r = a.minus(p.times(i)), a = i;
    return i = O(e.minus(t), n, 0, 1, 1), l = l.plus(i.times(u)), t = t.plus(i.times(n)), l.s = u.s = f.s, m = O(u, n, o, 1).minus(f).abs().cmp(O(l, t, o, 1).minus(f).abs()) < 1 ? [u, n] : [l, t], h.precision = c, x = true, m;
  };
  d.toHexadecimal = d.toHex = function(e, r) {
    return Ci(this, 16, e, r);
  };
  d.toNearest = function(e, r) {
    var t = this, n = t.constructor;
    if (t = new n(t), e == null) {
      if (!t.d)
        return t;
      e = new n(1), r = n.rounding;
    } else {
      if (e = new n(e), r === undefined ? r = n.rounding : se(r, 0, 8), !t.d)
        return e.s ? t : e;
      if (!e.d)
        return e.s && (e.s = t.s), e;
    }
    return e.d[0] ? (x = false, t = O(t, e, 0, r, 1).times(e), x = true, y(t)) : (e.s = t.s, t = e), t;
  };
  d.toNumber = function() {
    return +this;
  };
  d.toOctal = function(e, r) {
    return Ci(this, 8, e, r);
  };
  d.toPower = d.pow = function(e) {
    var r, t, n, i, o, s, a = this, l = a.constructor, u = +(e = new l(e));
    if (!a.d || !e.d || !a.d[0] || !e.d[0])
      return new l(Q(+a, u));
    if (a = new l(a), a.eq(1))
      return a;
    if (n = l.precision, o = l.rounding, e.eq(1))
      return y(a, n, o);
    if (r = re(e.e / b), r >= e.d.length - 1 && (t = u < 0 ? -u : u) <= ac)
      return i = xs(l, a, t, n), e.s < 0 ? new l(1).div(i) : y(i, n, o);
    if (s = a.s, s < 0) {
      if (r < e.d.length - 1)
        return new l(NaN);
      if (e.d[r] & 1 || (s = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
        return a.s = s, a;
    }
    return t = Q(+a, u), r = t == 0 || !isFinite(t) ? re(u * (Math.log("0." + z(a.d)) / Math.LN10 + a.e + 1)) : new l(t + "").e, r > l.maxE + 1 || r < l.minE - 1 ? new l(r > 0 ? s / 0 : 0) : (x = false, l.rounding = a.s = 1, t = Math.min(12, (r + "").length), i = vi(e.times(Qe(a, n + t)), n), i.d && (i = y(i, n + 5, 1), tt(i.d, n, o) && (r = n + 10, i = y(vi(e.times(Qe(a, r + t)), r), r + 5, 1), +z(i.d).slice(n + 1, n + 15) + 1 == 100000000000000 && (i = y(i, n + 1, 0)))), i.s = s, x = true, l.rounding = o, y(i, n, o));
  };
  d.toPrecision = function(e, r) {
    var t, n = this, i = n.constructor;
    return e === undefined ? t = ve(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (se(e, 1, Je), r === undefined ? r = i.rounding : se(r, 0, 8), n = y(new i(n), e, r), t = ve(n, e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + t : t;
  };
  d.toSignificantDigits = d.toSD = function(e, r) {
    var t = this, n = t.constructor;
    return e === undefined ? (e = n.precision, r = n.rounding) : (se(e, 1, Je), r === undefined ? r = n.rounding : se(r, 0, 8)), y(new n(t), e, r);
  };
  d.toString = function() {
    var e = this, r = e.constructor, t = ve(e, e.e <= r.toExpNeg || e.e >= r.toExpPos);
    return e.isNeg() && !e.isZero() ? "-" + t : t;
  };
  d.truncated = d.trunc = function() {
    return y(new this.constructor(this), this.e + 1, 1);
  };
  d.valueOf = d.toJSON = function() {
    var e = this, r = e.constructor, t = ve(e, e.e <= r.toExpNeg || e.e >= r.toExpPos);
    return e.isNeg() ? "-" + t : t;
  };
  var O = function() {
    function e(n, i, o) {
      var s, a = 0, l = n.length;
      for (n = n.slice();l--; )
        s = n[l] * i + a, n[l] = s % o | 0, a = s / o | 0;
      return a && n.unshift(a), n;
    }
    function r(n, i, o, s) {
      var a, l;
      if (o != s)
        l = o > s ? 1 : -1;
      else
        for (a = l = 0;a < o; a++)
          if (n[a] != i[a]) {
            l = n[a] > i[a] ? 1 : -1;
            break;
          }
      return l;
    }
    function t(n, i, o, s) {
      for (var a = 0;o--; )
        n[o] -= a, a = n[o] < i[o] ? 1 : 0, n[o] = a * s + n[o] - i[o];
      for (;!n[0] && n.length > 1; )
        n.shift();
    }
    return function(n, i, o, s, a, l) {
      var u, c, p, m, f, g, h, A, T, C, E, I, me, le, Nr, U, ie, Ae, Y, pr, Ct = n.constructor, _n = n.s == i.s ? 1 : -1, Z = n.d, L = i.d;
      if (!Z || !Z[0] || !L || !L[0])
        return new Ct(!n.s || !i.s || (Z ? L && Z[0] == L[0] : !L) ? NaN : Z && Z[0] == 0 || !L ? _n * 0 : _n / 0);
      for (l ? (f = 1, c = n.e - i.e) : (l = he, f = b, c = re(n.e / f) - re(i.e / f)), Y = L.length, ie = Z.length, T = new Ct(_n), C = T.d = [], p = 0;L[p] == (Z[p] || 0); p++)
        ;
      if (L[p] > (Z[p] || 0) && c--, o == null ? (le = o = Ct.precision, s = Ct.rounding) : a ? le = o + (n.e - i.e) + 1 : le = o, le < 0)
        C.push(1), g = true;
      else {
        if (le = le / f + 2 | 0, p = 0, Y == 1) {
          for (m = 0, L = L[0], le++;(p < ie || m) && le--; p++)
            Nr = m * l + (Z[p] || 0), C[p] = Nr / L | 0, m = Nr % L | 0;
          g = m || p < ie;
        } else {
          for (m = l / (L[0] + 1) | 0, m > 1 && (L = e(L, m, l), Z = e(Z, m, l), Y = L.length, ie = Z.length), U = Y, E = Z.slice(0, Y), I = E.length;I < Y; )
            E[I++] = 0;
          pr = L.slice(), pr.unshift(0), Ae = L[0], L[1] >= l / 2 && ++Ae;
          do
            m = 0, u = r(L, E, Y, I), u < 0 ? (me = E[0], Y != I && (me = me * l + (E[1] || 0)), m = me / Ae | 0, m > 1 ? (m >= l && (m = l - 1), h = e(L, m, l), A = h.length, I = E.length, u = r(h, E, A, I), u == 1 && (m--, t(h, Y < A ? pr : L, A, l))) : (m == 0 && (u = m = 1), h = L.slice()), A = h.length, A < I && h.unshift(0), t(E, h, I, l), u == -1 && (I = E.length, u = r(L, E, Y, I), u < 1 && (m++, t(E, Y < I ? pr : L, I, l))), I = E.length) : u === 0 && (m++, E = [0]), C[p++] = m, u && E[0] ? E[I++] = Z[U] || 0 : (E = [Z[U]], I = 1);
          while ((U++ < ie || E[0] !== undefined) && le--);
          g = E[0] !== undefined;
        }
        C[0] || C.shift();
      }
      if (f == 1)
        T.e = c, gs = g;
      else {
        for (p = 1, m = C[0];m >= 10; m /= 10)
          p++;
        T.e = p + c * f - 1, y(T, a ? o + T.e + 1 : o, s, g);
      }
      return T;
    };
  }();
  d[Symbol.for("nodejs.util.inspect.custom")] = d.toString;
  d[Symbol.toStringTag] = "Decimal";
  var or = d.constructor = Cs(xi);
  zt = new or(zt);
  Yt = new or(Yt);
  var Te = or;
  var nt = class {
    constructor(r, t, n, i, o) {
      this.modelName = r, this.name = t, this.typeName = n, this.isList = i, this.isEnum = o;
    }
    _toGraphQLInputType() {
      let r = this.isList ? "List" : "", t = this.isEnum ? "Enum" : "";
      return `${r}${t}${this.typeName}FieldRefInput<${this.modelName}>`;
    }
  };
  var tn = class {
    constructor(r) {
      this.value = r;
    }
    write(r) {
      r.write(this.value);
    }
    markAsError() {
      this.value.markAsError();
    }
  };
  var nn = (e) => e;
  var on = { bold: nn, red: nn, green: nn, dim: nn, enabled: false };
  var Rs = { bold: W, red: ce, green: $e, dim: Ie, enabled: true };
  var Cr = { write(e) {
    e.writeLine(",");
  } };
  var Ce = class {
    constructor(r) {
      this.contents = r;
      this.isUnderlined = false;
      this.color = (r2) => r2;
    }
    underline() {
      return this.isUnderlined = true, this;
    }
    setColor(r) {
      return this.color = r, this;
    }
    write(r) {
      let t = r.getCurrentLineLength();
      r.write(this.color(this.contents)), this.isUnderlined && r.afterNextNewline(() => {
        r.write(" ".repeat(t)).writeLine(this.color("~".repeat(this.contents.length)));
      });
    }
  };
  var He = class {
    constructor() {
      this.hasError = false;
    }
    markAsError() {
      return this.hasError = true, this;
    }
  };
  var Rr = class extends He {
    constructor() {
      super(...arguments);
      this.items = [];
    }
    addItem(t) {
      return this.items.push(new tn(t)), this;
    }
    getField(t) {
      return this.items[t];
    }
    getPrintWidth() {
      return this.items.length === 0 ? 2 : Math.max(...this.items.map((n) => n.value.getPrintWidth())) + 2;
    }
    write(t) {
      if (this.items.length === 0) {
        this.writeEmpty(t);
        return;
      }
      this.writeWithItems(t);
    }
    writeEmpty(t) {
      let n = new Ce("[]");
      this.hasError && n.setColor(t.context.colors.red).underline(), t.write(n);
    }
    writeWithItems(t) {
      let { colors: n } = t.context;
      t.writeLine("[").withIndent(() => t.writeJoined(Cr, this.items).newLine()).write("]"), this.hasError && t.afterNextNewline(() => {
        t.writeLine(n.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var Ss = ": ";
  var sn = class {
    constructor(r, t) {
      this.name = r;
      this.value = t;
      this.hasError = false;
    }
    markAsError() {
      this.hasError = true;
    }
    getPrintWidth() {
      return this.name.length + this.value.getPrintWidth() + Ss.length;
    }
    write(r) {
      let t = new Ce(this.name);
      this.hasError && t.underline().setColor(r.context.colors.red), r.write(t).write(Ss).write(this.value);
    }
  };
  var J = class e extends He {
    constructor() {
      super(...arguments);
      this.fields = {};
      this.suggestions = [];
    }
    addField(t) {
      this.fields[t.name] = t;
    }
    addSuggestion(t) {
      this.suggestions.push(t);
    }
    getField(t) {
      return this.fields[t];
    }
    getDeepField(t) {
      let [n, ...i] = t, o = this.getField(n);
      if (!o)
        return;
      let s = o;
      for (let a of i) {
        let l;
        if (s.value instanceof e ? l = s.value.getField(a) : s.value instanceof Rr && (l = s.value.getField(Number(a))), !l)
          return;
        s = l;
      }
      return s;
    }
    getDeepFieldValue(t) {
      return t.length === 0 ? this : this.getDeepField(t)?.value;
    }
    hasField(t) {
      return !!this.getField(t);
    }
    removeAllFields() {
      this.fields = {};
    }
    removeField(t) {
      delete this.fields[t];
    }
    getFields() {
      return this.fields;
    }
    isEmpty() {
      return Object.keys(this.fields).length === 0;
    }
    getFieldValue(t) {
      return this.getField(t)?.value;
    }
    getDeepSubSelectionValue(t) {
      let n = this;
      for (let i of t) {
        if (!(n instanceof e))
          return;
        let o = n.getSubSelectionValue(i);
        if (!o)
          return;
        n = o;
      }
      return n;
    }
    getDeepSelectionParent(t) {
      let n = this.getSelectionParent();
      if (!n)
        return;
      let i = n;
      for (let o of t) {
        let s = i.value.getFieldValue(o);
        if (!s || !(s instanceof e))
          return;
        let a = s.getSelectionParent();
        if (!a)
          return;
        i = a;
      }
      return i;
    }
    getSelectionParent() {
      let t = this.getField("select");
      if (t?.value instanceof e)
        return { kind: "select", value: t.value };
      let n = this.getField("include");
      if (n?.value instanceof e)
        return { kind: "include", value: n.value };
    }
    getSubSelectionValue(t) {
      return this.getSelectionParent()?.value.fields[t].value;
    }
    getPrintWidth() {
      let t = Object.values(this.fields);
      return t.length == 0 ? 2 : Math.max(...t.map((i) => i.getPrintWidth())) + 2;
    }
    write(t) {
      let n = Object.values(this.fields);
      if (n.length === 0 && this.suggestions.length === 0) {
        this.writeEmpty(t);
        return;
      }
      this.writeWithContents(t, n);
    }
    writeEmpty(t) {
      let n = new Ce("{}");
      this.hasError && n.setColor(t.context.colors.red).underline(), t.write(n);
    }
    writeWithContents(t, n) {
      t.writeLine("{").withIndent(() => {
        t.writeJoined(Cr, [...n, ...this.suggestions]).newLine();
      }), t.write("}"), this.hasError && t.afterNextNewline(() => {
        t.writeLine(t.context.colors.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var H = class extends He {
    constructor(t) {
      super();
      this.text = t;
    }
    getPrintWidth() {
      return this.text.length;
    }
    write(t) {
      let n = new Ce(this.text);
      this.hasError && n.underline().setColor(t.context.colors.red), t.write(n);
    }
  };
  var Ri = class {
    constructor(r) {
      this.errorMessages = [];
      this.arguments = r;
    }
    write(r) {
      r.write(this.arguments);
    }
    addErrorMessage(r) {
      this.errorMessages.push(r);
    }
    renderAllMessages(r) {
      return this.errorMessages.map((t) => t(r)).join(`
`);
    }
  };
  var Xc = "P2037";
  var it = "<unknown>";
  var rp = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var tp = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  var ip = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var sp = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var ap = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  var up = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  var pp = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var Si = class {
    getLocation() {
      return null;
    }
  };
  var Ai = class {
    constructor() {
      this._error = new Error;
    }
    getLocation() {
      let r = this._error.stack;
      if (!r)
        return null;
      let n = ks(r).find((i) => {
        if (!i.file)
          return false;
        let o = ii(i.file);
        return o !== "<anonymous>" && !o.includes("@prisma") && !o.includes("/packages/client/src/runtime/") && !o.endsWith("/runtime/binary.js") && !o.endsWith("/runtime/library.js") && !o.endsWith("/runtime/edge.js") && !o.endsWith("/runtime/edge-esm.js") && !o.startsWith("internal/") && !i.methodName.includes("new ") && !i.methodName.includes("getCallSite") && !i.methodName.includes("Proxy.") && i.methodName.split(".").length < 4;
      });
      return !n || !n.file ? null : { fileName: n.file, lineNumber: n.lineNumber, columnNumber: n.column };
    }
  };
  var Ds = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
  var $s = (e) => Array.isArray(e) ? e : e.split(".");
  var Ii = (e, r) => $s(r).reduce((t, n) => t && t[n], e);
  var qs = (e, r, t) => $s(r).reduceRight((n, i, o, s) => Object.assign({}, Ii(e, s.slice(0, o)), { [i]: n }), t);
  var Gs = _(oi());
  var Qs = _(import.meta.require("fs"));
  var Bs = { keyword: _e, entity: _e, value: (e) => W(Ze(e)), punctuation: Ze, directive: _e, function: _e, variable: (e) => W(Ze(e)), string: (e) => W($e(e)), boolean: de, number: _e, comment: Fr };
  var Pp = (e) => e;
  var un = {};
  var vp = 0;
  var P = { manual: un.Prism && un.Prism.manual, disableWorkerMessageHandler: un.Prism && un.Prism.disableWorkerMessageHandler, util: { encode: function(e) {
    if (e instanceof ye) {
      let r = e;
      return new ye(r.type, P.util.encode(r.content), r.alias);
    } else
      return Array.isArray(e) ? e.map(P.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
  }, type: function(e) {
    return Object.prototype.toString.call(e).slice(8, -1);
  }, objId: function(e) {
    return e.__id || Object.defineProperty(e, "__id", { value: ++vp }), e.__id;
  }, clone: function e(r, t) {
    let n, i, o = P.util.type(r);
    switch (t = t || {}, o) {
      case "Object":
        if (i = P.util.objId(r), t[i])
          return t[i];
        n = {}, t[i] = n;
        for (let s in r)
          r.hasOwnProperty(s) && (n[s] = e(r[s], t));
        return n;
      case "Array":
        return i = P.util.objId(r), t[i] ? t[i] : (n = [], t[i] = n, r.forEach(function(s, a) {
          n[a] = e(s, t);
        }), n);
      default:
        return r;
    }
  } }, languages: { extend: function(e, r) {
    let t = P.util.clone(P.languages[e]);
    for (let n in r)
      t[n] = r[n];
    return t;
  }, insertBefore: function(e, r, t, n) {
    n = n || P.languages;
    let i = n[e], o = {};
    for (let a in i)
      if (i.hasOwnProperty(a)) {
        if (a == r)
          for (let l in t)
            t.hasOwnProperty(l) && (o[l] = t[l]);
        t.hasOwnProperty(a) || (o[a] = i[a]);
      }
    let s = n[e];
    return n[e] = o, P.languages.DFS(P.languages, function(a, l) {
      l === s && a != e && (this[a] = o);
    }), o;
  }, DFS: function e(r, t, n, i) {
    i = i || {};
    let o = P.util.objId;
    for (let s in r)
      if (r.hasOwnProperty(s)) {
        t.call(r, s, r[s], n || s);
        let a = r[s], l = P.util.type(a);
        l === "Object" && !i[o(a)] ? (i[o(a)] = true, e(a, t, null, i)) : l === "Array" && !i[o(a)] && (i[o(a)] = true, e(a, t, s, i));
      }
  } }, plugins: {}, highlight: function(e, r, t) {
    let n = { code: e, grammar: r, language: t };
    return P.hooks.run("before-tokenize", n), n.tokens = P.tokenize(n.code, n.grammar), P.hooks.run("after-tokenize", n), ye.stringify(P.util.encode(n.tokens), n.language);
  }, matchGrammar: function(e, r, t, n, i, o, s) {
    for (let h in t) {
      if (!t.hasOwnProperty(h) || !t[h])
        continue;
      if (h == s)
        return;
      let A = t[h];
      A = P.util.type(A) === "Array" ? A : [A];
      for (let T = 0;T < A.length; ++T) {
        let C = A[T], E = C.inside, I = !!C.lookbehind, me = !!C.greedy, le = 0, Nr = C.alias;
        if (me && !C.pattern.global) {
          let U = C.pattern.toString().match(/[imuy]*$/)[0];
          C.pattern = RegExp(C.pattern.source, U + "g");
        }
        C = C.pattern || C;
        for (let U = n, ie = i;U < r.length; ie += r[U].length, ++U) {
          let Ae = r[U];
          if (r.length > e.length)
            return;
          if (Ae instanceof ye)
            continue;
          if (me && U != r.length - 1) {
            C.lastIndex = ie;
            var p = C.exec(e);
            if (!p)
              break;
            var c = p.index + (I ? p[1].length : 0), m = p.index + p[0].length, a = U, l = ie;
            for (let L = r.length;a < L && (l < m || !r[a].type && !r[a - 1].greedy); ++a)
              l += r[a].length, c >= l && (++U, ie = l);
            if (r[U] instanceof ye)
              continue;
            u = a - U, Ae = e.slice(ie, l), p.index -= ie;
          } else {
            C.lastIndex = 0;
            var p = C.exec(Ae), u = 1;
          }
          if (!p) {
            if (o)
              break;
            continue;
          }
          I && (le = p[1] ? p[1].length : 0);
          var c = p.index + le, p = p[0].slice(le), m = c + p.length, f = Ae.slice(0, c), g = Ae.slice(m);
          let Y = [U, u];
          f && (++U, ie += f.length, Y.push(f));
          let pr = new ye(h, E ? P.tokenize(p, E) : p, Nr, p, me);
          if (Y.push(pr), g && Y.push(g), Array.prototype.splice.apply(r, Y), u != 1 && P.matchGrammar(e, r, t, U, ie, true, h), o)
            break;
        }
      }
    }
  }, tokenize: function(e, r) {
    let t = [e], n = r.rest;
    if (n) {
      for (let i in n)
        r[i] = n[i];
      delete r.rest;
    }
    return P.matchGrammar(e, t, r, 0, 0, false), t;
  }, hooks: { all: {}, add: function(e, r) {
    let t = P.hooks.all;
    t[e] = t[e] || [], t[e].push(r);
  }, run: function(e, r) {
    let t = P.hooks.all[e];
    if (!(!t || !t.length))
      for (var n = 0, i;i = t[n++]; )
        i(r);
  } }, Token: ye };
  P.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
  P.languages.javascript = P.languages.extend("clike", { "class-name": [P.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
  P.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  P.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: P.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: P.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: P.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: P.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
  P.languages.markup && P.languages.markup.tag.addInlined("script", "javascript");
  P.languages.js = P.languages.javascript;
  P.languages.typescript = P.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
  P.languages.ts = P.languages.typescript;
  ye.stringify = function(e, r) {
    return typeof e == "string" ? e : Array.isArray(e) ? e.map(function(t) {
      return ye.stringify(t, r);
    }).join("") : Tp(e.type)(e.content);
  };
  var js = _(Ko());
  var cn = class e {
    static read(r) {
      let t;
      try {
        t = Qs.default.readFileSync(r, "utf-8");
      } catch {
        return null;
      }
      return e.fromContent(t);
    }
    static fromContent(r) {
      let t = r.split(/\r?\n/);
      return new e(1, t);
    }
    constructor(r, t) {
      this.firstLineNumber = r, this.lines = t;
    }
    get lastLineNumber() {
      return this.firstLineNumber + this.lines.length - 1;
    }
    mapLineAt(r, t) {
      if (r < this.firstLineNumber || r > this.lines.length + this.firstLineNumber)
        return this;
      let n = r - this.firstLineNumber, i = [...this.lines];
      return i[n] = t(i[n]), new e(this.firstLineNumber, i);
    }
    mapLines(r) {
      return new e(this.firstLineNumber, this.lines.map((t, n) => r(t, this.firstLineNumber + n)));
    }
    lineAt(r) {
      return this.lines[r - this.firstLineNumber];
    }
    prependSymbolAt(r, t) {
      return this.mapLines((n, i) => i === r ? `${t} ${n}` : `  ${n}`);
    }
    slice(r, t) {
      let n = this.lines.slice(r - 1, t).join(`
`);
      return new e(r, Us(n).split(`
`));
    }
    highlight() {
      let r = Vs(this.toString());
      return new e(this.firstLineNumber, r.split(`
`));
    }
    toString() {
      return this.lines.join(`
`);
    }
  };
  var Rp = { red: ce, gray: Fr, dim: Ie, bold: W, underline: ee, highlightSource: (e) => e.highlight() };
  var Sp = { red: (e) => e, gray: (e) => e, dim: (e) => e, bold: (e) => e, underline: (e) => e, highlightSource: (e) => e };
  var Op = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
  var Fp = ["aggregate", "count", "groupBy"];
  var Di = Symbol();
  var ea = (e) => e;
  var mn = class {
    constructor(r, t) {
      this.extension = r;
      this.previous = t;
      this.computedFieldsCache = new xe;
      this.modelExtensionsCache = new xe;
      this.queryCallbacksCache = new xe;
      this.clientExtensions = Wr(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
      this.batchCallbacks = Wr(() => {
        let r2 = this.previous?.getAllBatchQueryCallbacks() ?? [], t2 = this.extension.query?.$__internalBatch;
        return t2 ? r2.concat(t2) : r2;
      });
    }
    getAllComputedFields(r) {
      return this.computedFieldsCache.getOrCreate(r, () => aa(this.previous?.getAllComputedFields(r), this.extension, r));
    }
    getAllClientExtensions() {
      return this.clientExtensions.get();
    }
    getAllModelExtensions(r) {
      return this.modelExtensionsCache.getOrCreate(r, () => {
        let t = Re(r);
        return !this.extension.model || !(this.extension.model[t] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(r) : { ...this.previous?.getAllModelExtensions(r), ...this.extension.model.$allModels, ...this.extension.model[t] };
      });
    }
    getAllQueryCallbacks(r, t) {
      return this.queryCallbacksCache.getOrCreate(`${r}:${t}`, () => {
        let n = this.previous?.getAllQueryCallbacks(r, t) ?? [], i = [], o = this.extension.query;
        return !o || !(o[r] || o.$allModels || o[t] || o.$allOperations) ? n : (o[r] !== undefined && (o[r][t] !== undefined && i.push(o[r][t]), o[r].$allOperations !== undefined && i.push(o[r].$allOperations)), r !== "$none" && o.$allModels !== undefined && (o.$allModels[t] !== undefined && i.push(o.$allModels[t]), o.$allModels.$allOperations !== undefined && i.push(o.$allModels.$allOperations)), o[t] !== undefined && i.push(o[t]), o.$allOperations !== undefined && i.push(o.$allOperations), n.concat(i));
      });
    }
    getAllBatchQueryCallbacks() {
      return this.batchCallbacks.get();
    }
  };
  var dn = class e {
    constructor(r) {
      this.head = r;
    }
    static empty() {
      return new e;
    }
    static single(r) {
      return new e(new mn(r));
    }
    isEmpty() {
      return this.head === undefined;
    }
    append(r) {
      return new e(new mn(r, this.head));
    }
    getAllComputedFields(r) {
      return this.head?.getAllComputedFields(r);
    }
    getAllClientExtensions() {
      return this.head?.getAllClientExtensions();
    }
    getAllModelExtensions(r) {
      return this.head?.getAllModelExtensions(r);
    }
    getAllQueryCallbacks(r, t) {
      return this.head?.getAllQueryCallbacks(r, t) ?? [];
    }
    getAllBatchQueryCallbacks() {
      return this.head?.getAllBatchQueryCallbacks() ?? [];
    }
  };
  var ua = N("prisma:client");
  var ca = { Vercel: "vercel", "Netlify CI": "netlify" };
  var Jp = "Cloudflare-Workers";
  var Hp = "node";
  var Wp = { node: "Node.js", workerd: "Cloudflare Workers", deno: "Deno and Deno Deploy", netlify: "Netlify Edge Functions", "edge-light": "Vercel Edge Functions or Edge Middleware" };
  var Ea = _(import.meta.require("fs"));
  var at = _(import.meta.require("path"));
  var zp = N("prisma:client:engines:resolveEnginePath");
  var Yp = () => new RegExp("runtime[\\\\/]library\\.m?js$");
  var Li = _(ui());
  var va = _(is());
  var En = class extends Error {
    constructor(r, t) {
      super(r), this.clientVersion = t.clientVersion, this.cause = t.cause;
    }
    get [Symbol.toStringTag]() {
      return this.name;
    }
  };
  var ae = class extends En {
    constructor(r, t) {
      super(r, t), this.isRetryable = t.isRetryable ?? true;
    }
  };
  var _r = class extends ae {
    constructor(t) {
      super("This request must be retried", S(t, true));
      this.name = "ForcedRetryError";
      this.code = "P5001";
    }
  };
  w(_r, "ForcedRetryError");
  var ar = class extends ae {
    constructor(t, n) {
      super(t, S(n, false));
      this.name = "InvalidDatasourceError";
      this.code = "P6001";
    }
  };
  w(ar, "InvalidDatasourceError");
  var lr = class extends ae {
    constructor(t, n) {
      super(t, S(n, false));
      this.name = "NotImplementedYetError";
      this.code = "P5004";
    }
  };
  w(lr, "NotImplementedYetError");
  var $ = class extends ae {
    constructor(r, t) {
      super(r, t), this.response = t.response;
      let n = this.response.headers.get("prisma-request-id");
      if (n) {
        let i = `(The request id was: ${n})`;
        this.message = this.message + " " + i;
      }
    }
  };
  var ur = class extends $ {
    constructor(t) {
      super("Schema needs to be uploaded", S(t, true));
      this.name = "SchemaMissingError";
      this.code = "P5005";
    }
  };
  w(ur, "SchemaMissingError");
  var Ni = "This request could not be understood by the server";
  var lt = class extends $ {
    constructor(t, n, i) {
      super(n || Ni, S(t, false));
      this.name = "BadRequestError";
      this.code = "P5000";
      i && (this.code = i);
    }
  };
  w(lt, "BadRequestError");
  var ut = class extends $ {
    constructor(t, n) {
      super("Engine not started: healthcheck timeout", S(t, true));
      this.name = "HealthcheckTimeoutError";
      this.code = "P5013";
      this.logs = n;
    }
  };
  w(ut, "HealthcheckTimeoutError");
  var ct = class extends $ {
    constructor(t, n, i) {
      super(n, S(t, true));
      this.name = "EngineStartupError";
      this.code = "P5014";
      this.logs = i;
    }
  };
  w(ct, "EngineStartupError");
  var pt = class extends $ {
    constructor(t) {
      super("Engine version is not supported", S(t, false));
      this.name = "EngineVersionNotSupportedError";
      this.code = "P5012";
    }
  };
  w(pt, "EngineVersionNotSupportedError");
  var Oi = "Request timed out";
  var mt = class extends $ {
    constructor(t, n = Oi) {
      super(n, S(t, false));
      this.name = "GatewayTimeoutError";
      this.code = "P5009";
    }
  };
  w(mt, "GatewayTimeoutError");
  var Xp = "Interactive transaction error";
  var dt = class extends $ {
    constructor(t, n = Xp) {
      super(n, S(t, false));
      this.name = "InteractiveTransactionError";
      this.code = "P5015";
    }
  };
  w(dt, "InteractiveTransactionError");
  var em = "Request parameters are invalid";
  var ft = class extends $ {
    constructor(t, n = em) {
      super(n, S(t, false));
      this.name = "InvalidRequestError";
      this.code = "P5011";
    }
  };
  w(ft, "InvalidRequestError");
  var Fi = "Requested resource does not exist";
  var gt = class extends $ {
    constructor(t, n = Fi) {
      super(n, S(t, false));
      this.name = "NotFoundError";
      this.code = "P5003";
    }
  };
  w(gt, "NotFoundError");
  var Mi = "Unknown server error";
  var kr = class extends $ {
    constructor(t, n, i) {
      super(n || Mi, S(t, true));
      this.name = "ServerError";
      this.code = "P5006";
      this.logs = i;
    }
  };
  w(kr, "ServerError");
  var $i = "Unauthorized, check your connection string";
  var ht = class extends $ {
    constructor(t, n = $i) {
      super(n, S(t, false));
      this.name = "UnauthorizedError";
      this.code = "P5007";
    }
  };
  w(ht, "UnauthorizedError");
  var qi = "Usage exceeded, retry again later";
  var yt = class extends $ {
    constructor(t, n = qi) {
      super(n, S(t, true));
      this.name = "UsageExceededError";
      this.code = "P5008";
    }
  };
  w(yt, "UsageExceededError");
  var Fe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var _a = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "5.11.0-15.efd2449663b3d73d637ea1fd226bafbcf45b3102", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*" };
  var bt = class extends ae {
    constructor(t, n) {
      super(`Cannot fetch data from service:
${t}`, S(n, true));
      this.name = "RequestError";
      this.code = "P5010";
    }
  };
  w(bt, "RequestError");
  var am = typeof import.meta.require < "u" ? import.meta.require : () => {
  };
  var Vi = class {
    constructor(r = {}) {
      this.headers = new Map;
      for (let [t, n] of Object.entries(r))
        if (typeof n == "string")
          this.headers.set(t, n);
        else if (Array.isArray(n))
          for (let i of n)
            this.headers.set(t, i);
    }
    append(r, t) {
      this.headers.set(r, t);
    }
    delete(r) {
      this.headers.delete(r);
    }
    get(r) {
      return this.headers.get(r) ?? null;
    }
    has(r) {
      return this.headers.has(r);
    }
    set(r, t) {
      this.headers.set(r, t);
    }
    forEach(r, t) {
      for (let [n, i] of this.headers)
        r.call(t, i, n, this);
    }
  };
  var lm = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
  var ka = N("prisma:client:dataproxyEngine");
  var La = 3;
  var ji = N("prisma:client:dataproxyEngine");
  var Ui = class {
    constructor({ apiKey: r, tracingHelper: t, logLevel: n, logQueries: i, engineHash: o }) {
      this.apiKey = r, this.tracingHelper = t, this.logLevel = n, this.logQueries = i, this.engineHash = o;
    }
    build({ traceparent: r, interactiveTransaction: t } = {}) {
      let n = { Authorization: `Bearer ${this.apiKey}`, "Prisma-Engine-Hash": this.engineHash };
      this.tracingHelper.isEnabled() && (n.traceparent = r ?? this.tracingHelper.getTraceParent()), t && (n["X-transaction-id"] = t.id);
      let i = this.buildCaptureSettings();
      return i.length > 0 && (n["X-capture-telemetry"] = i.join(", ")), n;
    }
    buildCaptureSettings() {
      let r = [];
      return this.tracingHelper.isEnabled() && r.push("tracing"), this.logLevel && r.push(this.logLevel), this.logQueries && r.push("query"), r;
    }
  };
  var wt = class {
    constructor(r) {
      this.name = "DataProxyEngine";
      Aa(r), this.config = r, this.env = { ...r.env, ...typeof process < "u" ? process.env : {} }, this.inlineSchema = Sa(r.inlineSchema), this.inlineDatasources = r.inlineDatasources, this.inlineSchemaHash = r.inlineSchemaHash, this.clientVersion = r.clientVersion, this.engineHash = r.engineVersion, this.logEmitter = r.logEmitter, this.tracingHelper = r.tracingHelper;
    }
    apiKey() {
      return this.headerBuilder.apiKey;
    }
    version() {
      return this.engineHash;
    }
    async start() {
      this.startPromise !== undefined && await this.startPromise, this.startPromise = (async () => {
        let [r, t] = this.extractHostAndApiKey();
        this.host = r, this.headerBuilder = new Ui({ apiKey: t, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries, engineHash: this.engineHash }), this.remoteClientVersion = await Da(r, this.config), ji("host", this.host);
      })(), await this.startPromise;
    }
    async stop() {
    }
    propagateResponseExtensions(r) {
      r?.logs?.length && r.logs.forEach((t) => {
        switch (t.level) {
          case "debug":
          case "error":
          case "trace":
          case "warn":
          case "info":
            break;
          case "query": {
            let n = typeof t.attributes.query == "string" ? t.attributes.query : "";
            if (!this.tracingHelper.isEnabled()) {
              let [i] = n.split("/* traceparent");
              n = i;
            }
            this.logEmitter.emit("query", { query: n, timestamp: Ia(t.timestamp), duration: Number(t.attributes.duration_ms), params: t.attributes.params, target: t.attributes.target });
          }
        }
      }), r?.traces?.length && this.tracingHelper.createEngineSpan({ span: true, spans: r.traces });
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the remote query engine');
    }
    async url(r) {
      return await this.start(), `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`;
    }
    async uploadSchema() {
      let r = { name: "schemaUpload", internal: true };
      return this.tracingHelper.runInChildSpan(r, async () => {
        let t = await cr(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
        t.ok || ji("schema response status", t.status);
        let n = await Et(t, this.clientVersion);
        if (n)
          throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${n.message}`, timestamp: new Date, target: "" }), n;
        this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`, timestamp: new Date, target: "" });
      });
    }
    request(r, { traceparent: t, interactiveTransaction: n, customDataProxyFetch: i }) {
      return this.requestInternal({ body: r, traceparent: t, interactiveTransaction: n, customDataProxyFetch: i });
    }
    async requestBatch(r, { traceparent: t, transaction: n, customDataProxyFetch: i }) {
      let o = n?.kind === "itx" ? n.options : undefined, s = Er(r, n), { batchResult: a, elapsed: l } = await this.requestInternal({ body: s, customDataProxyFetch: i, interactiveTransaction: o, traceparent: t });
      return a.map((u) => ("errors" in u) && u.errors.length > 0 ? sr(u.errors[0], this.clientVersion, this.config.activeProvider) : { data: u, elapsed: l });
    }
    requestInternal({ body: r, traceparent: t, customDataProxyFetch: n, interactiveTransaction: i }) {
      return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: o }) => {
        let s = i ? `${i.payload.endpoint}/graphql` : await this.url("graphql");
        o(s);
        let a = await cr(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: t, interactiveTransaction: i }), body: JSON.stringify(r), clientVersion: this.clientVersion }, n);
        a.ok || ji("graphql response status", a.status), await this.handleError(await Et(a, this.clientVersion));
        let l = await a.json(), u = l.extensions;
        if (u && this.propagateResponseExtensions(u), l.errors)
          throw l.errors.length === 1 ? sr(l.errors[0], this.config.clientVersion, this.config.activeProvider) : new j(l.errors, { clientVersion: this.config.clientVersion });
        return l;
      } });
    }
    async transaction(r, t, n) {
      let i = { start: "starting", commit: "committing", rollback: "rolling back" };
      return this.withRetry({ actionGerund: `${i[r]} transaction`, callback: async ({ logHttpCall: o }) => {
        if (r === "start") {
          let s = JSON.stringify({ max_wait: n.maxWait, timeout: n.timeout, isolation_level: n.isolationLevel }), a = await this.url("transaction/start");
          o(a);
          let l = await cr(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: t.traceparent }), body: s, clientVersion: this.clientVersion });
          await this.handleError(await Et(l, this.clientVersion));
          let u = await l.json(), c = u.extensions;
          c && this.propagateResponseExtensions(c);
          let p = u.id, m = u["data-proxy"].endpoint;
          return { id: p, payload: { endpoint: m } };
        } else {
          let s = `${n.payload.endpoint}/${r}`;
          o(s);
          let a = await cr(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: t.traceparent }), clientVersion: this.clientVersion });
          await this.handleError(await Et(a, this.clientVersion));
          let u = (await a.json()).extensions;
          u && this.propagateResponseExtensions(u);
          return;
        }
      } });
    }
    extractHostAndApiKey() {
      let r = { clientVersion: this.clientVersion }, t = Object.keys(this.inlineDatasources)[0], n = Ir({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), i;
      try {
        i = new URL(n);
      } catch {
        throw new ar(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\``, r);
      }
      let { protocol: o, host: s, searchParams: a } = i;
      if (o !== "prisma:")
        throw new ar(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\``, r);
      let l = a.get("api_key");
      if (l === null || l.length < 1)
        throw new ar(`Error validating datasource \`${t}\`: the URL must contain a valid API key`, r);
      return [s, l];
    }
    metrics() {
      throw new lr("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
    }
    async withRetry(r) {
      for (let t = 0;; t++) {
        let n = (i) => {
          this.logEmitter.emit("info", { message: `Calling ${i} (n=${t})`, timestamp: new Date, target: "" });
        };
        try {
          return await r.callback({ logHttpCall: n });
        } catch (i) {
          if (!(i instanceof ae) || !i.isRetryable)
            throw i;
          if (t >= La)
            throw i instanceof _r ? i.cause : i;
          this.logEmitter.emit("warn", { message: `Attempt ${t + 1}/${La} failed for ${r.actionGerund}: ${i.message ?? "(unknown)"}`, timestamp: new Date, target: "" });
          let o = await Ra(t);
          this.logEmitter.emit("warn", { message: `Retrying after ${o}ms`, timestamp: new Date, target: "" });
        }
      }
    }
    async handleError(r) {
      if (r instanceof ur)
        throw await this.uploadSchema(), new _r({ clientVersion: this.clientVersion, cause: r });
      if (r)
        throw r;
    }
  };
  var Gi = _(import.meta.require("os"));
  var Oa = _(import.meta.require("path"));
  var Qi = Symbol("PrismaLibraryEngineCache");
  var Fa = { async loadLibrary(e) {
    let r = await jn(), t = await ba("library", e);
    try {
      return e.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => mm(t));
    } catch (n) {
      let i = ni({ e: n, platformInfo: r, id: t });
      throw new R(i, e.clientVersion);
    }
  } };
  var Ji;
  var Ma = { async loadLibrary(e) {
    let { clientVersion: r, adapter: t, engineWasm: n } = e;
    if (t === undefined)
      throw new R(`The \`adapter\` option for \`PrismaClient\` is required in this context (${fn().prettyName})`, r);
    if (n === undefined)
      throw new R("WASM engine was unexpectedly `undefined`", r);
    Ji === undefined && (Ji = (async () => {
      let o = n.getRuntime(), s = await n.getQueryEngineWasmModule();
      if (s == null)
        throw new R("The loaded wasm module was unexpectedly `undefined` or `null` once loaded", r);
      let a = { "./query_engine_bg.js": o }, l = new WebAssembly.Instance(s, a);
      return o.__wbg_set_wasm(l.exports), o.QueryEngine;
    })());
    let i = await Ji;
    return { debugPanic() {
      return Promise.reject("{}");
    }, dmmf() {
      return Promise.resolve("{}");
    }, version() {
      return { commit: "unknown", version: "unknown" };
    }, QueryEngine: i };
  } };
  var dm = "P2036";
  var Se = N("prisma:client:libraryEngine");
  var $a = [...Mn, "native"];
  var qa = 0;
  var xt = class {
    constructor(r, t) {
      this.name = "LibraryEngine";
      this.libraryLoader = t ?? Fa, r.engineWasm !== undefined && (this.libraryLoader = t ?? Ma), this.config = r, this.libraryStarted = false, this.logQueries = r.logQueries ?? false, this.logLevel = r.logLevel ?? "error", this.logEmitter = r.logEmitter, this.datamodel = r.inlineSchema, r.enableDebugLogs && (this.logLevel = "debug");
      let n = Object.keys(r.overrideDatasources)[0], i = r.overrideDatasources[n]?.url;
      n !== undefined && i !== undefined && (this.datasourceOverrides = { [n]: i }), this.libraryInstantiationPromise = this.instantiateLibrary(), this.checkForTooManyEngines();
    }
    checkForTooManyEngines() {
      qa === 10 && console.warn(`${de("warn(prisma-client)")} This is the 10th instance of Prisma Client being started. Make sure this is intentional.`);
    }
    async transaction(r, t, n) {
      await this.start();
      let i = JSON.stringify(t), o;
      if (r === "start") {
        let a = JSON.stringify({ max_wait: n.maxWait, timeout: n.timeout, isolation_level: n.isolationLevel });
        o = await this.engine?.startTransaction(a, i);
      } else
        r === "commit" ? o = await this.engine?.commitTransaction(n.id, i) : r === "rollback" && (o = await this.engine?.rollbackTransaction(n.id, i));
      let s = this.parseEngineResponse(o);
      if (hm(s)) {
        let a = this.getExternalAdapterError(s);
        throw a ? a.error : new V(s.message, { code: s.error_code, clientVersion: this.config.clientVersion, meta: s.meta });
      }
      return s;
    }
    async instantiateLibrary() {
      if (Se("internalSetup"), this.libraryInstantiationPromise)
        return this.libraryInstantiationPromise;
      Fn(), this.binaryTarget = await this.getCurrentBinaryTarget(), await this.loadEngine(), this.version();
    }
    async getCurrentBinaryTarget() {
      {
        if (this.binaryTarget)
          return this.binaryTarget;
        let r = await rr();
        if (!$a.includes(r))
          throw new R(`Unknown ${ce("PRISMA_QUERY_ENGINE_LIBRARY")} ${ce(W(r))}. Possible binaryTargets: ${$e($a.join(", "))} or a path to the query engine library.
You may have to run ${$e("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
        return r;
      }
    }
    parseEngineResponse(r) {
      if (!r)
        throw new j("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
      try {
        return JSON.parse(r);
      } catch {
        throw new j("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
      }
    }
    async loadEngine() {
      if (!this.engine) {
        this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(this.config), this.QueryEngineConstructor = this.library.QueryEngine);
        try {
          let r = new WeakRef(this), { adapter: t } = this.config;
          t && Se("Using driver adapter: %O", t), this.engine = new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json" }, (n) => {
            r.deref()?.logger(n);
          }, t), qa++;
        } catch (r) {
          let t = r, n = this.parseInitError(t.message);
          throw typeof n == "string" ? t : new R(n.message, this.config.clientVersion, n.error_code);
        }
      }
    }
    logger(r) {
      let t = this.parseEngineResponse(r);
      if (t) {
        if ("span" in t) {
          this.config.tracingHelper.createEngineSpan(t);
          return;
        }
        t.level = t?.level.toLowerCase() ?? "unknown", fm(t) ? this.logEmitter.emit("query", { timestamp: new Date, query: t.query, params: t.params, duration: Number(t.duration_ms), target: t.module_path }) : gm(t) ? this.loggerRustPanic = new ue(Hi(this, `${t.message}: ${t.reason} in ${t.file}:${t.line}:${t.column}`), this.config.clientVersion) : this.logEmitter.emit(t.level, { timestamp: new Date, message: t.message, target: t.module_path });
      }
    }
    parseInitError(r) {
      try {
        return JSON.parse(r);
      } catch {
      }
      return r;
    }
    parseRequestError(r) {
      try {
        return JSON.parse(r);
      } catch {
      }
      return r;
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
    }
    async start() {
      if (await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise)
        return Se(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
      if (this.libraryStarted)
        return;
      let r = async () => {
        Se("library starting");
        try {
          let t = { traceparent: this.config.tracingHelper.getTraceParent() };
          await this.engine?.connect(JSON.stringify(t)), this.libraryStarted = true, Se("library started");
        } catch (t) {
          let n = this.parseInitError(t.message);
          throw typeof n == "string" ? t : new R(n.message, this.config.clientVersion, n.error_code);
        } finally {
          this.libraryStartingPromise = undefined;
        }
      };
      return this.libraryStartingPromise = this.config.tracingHelper.runInChildSpan("connect", r), this.libraryStartingPromise;
    }
    async stop() {
      if (await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise)
        return Se("library is already stopping"), this.libraryStoppingPromise;
      if (!this.libraryStarted)
        return;
      let r = async () => {
        await new Promise((n) => setTimeout(n, 5)), Se("library stopping");
        let t = { traceparent: this.config.tracingHelper.getTraceParent() };
        await this.engine?.disconnect(JSON.stringify(t)), this.libraryStarted = false, this.libraryStoppingPromise = undefined, Se("library stopped");
      };
      return this.libraryStoppingPromise = this.config.tracingHelper.runInChildSpan("disconnect", r), this.libraryStoppingPromise;
    }
    version() {
      return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
    }
    debugPanic(r) {
      return this.library?.debugPanic(r);
    }
    async request(r, { traceparent: t, interactiveTransaction: n }) {
      Se(`sending request, this.libraryStarted: ${this.libraryStarted}`);
      let i = JSON.stringify({ traceparent: t }), o = JSON.stringify(r);
      try {
        await this.start(), this.executingQueryPromise = this.engine?.query(o, i, n?.id), this.lastQuery = o;
        let s = this.parseEngineResponse(await this.executingQueryPromise);
        if (s.errors)
          throw s.errors.length === 1 ? this.buildQueryError(s.errors[0]) : new j(JSON.stringify(s.errors), { clientVersion: this.config.clientVersion });
        if (this.loggerRustPanic)
          throw this.loggerRustPanic;
        return { data: s, elapsed: 0 };
      } catch (s) {
        if (s instanceof R)
          throw s;
        if (s.code === "GenericFailure" && s.message?.startsWith("PANIC:"))
          throw new ue(Hi(this, s.message), this.config.clientVersion);
        let a = this.parseRequestError(s.message);
        throw typeof a == "string" ? s : new j(`${a.message}
${a.backtrace}`, { clientVersion: this.config.clientVersion });
      }
    }
    async requestBatch(r, { transaction: t, traceparent: n }) {
      Se("requestBatch");
      let i = Er(r, t);
      await this.start(), this.lastQuery = JSON.stringify(i), this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify({ traceparent: n }), Na(t));
      let o = await this.executingQueryPromise, s = this.parseEngineResponse(o);
      if (s.errors)
        throw s.errors.length === 1 ? this.buildQueryError(s.errors[0]) : new j(JSON.stringify(s.errors), { clientVersion: this.config.clientVersion });
      let { batchResult: a, errors: l } = s;
      if (Array.isArray(a))
        return a.map((u) => u.errors && u.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(u.errors[0]) : { data: u, elapsed: 0 });
      throw l && l.length === 1 ? new Error(l[0].error) : new Error(JSON.stringify(s));
    }
    buildQueryError(r) {
      if (r.user_facing_error.is_panic)
        return new ue(Hi(this, r.user_facing_error.message), this.config.clientVersion);
      let t = this.getExternalAdapterError(r.user_facing_error);
      return t ? t.error : sr(r, this.config.clientVersion, this.config.activeProvider);
    }
    getExternalAdapterError(r) {
      if (r.error_code === dm && this.config.adapter) {
        let t = r.meta?.id;
        Vt(typeof t == "number", "Malformed external JS error received from the engine");
        let n = this.config.adapter.errorRegistry.consumeError(t);
        return Vt(n, "External error with reported id was not registered"), n;
      }
    }
    async metrics(r) {
      await this.start();
      let t = await this.engine.metrics(JSON.stringify(r));
      return r.format === "prometheus" ? t : this.parseEngineResponse(t);
    }
  };
  var Ja = _(Wi());
  var Me = class {
    constructor(r, t) {
      this.name = r;
      this.value = t;
      this.isRequired = false;
    }
    makeRequired() {
      return this.isRequired = true, this;
    }
    write(r) {
      let { colors: { green: t } } = r.context;
      r.addMarginSymbol(t(this.isRequired ? "+" : "?")), r.write(t(this.name)), this.isRequired || r.write(t("?")), r.write(t(": ")), typeof this.value == "string" ? r.write(t(this.value)) : r.write(this.value);
    }
  };
  var xn = class {
    constructor() {
      this.fields = [];
    }
    addField(r, t) {
      return this.fields.push({ write(n) {
        let { green: i, dim: o } = n.context.colors;
        n.write(i(o(`${r}: ${t}`))).addMarginSymbol(i(o("+")));
      } }), this;
    }
    write(r) {
      let { colors: { green: t } } = r.context;
      r.writeLine(t("{")).withIndent(() => {
        r.writeJoined(Cr, this.fields).newLine();
      }).write(t("}")).addMarginSymbol(t("+"));
    }
  };
  var Lm = 3;
  var Om = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", update: "updateOne", updateMany: "updateMany", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
  var Ki = class e {
    constructor(r) {
      this.params = r;
      this.params.modelName && (this.model = this.params.runtimeDataModel.models[this.params.modelName]);
    }
    throwValidationError(r) {
      Tn({ errors: [r], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion });
    }
    getSelectionPath() {
      return this.params.selectionPath;
    }
    getArgumentPath() {
      return this.params.argumentPath;
    }
    getArgumentName() {
      return this.params.argumentPath[this.params.argumentPath.length - 1];
    }
    getOutputTypeDescription() {
      if (!(!this.params.modelName || !this.model))
        return { name: this.params.modelName, fields: this.model.fields.map((r) => ({ name: r.name, typeName: "boolean", isRelation: r.kind === "object" })) };
    }
    isRawAction() {
      return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
    }
    getComputedFields() {
      if (this.params.modelName)
        return this.params.extensions.getAllComputedFields(this.params.modelName);
    }
    findField(r) {
      return this.model?.fields.find((t) => t.name === r);
    }
    nestSelection(r) {
      let t = this.findField(r), n = t?.kind === "object" ? t.type : undefined;
      return new e({ ...this.params, modelName: n, selectionPath: this.params.selectionPath.concat(r) });
    }
    nestArgument(r) {
      return new e({ ...this.params, argumentPath: this.params.argumentPath.concat(r) });
    }
  };
  var el = (e) => ({ command: e });
  var rl = (e) => e.strings.reduce((r, t, n) => `${r}@P${n}${t}`);
  var Gm = /^(\s*alter\s)/i;
  var ol = N("prisma:client");
  var Zi = ({ clientMethod: e, activeProvider: r }) => (t) => {
    let n = "", i;
    if (Array.isArray(t)) {
      let [o, ...s] = t;
      n = o, i = { values: vt(s || []), __prismaRawParameters__: true };
    } else
      switch (r) {
        case "sqlite":
        case "mysql": {
          n = t.sql, i = { values: vt(t.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          n = t.text, i = { values: vt(t.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          n = rl(t), i = { values: vt(t.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${r} provider does not support ${e}`);
      }
    return i?.values ? ol(`prisma.${e}(${n}, ${i.values})`) : ol(`prisma.${e}(${n})`), { query: n, parameters: i };
  };
  var sl = { requestArgsToMiddlewareArgs(e) {
    return [e.strings, ...e.values];
  }, middlewareArgsToRequestArgs(e) {
    let [r, ...t] = e;
    return new oe(r, t);
  } };
  var al = { requestArgsToMiddlewareArgs(e) {
    return [e];
  }, middlewareArgsToRequestArgs(e) {
    return e[0];
  } };
  var ul = { isEnabled() {
    return false;
  }, getTraceParent() {
    return "00-10-10-00";
  }, async createEngineSpan() {
  }, getActiveContext() {
  }, runInChildSpan(e, r) {
    return r();
  } };
  var eo = class {
    isEnabled() {
      return this.getGlobalTracingHelper().isEnabled();
    }
    getTraceParent(r) {
      return this.getGlobalTracingHelper().getTraceParent(r);
    }
    createEngineSpan(r) {
      return this.getGlobalTracingHelper().createEngineSpan(r);
    }
    getActiveContext() {
      return this.getGlobalTracingHelper().getActiveContext();
    }
    runInChildSpan(r, t) {
      return this.getGlobalTracingHelper().runInChildSpan(r, t);
    }
    getGlobalTracingHelper() {
      return globalThis.PRISMA_INSTRUMENTATION?.helper ?? ul;
    }
  };
  var Jm = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
  var ml = Jm;
  var Cn = class {
    constructor() {
      this._middlewares = [];
    }
    use(r) {
      this._middlewares.push(r);
    }
    get(r) {
      return this._middlewares[r];
    }
    has(r) {
      return !!this._middlewares[r];
    }
    length() {
      return this._middlewares.length;
    }
  };
  var gl = _(ui());
  var Km = { aggregate: false, aggregateRaw: false, createMany: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateOne: true, upsertOne: true };
  var An = class {
    constructor(r) {
      this.options = r;
      this.tickActive = false;
      this.batches = {};
    }
    request(r) {
      let t = this.options.batchBy(r);
      return t ? (this.batches[t] || (this.batches[t] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
        this.dispatchBatches(), this.tickActive = false;
      }))), new Promise((n, i) => {
        this.batches[t].push({ request: r, resolve: n, reject: i });
      })) : this.options.singleLoader(r);
    }
    dispatchBatches() {
      for (let r in this.batches) {
        let t = this.batches[r];
        delete this.batches[r], t.length === 1 ? this.options.singleLoader(t[0].request).then((n) => {
          n instanceof Error ? t[0].reject(n) : t[0].resolve(n);
        }).catch((n) => {
          t[0].reject(n);
        }) : (t.sort((n, i) => this.options.batchOrder(n.request, i.request)), this.options.batchLoader(t.map((n) => n.request)).then((n) => {
          if (n instanceof Error)
            for (let i = 0;i < t.length; i++)
              t[i].reject(n);
          else
            for (let i = 0;i < t.length; i++) {
              let o = n[i];
              o instanceof Error ? t[i].reject(o) : t[i].resolve(o);
            }
        }).catch((n) => {
          for (let i = 0;i < t.length; i++)
            t[i].reject(n);
        }));
      }
    }
    get [Symbol.toStringTag]() {
      return "DataLoader";
    }
  };
  var zm = N("prisma:client:request_handler");
  var In = class {
    constructor(r, t) {
      this.logEmitter = t, this.client = r, this.dataloader = new An({ batchLoader: na(async ({ requests: n, customDataProxyFetch: i }) => {
        let { transaction: o, otelParentCtx: s } = n[0], a = n.map((p) => p.protocolQuery), l = this.client._tracingHelper.getTraceParent(s), u = n.some((p) => to(p.protocolQuery.action));
        return (await this.client._engine.requestBatch(a, { traceparent: l, transaction: Ym(o), containsWrite: u, customDataProxyFetch: i })).map((p, m) => {
          if (p instanceof Error)
            return p;
          try {
            return this.mapQueryEngineResult(n[m], p);
          } catch (f) {
            return f;
          }
        });
      }), singleLoader: async (n) => {
        let i = n.transaction?.kind === "itx" ? hl(n.transaction) : undefined, o = await this.client._engine.request(n.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i, isWrite: to(n.protocolQuery.action), customDataProxyFetch: n.customDataProxyFetch });
        return this.mapQueryEngineResult(n, o);
      }, batchBy: (n) => n.transaction?.id ? `transaction-${n.transaction.id}` : fl(n.protocolQuery), batchOrder(n, i) {
        return n.transaction?.kind === "batch" && i.transaction?.kind === "batch" ? n.transaction.index - i.transaction.index : 0;
      } });
    }
    async request(r) {
      try {
        return await this.dataloader.request(r);
      } catch (t) {
        let { clientMethod: n, callsite: i, transaction: o, args: s, modelName: a } = r;
        this.handleAndLogRequestError({ error: t, clientMethod: n, callsite: i, transaction: o, args: s, modelName: a });
      }
    }
    mapQueryEngineResult({ dataPath: r, unpacker: t }, n) {
      let i = n?.data, o = n?.elapsed, s = this.unpack(i, r, t);
      return process.env.PRISMA_CLIENT_GET_TIME ? { data: s, elapsed: o } : s;
    }
    handleAndLogRequestError(r) {
      try {
        this.handleRequestError(r);
      } catch (t) {
        throw this.logEmitter && this.logEmitter.emit("error", { message: t.message, target: r.clientMethod, timestamp: new Date }), t;
      }
    }
    handleRequestError({ error: r, clientMethod: t, callsite: n, transaction: i, args: o, modelName: s }) {
      if (zm(r), Zm(r, i) || r instanceof Le)
        throw r;
      if (r instanceof V && Xm(r)) {
        let l = yl(r.meta);
        Tn({ args: o, errors: [l], callsite: n, errorFormat: this.client._errorFormat, originalMethod: t, clientVersion: this.client._clientVersion });
      }
      let a = r.message;
      if (n && (a = Ar({ callsite: n, originalMethod: t, isPanic: r.isPanic, showColors: this.client._errorFormat === "pretty", message: a })), a = this.sanitizeMessage(a), r.code) {
        let l = s ? { modelName: s, ...r.meta } : r.meta;
        throw new V(a, { code: r.code, clientVersion: this.client._clientVersion, meta: l, batchRequestIdx: r.batchRequestIdx });
      } else {
        if (r.isPanic)
          throw new ue(a, this.client._clientVersion);
        if (r instanceof j)
          throw new j(a, { clientVersion: this.client._clientVersion, batchRequestIdx: r.batchRequestIdx });
        if (r instanceof R)
          throw new R(a, this.client._clientVersion);
        if (r instanceof ue)
          throw new ue(a, this.client._clientVersion);
      }
      throw r.clientVersion = this.client._clientVersion, r;
    }
    sanitizeMessage(r) {
      return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, gl.default)(r) : r;
    }
    unpack(r, t, n) {
      if (!r || (r.data && (r = r.data), !r))
        return r;
      let i = Object.values(r)[0], o = t.filter((a) => a !== "select" && a !== "include"), s = Sn(Ii(i, o));
      return n ? n(s) : s;
    }
    get [Symbol.toStringTag]() {
      return "RequestHandler";
    }
  };
  var El = "5.11.0";
  var bl = El;
  var Cl = _(Wi());
  var q = class extends Error {
    constructor(r) {
      super(r + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientConstructorValidationError";
    }
  };
  w(q, "PrismaClientConstructorValidationError");
  var Pl = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "transactionOptions", "__internal"];
  var vl = ["pretty", "colorless", "minimal"];
  var Tl = ["info", "query", "warn", "error"];
  var rd = { datasources: (e, { datasourceNames: r }) => {
    if (e) {
      if (typeof e != "object" || Array.isArray(e))
        throw new q(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);
      for (let [t, n] of Object.entries(e)) {
        if (!r.includes(t)) {
          let i = Lr(t, r) || ` Available datasources: ${r.join(", ")}`;
          throw new q(`Unknown datasource ${t} provided to PrismaClient constructor.${i}`);
        }
        if (typeof n != "object" || Array.isArray(n))
          throw new q(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
        if (n && typeof n == "object")
          for (let [i, o] of Object.entries(n)) {
            if (i !== "url")
              throw new q(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof o != "string")
              throw new q(`Invalid value ${JSON.stringify(o)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
      }
    }
  }, adapter: (e, r) => {
    if (e === null)
      return;
    if (e === undefined)
      throw new q('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
    if (!bn(r).includes("driverAdapters"))
      throw new q('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
    if (Ur() === "binary")
      throw new q('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.');
  }, datasourceUrl: (e) => {
    if (typeof e < "u" && typeof e != "string")
      throw new q(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
  }, errorFormat: (e) => {
    if (e) {
      if (typeof e != "string")
        throw new q(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);
      if (!vl.includes(e)) {
        let r = Lr(e, vl);
        throw new q(`Invalid errorFormat ${e} provided to PrismaClient constructor.${r}`);
      }
    }
  }, log: (e) => {
    if (!e)
      return;
    if (!Array.isArray(e))
      throw new q(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);
    function r(t) {
      if (typeof t == "string" && !Tl.includes(t)) {
        let n = Lr(t, Tl);
        throw new q(`Invalid log level "${t}" provided to PrismaClient constructor.${n}`);
      }
    }
    for (let t of e) {
      r(t);
      let n = { level: r, emit: (i) => {
        let o = ["stdout", "event"];
        if (!o.includes(i)) {
          let s = Lr(i, o);
          throw new q(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`);
        }
      } };
      if (t && typeof t == "object")
        for (let [i, o] of Object.entries(t))
          if (n[i])
            n[i](o);
          else
            throw new q(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
    }
  }, transactionOptions: (e) => {
    if (!e)
      return;
    let r = e.maxWait;
    if (r != null && r <= 0)
      throw new q(`Invalid value ${r} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);
    let t = e.timeout;
    if (t != null && t <= 0)
      throw new q(`Invalid value ${t} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`);
  }, __internal: (e) => {
    if (!e)
      return;
    let r = ["debug", "engine", "configOverride"];
    if (typeof e != "object")
      throw new q(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);
    for (let [t] of Object.entries(e))
      if (!r.includes(t)) {
        let n = Lr(t, r);
        throw new q(`Invalid property ${JSON.stringify(t)} for "__internal" provided to PrismaClient constructor.${n}`);
      }
  } };
  var Ye = N("prisma:client");
  typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
  var nd = { requestArgsToMiddlewareArgs: (e) => e, middlewareArgsToRequestArgs: (e) => e };
  var id = Symbol.for("prisma.client.transaction.id");
  var od = { id: 0, nextId() {
    return ++this.id;
  } };
  var ad = new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
  /*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  */
});

// node_modules/.prisma/client/index.js
var require_client = __commonJS((exports) => {
  var __dirname = "/home/ujjujjuj/code/projects/switcher-freelance/tstrack/tracker/node_modules/.prisma/client";
  Object.defineProperty(exports, "__esModule", { value: true });
  var {
    PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
    PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
    PrismaClientRustPanicError: PrismaClientRustPanicError2,
    PrismaClientInitializationError: PrismaClientInitializationError2,
    PrismaClientValidationError: PrismaClientValidationError2,
    NotFoundError: NotFoundError2,
    getPrismaClient: getPrismaClient2,
    sqltag: sqltag2,
    empty: empty2,
    join: join2,
    raw: raw2,
    Decimal: Decimal2,
    Debug: Debug2,
    objectEnumValues: objectEnumValues2,
    makeStrictEnum: makeStrictEnum2,
    Extensions: Extensions2,
    warnOnce: warnOnce2,
    defineDmmfProperty: defineDmmfProperty2,
    Public: Public2,
    getRuntime: getRuntime2
  } = require_library();
  var Prisma = {};
  exports.Prisma = Prisma;
  exports.$Enums = {};
  Prisma.prismaVersion = {
    client: "5.11.0",
    engine: "efd2449663b3d73d637ea1fd226bafbcf45b3102"
  };
  Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
  Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
  Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
  Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
  Prisma.PrismaClientValidationError = PrismaClientValidationError2;
  Prisma.NotFoundError = NotFoundError2;
  Prisma.Decimal = Decimal2;
  Prisma.sql = sqltag2;
  Prisma.empty = empty2;
  Prisma.join = join2;
  Prisma.raw = raw2;
  Prisma.validator = Public2.validator;
  Prisma.getExtensionContext = Extensions2.getExtensionContext;
  Prisma.defineExtension = Extensions2.defineExtension;
  Prisma.DbNull = objectEnumValues2.instances.DbNull;
  Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
  Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
  Prisma.NullTypes = {
    DbNull: objectEnumValues2.classes.DbNull,
    JsonNull: objectEnumValues2.classes.JsonNull,
    AnyNull: objectEnumValues2.classes.AnyNull
  };
  var path = import.meta.require("path");
  exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
    ReadUncommitted: "ReadUncommitted",
    ReadCommitted: "ReadCommitted",
    RepeatableRead: "RepeatableRead",
    Serializable: "Serializable"
  });
  exports.Prisma.DebugScalarFieldEnum = {
    id: "id",
    txhash: "txhash",
    user_id: "user_id"
  };
  exports.Prisma.GroupScalarFieldEnum = {
    id: "id",
    name: "name"
  };
  exports.Prisma.UserScalarFieldEnum = {
    id: "id"
  };
  exports.Prisma.UserOnGroupScalarFieldEnum = {
    userId: "userId",
    groupId: "groupId",
    creationDate: "creationDate"
  };
  exports.Prisma.WatchAddressScalarFieldEnum = {
    id: "id",
    groupId: "groupId",
    address: "address",
    alias: "alias",
    chains: "chains"
  };
  exports.Prisma.SortOrder = {
    asc: "asc",
    desc: "desc"
  };
  exports.Prisma.QueryMode = {
    default: "default",
    insensitive: "insensitive"
  };
  exports.Chain = exports.$Enums.Chain = {
    ETH: "ETH",
    BNB: "BNB",
    ARB: "ARB",
    MATIC: "MATIC",
    AVAX: "AVAX",
    SOL: "SOL"
  };
  exports.Prisma.ModelName = {
    Debug: "Debug",
    Group: "Group",
    User: "User",
    UserOnGroup: "UserOnGroup",
    WatchAddress: "WatchAddress"
  };
  var config2 = {
    generator: {
      name: "client",
      provider: {
        fromEnvVar: null,
        value: "prisma-client-js"
      },
      output: {
        value: "/home/ujjujjuj/code/projects/switcher-freelance/tstrack/tracker/node_modules/@prisma/client",
        fromEnvVar: null
      },
      config: {
        engineType: "library"
      },
      binaryTargets: [
        {
          fromEnvVar: null,
          value: "debian-openssl-1.1.x",
          native: true
        },
        {
          fromEnvVar: null,
          value: "debian-openssl-3.0.x"
        }
      ],
      previewFeatures: []
    },
    relativeEnvPaths: {
      rootEnvPath: null,
      schemaEnvPath: "../../../.env"
    },
    relativePath: "../../../prisma",
    clientVersion: "5.11.0",
    engineVersion: "efd2449663b3d73d637ea1fd226bafbcf45b3102",
    datasourceNames: [
      "db"
    ],
    activeProvider: "postgresql",
    inlineDatasources: {
      db: {
        url: {
          fromEnvVar: "DATABASE_URL",
          value: null
        }
      }
    },
    inlineSchema: "generator client {\n  provider      = \"prisma-client-js\"\n  binaryTargets = [\"native\", \"debian-openssl-3.0.x\"]\n}\n\ndatasource db {\n  provider = \"postgres\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel Debug {\n  id      String @id\n  txhash  String\n  user_id String\n}\n\nmodel Group {\n  id           String         @id\n  name         String\n  UserOnGroup  UserOnGroup[]\n  WatchAddress WatchAddress[]\n}\n\nmodel User {\n  id          String        @id\n  UserOnGroup UserOnGroup[]\n}\n\nmodel UserOnGroup {\n  userId       String\n  groupId      String\n  creationDate DateTime @default(now())\n  Group        Group    @relation(fields: [groupId], references: [id], onUpdate: Cascade)\n  User         User     @relation(fields: [userId], references: [id])\n\n  @@id([userId, groupId])\n}\n\nmodel WatchAddress {\n  id      String  @id\n  groupId String\n  address String\n  alias   String\n  chains  Chain[]\n  Group   Group   @relation(fields: [groupId], references: [id], onUpdate: Cascade)\n\n  @@unique([groupId, address])\n}\n\nenum Chain {\n  ETH\n  BNB\n  ARB\n  MATIC\n  AVAX\n  SOL\n}\n",
    inlineSchemaHash: "a52bb3772a5a932c0e02a14dcb606ee678758169c3244ae0fea6c78734ea74c8",
    copyEngine: true
  };
  var fs = import.meta.require("fs");
  config2.dirname = __dirname;
  if (!fs.existsSync(path.join(__dirname, "schema.prisma"))) {
    const alternativePaths = [
      "node_modules/.prisma/client",
      ".prisma/client"
    ];
    const alternativePath = alternativePaths.find((altPath) => {
      return fs.existsSync(path.join(process.cwd(), altPath, "schema.prisma"));
    }) ?? alternativePaths[0];
    config2.dirname = path.join(process.cwd(), alternativePath);
    config2.isBundled = true;
  }
  config2.runtimeDataModel = JSON.parse("{\"models\":{\"Debug\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"txhash\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user_id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Group\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"UserOnGroup\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"UserOnGroup\",\"relationName\":\"GroupToUserOnGroup\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"WatchAddress\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"WatchAddress\",\"relationName\":\"GroupToWatchAddress\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"User\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"UserOnGroup\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"UserOnGroup\",\"relationName\":\"UserToUserOnGroup\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"UserOnGroup\":{\"dbName\":null,\"fields\":[{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"groupId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"creationDate\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"Group\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Group\",\"relationName\":\"GroupToUserOnGroup\",\"relationFromFields\":[\"groupId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"User\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"relationName\":\"UserToUserOnGroup\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":{\"name\":null,\"fields\":[\"userId\",\"groupId\"]},\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"WatchAddress\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"groupId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"address\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"alias\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"chains\",\"kind\":\"enum\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Chain\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"Group\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Group\",\"relationName\":\"GroupToWatchAddress\",\"relationFromFields\":[\"groupId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[[\"groupId\",\"address\"]],\"uniqueIndexes\":[{\"name\":null,\"fields\":[\"groupId\",\"address\"]}],\"isGenerated\":false}},\"enums\":{\"Chain\":{\"values\":[{\"name\":\"ETH\",\"dbName\":null},{\"name\":\"BNB\",\"dbName\":null},{\"name\":\"ARB\",\"dbName\":null},{\"name\":\"MATIC\",\"dbName\":null},{\"name\":\"AVAX\",\"dbName\":null},{\"name\":\"SOL\",\"dbName\":null}],\"dbName\":null}},\"types\":{}}");
  defineDmmfProperty2(exports.Prisma, config2.runtimeDataModel);
  config2.engineWasm = undefined;
  var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
  warnEnvConflicts2({
    rootEnvPath: config2.relativeEnvPaths.rootEnvPath && path.resolve(config2.dirname, config2.relativeEnvPaths.rootEnvPath),
    schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && path.resolve(config2.dirname, config2.relativeEnvPaths.schemaEnvPath)
  });
  var PrismaClient = getPrismaClient2(config2);
  exports.PrismaClient = PrismaClient;
  Object.assign(exports, Prisma);
  path.join(__dirname, "libquery_engine-debian-openssl-1.1.x.so.node");
  path.join(process.cwd(), "node_modules/.prisma/client/libquery_engine-debian-openssl-1.1.x.so.node");
  path.join(__dirname, "libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(process.cwd(), "node_modules/.prisma/client/libquery_engine-debian-openssl-3.0.x.so.node");
  path.join(__dirname, "schema.prisma");
  path.join(process.cwd(), "node_modules/.prisma/client/schema.prisma");
});

// node_modules/.prisma/client/default.js
var require_default = __commonJS((exports, module) => {
  module.exports = { ...require_client() };
});

// node_modules/@prisma/client/default.js
var require_default2 = __commonJS((exports, module) => {
  module.exports = {
    ...require_default()
  };
});

// node_modules/web3-utils/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports, module) => {
  var Events = function() {
  };
  var EE = function(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  };
  var addListener = function(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  };
  var clearEvent = function(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  };
  var EventEmitter = function() {
    this._events = new Events;
    this._eventsCount = 0;
  };
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1);i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0;i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length;i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter;
  }
});

// node_modules/cross-fetch/dist/node-ponyfill.js
var require_node_ponyfill = __commonJS((exports, module) => {
  var nodeFetch = import.meta.require("node-fetch");
  var realFetch = nodeFetch.default || nodeFetch;
  var fetch2 = function(url, options) {
    if (/^\/\//.test(url)) {
      url = "https:" + url;
    }
    return realFetch.call(this, url, options);
  };
  fetch2.ponyfill = true;
  module.exports = exports = fetch2;
  exports.fetch = fetch2;
  exports.Headers = nodeFetch.Headers;
  exports.Request = nodeFetch.Request;
  exports.Response = nodeFetch.Response;
  exports.default = fetch2;
});

// node_modules/@ethereumjs/rlp/dist/index.js
var require_dist = __commonJS((exports) => {
  var encode = function(input) {
    if (Array.isArray(input)) {
      const output2 = [];
      let outputLength = 0;
      for (let i = 0;i < input.length; i++) {
        const encoded = encode(input[i]);
        output2.push(encoded);
        outputLength += encoded.length;
      }
      return concatBytes3(encodeLength(outputLength, 192), ...output2);
    }
    const inputBuf = toBytes2(input);
    if (inputBuf.length === 1 && inputBuf[0] < 128) {
      return inputBuf;
    }
    return concatBytes3(encodeLength(inputBuf.length, 128), inputBuf);
  };
  var safeSlice = function(input, start, end) {
    if (end > input.length) {
      throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
    }
    return input.slice(start, end);
  };
  var decodeLength = function(v) {
    if (v[0] === 0) {
      throw new Error("invalid RLP: extra zeros");
    }
    return parseHexByte(bytesToHex4(v));
  };
  var encodeLength = function(len, offset) {
    if (len < 56) {
      return Uint8Array.from([len + offset]);
    }
    const hexLength = numberToHex3(len);
    const lLength = hexLength.length / 2;
    const firstByte = numberToHex3(offset + 55 + lLength);
    return Uint8Array.from(hexToBytes3(firstByte + hexLength));
  };
  var decode = function(input, stream = false) {
    if (typeof input === "undefined" || input === null || input.length === 0) {
      return Uint8Array.from([]);
    }
    const inputBytes = toBytes2(input);
    const decoded = _decode(inputBytes);
    if (stream) {
      return decoded;
    }
    if (decoded.remainder.length !== 0) {
      throw new Error("invalid RLP: remainder must be zero");
    }
    return decoded.data;
  };
  var _decode = function(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 127) {
      return {
        data: input.slice(0, 1),
        remainder: input.slice(1)
      };
    } else if (firstByte <= 183) {
      length = firstByte - 127;
      if (firstByte === 128) {
        data = Uint8Array.from([]);
      } else {
        data = safeSlice(input, 1, length);
      }
      if (length === 2 && data[0] < 128) {
        throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
      }
      return {
        data,
        remainder: input.slice(length)
      };
    } else if (firstByte <= 191) {
      llength = firstByte - 182;
      if (input.length - 1 < llength) {
        throw new Error("invalid RLP: not enough bytes for string length");
      }
      length = decodeLength(safeSlice(input, 1, llength));
      if (length <= 55) {
        throw new Error("invalid RLP: expected string length to be greater than 55");
      }
      data = safeSlice(input, llength, length + llength);
      return {
        data,
        remainder: input.slice(length + llength)
      };
    } else if (firstByte <= 247) {
      length = firstByte - 191;
      innerRemainder = safeSlice(input, 1, length);
      while (innerRemainder.length) {
        d = _decode(innerRemainder);
        decoded.push(d.data);
        innerRemainder = d.remainder;
      }
      return {
        data: decoded,
        remainder: input.slice(length)
      };
    } else {
      llength = firstByte - 246;
      length = decodeLength(safeSlice(input, 1, llength));
      if (length < 56) {
        throw new Error("invalid RLP: encoded list too short");
      }
      const totalLength = llength + length;
      if (totalLength > input.length) {
        throw new Error("invalid RLP: total length is larger than the data");
      }
      innerRemainder = safeSlice(input, llength, totalLength);
      while (innerRemainder.length) {
        d = _decode(innerRemainder);
        decoded.push(d.data);
        innerRemainder = d.remainder;
      }
      return {
        data: decoded,
        remainder: input.slice(totalLength)
      };
    }
  };
  var bytesToHex4 = function(uint8a) {
    let hex = "";
    for (let i = 0;i < uint8a.length; i++) {
      hex += cachedHexes[uint8a[i]];
    }
    return hex;
  };
  var parseHexByte = function(hexByte) {
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte))
      throw new Error("Invalid byte sequence");
    return byte;
  };
  var hexToBytes3 = function(hex) {
    if (typeof hex !== "string") {
      throw new TypeError("hexToBytes: expected string, got " + typeof hex);
    }
    if (hex.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex");
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0;i < array.length; i++) {
      const j = i * 2;
      array[i] = parseHexByte(hex.slice(j, j + 2));
    }
    return array;
  };
  var concatBytes3 = function(...arrays) {
    if (arrays.length === 1)
      return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0;i < arrays.length; i++) {
      const arr = arrays[i];
      result.set(arr, pad);
      pad += arr.length;
    }
    return result;
  };
  var utf8ToBytes4 = function(utf) {
    return new TextEncoder().encode(utf);
  };
  var numberToHex3 = function(integer) {
    if (integer < 0) {
      throw new Error("Invalid integer as argument, must be unsigned!");
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
  };
  var padToEven2 = function(a) {
    return a.length % 2 ? `0${a}` : a;
  };
  var isHexPrefixed2 = function(str) {
    return str.length >= 2 && str[0] === "0" && str[1] === "x";
  };
  var stripHexPrefix2 = function(str) {
    if (typeof str !== "string") {
      return str;
    }
    return isHexPrefixed2(str) ? str.slice(2) : str;
  };
  var toBytes2 = function(v) {
    if (v instanceof Uint8Array) {
      return v;
    }
    if (typeof v === "string") {
      if (isHexPrefixed2(v)) {
        return hexToBytes3(padToEven2(stripHexPrefix2(v)));
      }
      return utf8ToBytes4(v);
    }
    if (typeof v === "number" || typeof v === "bigint") {
      if (!v) {
        return Uint8Array.from([]);
      }
      return hexToBytes3(numberToHex3(v));
    }
    if (v === null || v === undefined) {
      return Uint8Array.from([]);
    }
    throw new Error("toBytes: received unsupported type " + typeof v);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RLP = exports.utils = exports.decode = exports.encode = undefined;
  exports.encode = encode;
  exports.decode = decode;
  var cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
  exports.utils = {
    bytesToHex: bytesToHex4,
    concatBytes: concatBytes3,
    hexToBytes: hexToBytes3,
    utf8ToBytes: utf8ToBytes4
  };
  exports.RLP = { encode, decode };
});

// node_modules/crc-32/crc32.js
var require_crc32 = __commonJS((exports) => {
  /*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
  var CRC32;
  (function(factory) {
    if (typeof DO_NOT_EXPORT_CRC === "undefined") {
      if (typeof exports === "object") {
        factory(exports);
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          var module2 = {};
          factory(module2);
          return module2;
        });
      } else {
        factory(CRC32 = {});
      }
    } else {
      factory(CRC32 = {});
    }
  })(function(CRC322) {
    CRC322.version = "1.2.2";
    function signed_crc_table() {
      var c = 0, table = new Array(256);
      for (var n = 0;n != 256; ++n) {
        c = n;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        table[n] = c;
      }
      return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
    }
    var T0 = signed_crc_table();
    function slice_by_16_tables(T) {
      var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
      for (n = 0;n != 256; ++n)
        table[n] = T[n];
      for (n = 0;n != 256; ++n) {
        v = T[n];
        for (c = 256 + n;c < 4096; c += 256)
          v = table[c] = v >>> 8 ^ T[v & 255];
      }
      var out = [];
      for (n = 1;n != 16; ++n)
        out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
      return out;
    }
    var TT = slice_by_16_tables(T0);
    var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
    var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
    var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
    function crc32_bstr(bstr, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = bstr.length;i < L; )
        C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
      return ~C;
    }
    function crc32_buf(B, seed) {
      var C = seed ^ -1, L = B.length - 15, i = 0;
      for (;i < L; )
        C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
      L += 15;
      while (i < L)
        C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
      return ~C;
    }
    function crc32_str(str, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = str.length, c = 0, d = 0;i < L; ) {
        c = str.charCodeAt(i++);
        if (c < 128) {
          C = C >>> 8 ^ T0[(C ^ c) & 255];
        } else if (c < 2048) {
          C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        } else if (c >= 55296 && c < 57344) {
          c = (c & 1023) + 64;
          d = str.charCodeAt(i++) & 1023;
          C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
        } else {
          C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        }
      }
      return ~C;
    }
    CRC322.table = T0;
    CRC322.bstr = crc32_bstr;
    CRC322.buf = crc32_buf;
    CRC322.str = crc32_str;
  });
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate2 = __commonJS((exports) => {
  (function(global2, undefined2) {
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i + 1];
      }
      var task = { callback, args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }
    function run(task) {
      var callback = task.callback;
      var args = task.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined2, args);
          break;
      }
    }
    function runIfPresent(handle) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunningATask = true;
          try {
            run(task);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle) {
        process.nextTick(function() {
          runIfPresent(handle);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event) {
        if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle) {
        global2.postMessage(messagePrefix + handle, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel;
      channel.port1.onmessage = function(event) {
        var handle = event.data;
        runIfPresent(handle);
      };
      registerImmediate = function(handle) {
        channel.port2.postMessage(handle);
      };
    }
    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;
      registerImmediate = function(handle) {
        var script = doc.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };
        html.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === "undefined" ? typeof global === "undefined" ? exports : global : self);
});

// node_modules/abitype/dist/chunk-O6V2CMEF.js
var require_chunk_O6V2CMEF = __commonJS((exports) => {
  var _optionalChain = function(ops) {
    let lastAccessLHS = undefined;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = fn(value);
      } else if (op === "call" || op === "optionalCall") {
        value = fn((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = undefined;
      }
    }
    return value;
  };
  var execTyped = function(regex, string9) {
    const match = regex.exec(string9);
    return _optionalChain([match, "optionalAccess", (_) => _.groups]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
  var integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  var isTupleRegex = /^\(.+?\).*?$/;
  exports.execTyped = execTyped;
  exports.bytesRegex = bytesRegex;
  exports.integerRegex = integerRegex;
  exports.isTupleRegex = isTupleRegex;
});

// node_modules/abitype/dist/chunk-XXPGZHWZ.js
var require_chunk_XXPGZHWZ = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  exports.__publicField = __publicField;
});

// node_modules/abitype/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var _nullishCoalesce = function(lhs, rhsFn) {
    if (lhs != null) {
      return lhs;
    } else {
      return rhsFn();
    }
  };
  var _optionalChain = function(ops) {
    let lastAccessLHS = undefined;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = fn(value);
      } else if (op === "call" || op === "optionalCall") {
        value = fn((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = undefined;
      }
    }
    return value;
  };
  var narrow = function(value) {
    return value;
  };
  var isErrorSignature = function(signature) {
    return errorSignatureRegex.test(signature);
  };
  var execErrorSignature = function(signature) {
    return _chunkO6V2CMEFjs.execTyped.call(undefined, errorSignatureRegex, signature);
  };
  var isEventSignature = function(signature) {
    return eventSignatureRegex.test(signature);
  };
  var execEventSignature = function(signature) {
    return _chunkO6V2CMEFjs.execTyped.call(undefined, eventSignatureRegex, signature);
  };
  var isFunctionSignature = function(signature) {
    return functionSignatureRegex.test(signature);
  };
  var execFunctionSignature = function(signature) {
    return _chunkO6V2CMEFjs.execTyped.call(undefined, functionSignatureRegex, signature);
  };
  var isStructSignature = function(signature) {
    return structSignatureRegex.test(signature);
  };
  var execStructSignature = function(signature) {
    return _chunkO6V2CMEFjs.execTyped.call(undefined, structSignatureRegex, signature);
  };
  var isConstructorSignature = function(signature) {
    return constructorSignatureRegex.test(signature);
  };
  var execConstructorSignature = function(signature) {
    return _chunkO6V2CMEFjs.execTyped.call(undefined, constructorSignatureRegex, signature);
  };
  var isFallbackSignature = function(signature) {
    return fallbackSignatureRegex.test(signature);
  };
  var isReceiveSignature = function(signature) {
    return receiveSignatureRegex.test(signature);
  };
  var getParameterCacheKey = function(param, type) {
    if (type)
      return `${type}:${param}`;
    return param;
  };
  var parseSignature = function(signature, structs = {}) {
    if (isFunctionSignature(signature)) {
      const match = execFunctionSignature(signature);
      if (!match)
        throw new BaseError("Invalid function signature.", {
          details: signature
        });
      const inputParams = splitParameters(match.parameters);
      const inputs = [];
      const inputLength = inputParams.length;
      for (let i = 0;i < inputLength; i++) {
        inputs.push(parseAbiParameter(inputParams[i], {
          modifiers: functionModifiers,
          structs,
          type: "function"
        }));
      }
      const outputs = [];
      if (match.returns) {
        const outputParams = splitParameters(match.returns);
        const outputLength = outputParams.length;
        for (let i = 0;i < outputLength; i++) {
          outputs.push(parseAbiParameter(outputParams[i], {
            modifiers: functionModifiers,
            structs,
            type: "function"
          }));
        }
      }
      return {
        name: match.name,
        type: "function",
        stateMutability: _nullishCoalesce(match.stateMutability, () => "nonpayable"),
        inputs,
        outputs
      };
    }
    if (isEventSignature(signature)) {
      const match = execEventSignature(signature);
      if (!match)
        throw new BaseError("Invalid event signature.", {
          details: signature
        });
      const params = splitParameters(match.parameters);
      const abiParameters = [];
      const length = params.length;
      for (let i = 0;i < length; i++) {
        abiParameters.push(parseAbiParameter(params[i], {
          modifiers: eventModifiers,
          structs,
          type: "event"
        }));
      }
      return { name: match.name, type: "event", inputs: abiParameters };
    }
    if (isErrorSignature(signature)) {
      const match = execErrorSignature(signature);
      if (!match)
        throw new BaseError("Invalid error signature.", {
          details: signature
        });
      const params = splitParameters(match.parameters);
      const abiParameters = [];
      const length = params.length;
      for (let i = 0;i < length; i++) {
        abiParameters.push(parseAbiParameter(params[i], { structs, type: "error" }));
      }
      return { name: match.name, type: "error", inputs: abiParameters };
    }
    if (isConstructorSignature(signature)) {
      const match = execConstructorSignature(signature);
      if (!match)
        throw new BaseError("Invalid constructor signature.", {
          details: signature
        });
      const params = splitParameters(match.parameters);
      const abiParameters = [];
      const length = params.length;
      for (let i = 0;i < length; i++) {
        abiParameters.push(parseAbiParameter(params[i], { structs, type: "constructor" }));
      }
      return {
        type: "constructor",
        stateMutability: _nullishCoalesce(match.stateMutability, () => "nonpayable"),
        inputs: abiParameters
      };
    }
    if (isFallbackSignature(signature))
      return { type: "fallback" };
    if (isReceiveSignature(signature))
      return {
        type: "receive",
        stateMutability: "payable"
      };
    throw new BaseError("Unknown signature.", {
      details: signature
    });
  };
  var parseAbiParameter = function(param, options) {
    const parameterCacheKey = getParameterCacheKey(param, _optionalChain([options, "optionalAccess", (_3) => _3.type]));
    if (parameterCache.has(parameterCacheKey))
      return parameterCache.get(parameterCacheKey);
    const isTuple = _chunkO6V2CMEFjs.isTupleRegex.test(param);
    const match = _chunkO6V2CMEFjs.execTyped.call(undefined, isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
    if (!match)
      throw new BaseError("Invalid ABI parameter.", {
        details: param
      });
    if (match.name && isSolidityKeyword(match.name))
      throw new BaseError("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `"${match.name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
        ]
      });
    const name2 = match.name ? { name: match.name } : {};
    const indexed = match.modifier === "indexed" ? { indexed: true } : {};
    const structs = _nullishCoalesce(_optionalChain([options, "optionalAccess", (_4) => _4.structs]), () => ({}));
    let type;
    let components = {};
    if (isTuple) {
      type = "tuple";
      const params = splitParameters(match.type);
      const components_ = [];
      const length = params.length;
      for (let i = 0;i < length; i++) {
        components_.push(parseAbiParameter(params[i], { structs }));
      }
      components = { components: components_ };
    } else if (match.type in structs) {
      type = "tuple";
      components = { components: structs[match.type] };
    } else if (dynamicIntegerRegex.test(match.type)) {
      type = `${match.type}256`;
    } else {
      type = match.type;
      if (!(_optionalChain([options, "optionalAccess", (_5) => _5.type]) === "struct") && !isSolidityType(type))
        throw new BaseError("Unknown type.", {
          metaMessages: [`Type "${type}" is not a valid ABI type.`]
        });
    }
    if (match.modifier) {
      if (!_optionalChain([options, "optionalAccess", (_6) => _6.modifiers, "optionalAccess", (_7) => _7.has, "optionalCall", (_8) => _8(match.modifier)]))
        throw new BaseError("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${match.modifier}" not allowed${_optionalChain([options, "optionalAccess", (_9) => _9.type]) ? ` in "${options.type}" type` : ""}.`
          ]
        });
      if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
        throw new BaseError("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${match.modifier}" not allowed${_optionalChain([options, "optionalAccess", (_10) => _10.type]) ? ` in "${options.type}" type` : ""}.`,
            `Data location can only be specified for array, struct, or mapping types, but "${match.modifier}" was given.`
          ]
        });
    }
    const abiParameter = {
      type: `${type}${_nullishCoalesce(match.array, () => "")}`,
      ...name2,
      ...indexed,
      ...components
    };
    parameterCache.set(parameterCacheKey, abiParameter);
    return abiParameter;
  };
  var splitParameters = function(params, result = [], current = "", depth = 0) {
    if (params === "") {
      if (current === "")
        return result;
      if (depth !== 0)
        throw new BaseError("Unbalanced parentheses.", {
          metaMessages: [
            `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
          ],
          details: `Depth "${depth}"`
        });
      return [...result, current.trim()];
    }
    const length = params.length;
    for (let i = 0;i < length; i++) {
      const char = params[i];
      const tail = params.slice(i + 1);
      switch (char) {
        case ",":
          return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
        case "(":
          return splitParameters(tail, result, `${current}${char}`, depth + 1);
        case ")":
          return splitParameters(tail, result, `${current}${char}`, depth - 1);
        default:
          return splitParameters(tail, result, `${current}${char}`, depth);
      }
    }
    return [];
  };
  var isSolidityType = function(type) {
    return type === "address" || type === "bool" || type === "function" || type === "string" || _chunkO6V2CMEFjs.bytesRegex.test(type) || _chunkO6V2CMEFjs.integerRegex.test(type);
  };
  var isSolidityKeyword = function(name2) {
    return name2 === "address" || name2 === "bool" || name2 === "function" || name2 === "string" || name2 === "tuple" || _chunkO6V2CMEFjs.bytesRegex.test(name2) || _chunkO6V2CMEFjs.integerRegex.test(name2) || protectedKeywordsRegex.test(name2);
  };
  var isValidDataLocation = function(type, isArray) {
    return isArray || type === "bytes" || type === "string" || type === "tuple";
  };
  var parseStructs = function(signatures) {
    const shallowStructs = {};
    const signaturesLength = signatures.length;
    for (let i = 0;i < signaturesLength; i++) {
      const signature = signatures[i];
      if (!isStructSignature(signature))
        continue;
      const match = execStructSignature(signature);
      if (!match)
        throw new BaseError("Invalid struct signature.", {
          details: signature
        });
      const properties = match.properties.split(";");
      const components = [];
      const propertiesLength = properties.length;
      for (let k = 0;k < propertiesLength; k++) {
        const property = properties[k];
        const trimmed = property.trim();
        if (!trimmed)
          continue;
        const abiParameter = parseAbiParameter(trimmed, {
          type: "struct"
        });
        components.push(abiParameter);
      }
      if (!components.length)
        throw new BaseError("Invalid struct signature.", {
          details: signature,
          metaMessages: ["No properties exist."]
        });
      shallowStructs[match.name] = components;
    }
    const resolvedStructs = {};
    const entries = Object.entries(shallowStructs);
    const entriesLength = entries.length;
    for (let i = 0;i < entriesLength; i++) {
      const [name2, parameters] = entries[i];
      resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);
    }
    return resolvedStructs;
  };
  var resolveStructs = function(abiParameters, structs, ancestors = new Set) {
    const components = [];
    const length = abiParameters.length;
    for (let i = 0;i < length; i++) {
      const abiParameter = abiParameters[i];
      const isTuple = _chunkO6V2CMEFjs.isTupleRegex.test(abiParameter.type);
      if (isTuple)
        components.push(abiParameter);
      else {
        const match = _chunkO6V2CMEFjs.execTyped.call(undefined, typeWithoutTupleRegex, abiParameter.type);
        if (!_optionalChain([match, "optionalAccess", (_11) => _11.type]))
          throw new BaseError("Invalid ABI parameter.", {
            details: JSON.stringify(abiParameter, null, 2),
            metaMessages: ["ABI parameter type is invalid."]
          });
        const { array, type } = match;
        if (type in structs) {
          if (ancestors.has(type))
            throw new BaseError("Circular reference detected.", {
              metaMessages: [`Struct "${type}" is a circular reference.`]
            });
          components.push({
            ...abiParameter,
            type: `tuple${_nullishCoalesce(array, () => "")}`,
            components: resolveStructs(_nullishCoalesce(structs[type], () => []), structs, new Set([...ancestors, type]))
          });
        } else {
          if (isSolidityType(type))
            components.push(abiParameter);
          else
            throw new BaseError("Unknown type.", {
              metaMessages: [
                `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
              ]
            });
        }
      }
    }
    return components;
  };
  var parseAbi = function(signatures) {
    const structs = parseStructs(signatures);
    const abi2 = [];
    const length = signatures.length;
    for (let i = 0;i < length; i++) {
      const signature = signatures[i];
      if (isStructSignature(signature))
        continue;
      abi2.push(parseSignature(signature, structs));
    }
    return abi2;
  };
  var parseAbiItem = function(signature) {
    let abiItem;
    if (typeof signature === "string")
      abiItem = parseSignature(signature);
    else {
      const structs = parseStructs(signature);
      const length = signature.length;
      for (let i = 0;i < length; i++) {
        const signature_ = signature[i];
        if (isStructSignature(signature_))
          continue;
        abiItem = parseSignature(signature_, structs);
        break;
      }
    }
    if (!abiItem)
      throw new BaseError("Failed to parse ABI item.", {
        details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
        docsPath: "/api/human.html#parseabiitem-1"
      });
    return abiItem;
  };
  var parseAbiParameter2 = function(param) {
    let abiParameter;
    if (typeof param === "string")
      abiParameter = parseAbiParameter(param, {
        modifiers
      });
    else {
      const structs = parseStructs(param);
      const length = param.length;
      for (let i = 0;i < length; i++) {
        const signature = param[i];
        if (isStructSignature(signature))
          continue;
        abiParameter = parseAbiParameter(signature, { modifiers, structs });
        break;
      }
    }
    if (!abiParameter)
      throw new BaseError("Failed to parse ABI parameter.", {
        details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
        docsPath: "/api/human.html#parseabiparameter-1"
      });
    return abiParameter;
  };
  var parseAbiParameters = function(params) {
    const abiParameters = [];
    if (typeof params === "string") {
      const parameters = splitParameters(params);
      const length = parameters.length;
      for (let i = 0;i < length; i++) {
        abiParameters.push(parseAbiParameter(parameters[i], { modifiers }));
      }
    } else {
      const structs = parseStructs(params);
      const length = params.length;
      for (let i = 0;i < length; i++) {
        const signature = params[i];
        if (isStructSignature(signature))
          continue;
        const parameters = splitParameters(signature);
        const length2 = parameters.length;
        for (let k = 0;k < length2; k++) {
          abiParameters.push(parseAbiParameter(parameters[k], { modifiers, structs }));
        }
      }
    }
    if (abiParameters.length === 0)
      throw new BaseError("Failed to parse ABI parameters.", {
        details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
        docsPath: "/api/human.html#parseabiparameters-1"
      });
    return abiParameters;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var _chunkO6V2CMEFjs = require_chunk_O6V2CMEF();
  var _chunkXXPGZHWZjs = require_chunk_XXPGZHWZ();
  var name = "abitype";
  var version = "0.7.1";
  var BaseError = class extends Error {
    constructor(shortMessage, args = {}) {
      const details = args.cause instanceof BaseError ? args.cause.details : _optionalChain([args, "access", (_) => _.cause, "optionalAccess", (_2) => _2.message]) ? args.cause.message : args.details;
      const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
      const message = [
        shortMessage || "An error occurred.",
        "",
        ...args.metaMessages ? [...args.metaMessages, ""] : [],
        ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
        ...details ? [`Details: ${details}`] : [],
        `Version: ${name}@${version}`
      ].join("\n");
      super(message);
      _chunkXXPGZHWZjs.__publicField.call(undefined, this, "details");
      _chunkXXPGZHWZjs.__publicField.call(undefined, this, "docsPath");
      _chunkXXPGZHWZjs.__publicField.call(undefined, this, "metaMessages");
      _chunkXXPGZHWZjs.__publicField.call(undefined, this, "shortMessage");
      _chunkXXPGZHWZjs.__publicField.call(undefined, this, "name", "AbiTypeError");
      if (args.cause)
        this.cause = args.cause;
      this.details = details;
      this.docsPath = docsPath;
      this.metaMessages = args.metaMessages;
      this.shortMessage = shortMessage;
    }
  };
  var errorSignatureRegex = /^error (?<name>[a-zA-Z0-9_]+)\((?<parameters>.*?)\)$/;
  var eventSignatureRegex = /^event (?<name>[a-zA-Z0-9_]+)\((?<parameters>.*?)\)$/;
  var functionSignatureRegex = /^function (?<name>[a-zA-Z0-9_]+)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns \((?<returns>.*?)\))?$/;
  var structSignatureRegex = /^struct (?<name>[a-zA-Z0-9_]+) \{(?<properties>.*?)\}$/;
  var constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
  var fallbackSignatureRegex = /^fallback\(\)$/;
  var receiveSignatureRegex = /^receive\(\) external payable$/;
  var modifiers = new Set([
    "memory",
    "indexed",
    "storage",
    "calldata"
  ]);
  var eventModifiers = new Set(["indexed"]);
  var functionModifiers = new Set([
    "calldata",
    "memory",
    "storage"
  ]);
  var parameterCache = new Map([
    ["address", { type: "address" }],
    ["bool", { type: "bool" }],
    ["bytes", { type: "bytes" }],
    ["bytes32", { type: "bytes32" }],
    ["int", { type: "int256" }],
    ["int256", { type: "int256" }],
    ["string", { type: "string" }],
    ["uint", { type: "uint256" }],
    ["uint8", { type: "uint8" }],
    ["uint16", { type: "uint16" }],
    ["uint24", { type: "uint24" }],
    ["uint32", { type: "uint32" }],
    ["uint64", { type: "uint64" }],
    ["uint96", { type: "uint96" }],
    ["uint112", { type: "uint112" }],
    ["uint160", { type: "uint160" }],
    ["uint192", { type: "uint192" }],
    ["uint256", { type: "uint256" }],
    ["address owner", { type: "address", name: "owner" }],
    ["address to", { type: "address", name: "to" }],
    ["bool approved", { type: "bool", name: "approved" }],
    ["bytes _data", { type: "bytes", name: "_data" }],
    ["bytes data", { type: "bytes", name: "data" }],
    ["bytes signature", { type: "bytes", name: "signature" }],
    ["bytes32 hash", { type: "bytes32", name: "hash" }],
    ["bytes32 r", { type: "bytes32", name: "r" }],
    ["bytes32 root", { type: "bytes32", name: "root" }],
    ["bytes32 s", { type: "bytes32", name: "s" }],
    ["string name", { type: "string", name: "name" }],
    ["string symbol", { type: "string", name: "symbol" }],
    ["string tokenURI", { type: "string", name: "tokenURI" }],
    ["uint tokenId", { type: "uint256", name: "tokenId" }],
    ["uint8 v", { type: "uint8", name: "v" }],
    ["uint256 balance", { type: "uint256", name: "balance" }],
    ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
    ["uint256 value", { type: "uint256", name: "value" }],
    [
      "event:address indexed from",
      { type: "address", name: "from", indexed: true }
    ],
    ["event:address indexed to", { type: "address", name: "to", indexed: true }],
    [
      "event:uint indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ],
    [
      "event:uint256 indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ]
  ]);
  var abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/;
  var abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/;
  var dynamicIntegerRegex = /^u?int$/;
  var protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
  var typeWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?$/;
  exports.BaseError = BaseError;
  exports.narrow = narrow;
  exports.parseAbi = parseAbi;
  exports.parseAbiItem = parseAbiItem;
  exports.parseAbiParameter = parseAbiParameter2;
  exports.parseAbiParameters = parseAbiParameters;
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS((exports, module) => {
  var setup = function(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash3 = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash3 = (hash3 << 5) - hash3 + namespace.charCodeAt(i);
        hash3 |= 0;
      }
      return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter2 = createDebug.formatters[format2];
          if (typeof formatter2 === "function") {
            const val = args[index];
            match = formatter2.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split3 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split3.length;
      for (i = 0;i < len; i++) {
        if (!split3[i]) {
          continue;
        }
        namespaces = split3[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  };
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  var useColors = function() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  };
  var formatArgs = function(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  };
  var save = function(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  };
  var load = function() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  };
  var localstorage = function() {
    try {
      return localStorage;
    } catch (error) {
    }
  };
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports.log = console.debug || console.log || (() => {
  });
  module.exports = require_common2()(exports);
  var { formatters: formatters2 } = module.exports;
  formatters2.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node3 = __commonJS((exports, module) => {
  var useColors = function() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  };
  var formatArgs = function(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  };
  var getDate = function() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  };
  var log = function(...args) {
    return process.stderr.write(util2.format(...args) + "\n");
  };
  var save = function(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  };
  var load = function() {
    return process.env.DEBUG;
  };
  var init2 = function(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  };
  var tty = import.meta.require("tty");
  var util2 = import.meta.require("util");
  exports.init = init2;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{throw new Error(`Cannot require module "supports-color"`);})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  module.exports = require_common2()(exports);
  var { formatters: formatters2 } = module.exports;
  formatters2.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters2.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node3();
  }
});

// node_modules/telegraf/lib/core/helpers/util.js
var require_util = __commonJS((exports) => {
  var fmtCaption = function(extra) {
    if (!extra)
      return;
    const caption = extra.caption;
    if (!caption || typeof caption === "string")
      return extra;
    const { text, entities } = caption;
    return {
      ...extra,
      caption: text,
      ...entities && {
        caption_entities: entities,
        parse_mode: undefined
      }
    };
  };
  function* zip(xs, ys) {
    const x = xs[Symbol.iterator]();
    const y = ys[Symbol.iterator]();
    let x1 = x.next();
    let y1 = y.next();
    while (!x1.done) {
      yield x1.value;
      if (!y1.done)
        yield y1.value;
      x1 = x.next();
      y1 = y.next();
    }
    while (!y1.done) {
      yield y1.value;
      y1 = y.next();
    }
  }
  var indexed = function(target, indexer) {
    return new Proxy(target, {
      get: function(target2, prop, receiver) {
        if ((typeof prop === "string" || typeof prop === "number") && !isNaN(+prop))
          return indexer.call(target2, +prop);
        return Reflect.get(target2, prop, receiver);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.indexed = exports.zip = exports.fmtCaption = exports.env = undefined;
  exports.env = process.env;
  exports.fmtCaption = fmtCaption;
  exports.zip = zip;
  exports.indexed = indexed;
});

// node_modules/telegraf/lib/reactions.js
var require_reactions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageReactions = exports.ReactionList = exports.Digit = undefined;
  var util_1 = require_util();
  exports.Digit = new Set(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]);
  var inspectReaction = (reaction) => {
    if (reaction.type === "custom_emoji")
      return `Custom(${reaction.custom_emoji_id})`;
    else
      return reaction.emoji;
  };

  class ReactionList {
    constructor(list) {
      this.list = list;
    }
    static fromArray(list = []) {
      return (0, util_1.indexed)(new ReactionList(list), function(index) {
        return this.list[index];
      });
    }
    static has(reactions, reaction) {
      if (typeof reaction === "string")
        if (exports.Digit.has(reaction[0]))
          return reactions.some((r) => r.custom_emoji_id === reaction);
        else
          return reactions.some((r) => r.emoji === reaction);
      return reactions.some((r) => {
        if (r.type === "custom_emoji")
          return r.custom_emoji_id === reaction.custom_emoji_id;
        else if (r.type === "emoji")
          return r.emoji === reaction.emoji;
      });
    }
    toArray() {
      return [...this.list];
    }
    filter(filterFn) {
      return ReactionList.fromArray(this.list.filter(filterFn));
    }
    has(reaction) {
      return ReactionList.has(this.list, reaction);
    }
    get count() {
      return this.list.length;
    }
    [Symbol.iterator]() {
      return this.list[Symbol.iterator]();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const flattened = this.list.map(inspectReaction).join(", ");
      return ["ReactionList {", flattened, "}"].join(" ");
    }
  }
  exports.ReactionList = ReactionList;

  class MessageReactions extends ReactionList {
    constructor(ctx) {
      var _a4, _b;
      super((_b = (_a4 = ctx.update.message_reaction) === null || _a4 === undefined ? undefined : _a4.new_reaction) !== null && _b !== undefined ? _b : []);
      this.ctx = ctx;
    }
    static from(ctx) {
      return (0, util_1.indexed)(new MessageReactions(ctx), function(index) {
        return this.list[index];
      });
    }
    get old() {
      var _a4;
      return ReactionList.fromArray((_a4 = this.ctx.update.message_reaction) === null || _a4 === undefined ? undefined : _a4.old_reaction);
    }
    get new() {
      var _a4;
      return ReactionList.fromArray((_a4 = this.ctx.update.message_reaction) === null || _a4 === undefined ? undefined : _a4.new_reaction);
    }
    get added() {
      return this.new.filter((reaction) => !this.old.has(reaction));
    }
    get removed() {
      return this.old.filter((reaction) => !this.new.has(reaction));
    }
    get kept() {
      return this.new.filter((reaction) => this.old.has(reaction));
    }
  }
  exports.MessageReactions = MessageReactions;
});

// node_modules/telegraf/lib/context.js
var require_context = __commonJS((exports) => {
  var getMessageFromAnySource = function(ctx) {
    var _a4, _b, _c, _d, _e;
    const msg = (_e = (_d = (_b = (_a4 = ctx.message) !== null && _a4 !== undefined ? _a4 : ctx.editedMessage) !== null && _b !== undefined ? _b : (_c = ctx.callbackQuery) === null || _c === undefined ? undefined : _c.message) !== null && _d !== undefined ? _d : ctx.channelPost) !== null && _e !== undefined ? _e : ctx.editedChannelPost;
    if (msg)
      return Object.assign(Object.create(Msg), msg);
  };
  var getUserFromAnySource = function(ctx) {
    var _a4, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    if (ctx.callbackQuery)
      return ctx.callbackQuery.from;
    const msg = ctx.msg;
    if (msg === null || msg === undefined ? undefined : msg.has("from"))
      return msg.from;
    return (_h = (_g = (_f = (_e = (_d = (_c = (_b = (_a4 = ctx.inlineQuery) !== null && _a4 !== undefined ? _a4 : ctx.shippingQuery) !== null && _b !== undefined ? _b : ctx.preCheckoutQuery) !== null && _c !== undefined ? _c : ctx.chosenInlineResult) !== null && _d !== undefined ? _d : ctx.chatMember) !== null && _e !== undefined ? _e : ctx.myChatMember) !== null && _f !== undefined ? _f : ctx.chatJoinRequest) === null || _g === undefined ? undefined : _g.from) !== null && _h !== undefined ? _h : (_m = (_k = (_j = ctx.messageReaction) !== null && _j !== undefined ? _j : ctx.pollAnswer) !== null && _k !== undefined ? _k : (_l = ctx.chatBoost) === null || _l === undefined ? undefined : _l.boost.source) === null || _m === undefined ? undefined : _m.user;
  };
  var getMsgIdFromAnySource = function(ctx) {
    var _a4, _b;
    const msg = getMessageFromAnySource(ctx);
    return (_b = (_a4 = msg !== null && msg !== undefined ? msg : ctx.messageReaction) !== null && _a4 !== undefined ? _a4 : ctx.messageReactionCount) === null || _b === undefined ? undefined : _b.message_id;
  };
  var getTextAndEntitiesFromAnySource = function(ctx) {
    const msg = ctx.msg;
    let text, entities;
    if (msg) {
      if ("text" in msg)
        text = msg.text, entities = msg.entities;
      else if ("caption" in msg)
        text = msg.caption, entities = msg.caption_entities;
      else if ("game" in msg)
        text = msg.game.text, entities = msg.game.text_entities;
    } else if (ctx.poll)
      text = ctx.poll.explanation, entities = ctx.poll.explanation_entities;
    return [text, entities];
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Context = undefined;
  var debug_1 = __importDefault(require_src());
  var reactions_1 = require_reactions();
  var debug = (0, debug_1.default)("telegraf:context");

  class Context {
    constructor(update, telegram, botInfo) {
      this.update = update;
      this.telegram = telegram;
      this.botInfo = botInfo;
      this.state = {};
    }
    get updateType() {
      for (const key in this.update) {
        if (typeof this.update[key] === "object")
          return key;
      }
      throw new Error(`Cannot determine \`updateType\` of ${JSON.stringify(this.update)}`);
    }
    get me() {
      var _a4;
      return (_a4 = this.botInfo) === null || _a4 === undefined ? undefined : _a4.username;
    }
    get tg() {
      return this.telegram;
    }
    get message() {
      return this.update.message;
    }
    get editedMessage() {
      return this.update.edited_message;
    }
    get inlineQuery() {
      return this.update.inline_query;
    }
    get shippingQuery() {
      return this.update.shipping_query;
    }
    get preCheckoutQuery() {
      return this.update.pre_checkout_query;
    }
    get chosenInlineResult() {
      return this.update.chosen_inline_result;
    }
    get channelPost() {
      return this.update.channel_post;
    }
    get editedChannelPost() {
      return this.update.edited_channel_post;
    }
    get messageReaction() {
      return this.update.message_reaction;
    }
    get messageReactionCount() {
      return this.update.message_reaction_count;
    }
    get callbackQuery() {
      return this.update.callback_query;
    }
    get poll() {
      return this.update.poll;
    }
    get pollAnswer() {
      return this.update.poll_answer;
    }
    get myChatMember() {
      return this.update.my_chat_member;
    }
    get chatMember() {
      return this.update.chat_member;
    }
    get chatJoinRequest() {
      return this.update.chat_join_request;
    }
    get chatBoost() {
      return this.update.chat_boost;
    }
    get removedChatBoost() {
      return this.update.removed_chat_boost;
    }
    get msg() {
      return getMessageFromAnySource(this);
    }
    get msgId() {
      return getMsgIdFromAnySource(this);
    }
    get chat() {
      var _a4, _b, _c, _d, _e, _f, _g;
      return (_g = (_f = (_e = (_d = (_c = (_b = (_a4 = this.msg) !== null && _a4 !== undefined ? _a4 : this.messageReaction) !== null && _b !== undefined ? _b : this.messageReactionCount) !== null && _c !== undefined ? _c : this.chatJoinRequest) !== null && _d !== undefined ? _d : this.chatMember) !== null && _e !== undefined ? _e : this.myChatMember) !== null && _f !== undefined ? _f : this.removedChatBoost) === null || _g === undefined ? undefined : _g.chat;
    }
    get senderChat() {
      const msg = this.msg;
      return (msg === null || msg === undefined ? undefined : msg.has("sender_chat")) && msg.sender_chat;
    }
    get from() {
      return getUserFromAnySource(this);
    }
    get inlineMessageId() {
      var _a4, _b;
      return (_b = (_a4 = this.callbackQuery) !== null && _a4 !== undefined ? _a4 : this.chosenInlineResult) === null || _b === undefined ? undefined : _b.inline_message_id;
    }
    get passportData() {
      var _a4;
      if (this.message == null)
        return;
      if (!("passport_data" in this.message))
        return;
      return (_a4 = this.message) === null || _a4 === undefined ? undefined : _a4.passport_data;
    }
    get webAppData() {
      if (!(this.message && ("web_app_data" in this.message)))
        return;
      const { data, button_text } = this.message.web_app_data;
      return {
        data: {
          json() {
            return JSON.parse(data);
          },
          text() {
            return data;
          }
        },
        button_text
      };
    }
    get webhookReply() {
      return this.telegram.webhookReply;
    }
    set webhookReply(enable) {
      this.telegram.webhookReply = enable;
    }
    get reactions() {
      return reactions_1.MessageReactions.from(this);
    }
    assert(value, method) {
      if (value === undefined) {
        throw new TypeError(`Telegraf: "${method}" isn't available for "${this.updateType}"`);
      }
    }
    has(filters) {
      if (!Array.isArray(filters))
        filters = [filters];
      for (const filter3 of filters)
        if (typeof filter3 !== "string" ? filter3(this.update) : (filter3 in this.update))
          return true;
      return false;
    }
    get text() {
      return getTextAndEntitiesFromAnySource(this)[0];
    }
    entities(...types15) {
      const [text = "", entities = []] = getTextAndEntitiesFromAnySource(this);
      return (types15.length ? entities.filter((entity) => types15.includes(entity.type)) : entities).map((entity) => ({
        ...entity,
        fragment: text.slice(entity.offset, entity.offset + entity.length)
      }));
    }
    answerInlineQuery(...args) {
      this.assert(this.inlineQuery, "answerInlineQuery");
      return this.telegram.answerInlineQuery(this.inlineQuery.id, ...args);
    }
    answerCbQuery(...args) {
      this.assert(this.callbackQuery, "answerCbQuery");
      return this.telegram.answerCbQuery(this.callbackQuery.id, ...args);
    }
    answerGameQuery(...args) {
      this.assert(this.callbackQuery, "answerGameQuery");
      return this.telegram.answerGameQuery(this.callbackQuery.id, ...args);
    }
    getUserChatBoosts() {
      this.assert(this.chat, "getUserChatBoosts");
      this.assert(this.from, "getUserChatBoosts");
      return this.telegram.getUserChatBoosts(this.chat.id, this.from.id);
    }
    answerShippingQuery(...args) {
      this.assert(this.shippingQuery, "answerShippingQuery");
      return this.telegram.answerShippingQuery(this.shippingQuery.id, ...args);
    }
    answerPreCheckoutQuery(...args) {
      this.assert(this.preCheckoutQuery, "answerPreCheckoutQuery");
      return this.telegram.answerPreCheckoutQuery(this.preCheckoutQuery.id, ...args);
    }
    editMessageText(text, extra) {
      var _a4, _b;
      this.assert((_a4 = this.msgId) !== null && _a4 !== undefined ? _a4 : this.inlineMessageId, "editMessageText");
      return this.telegram.editMessageText((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, text, extra);
    }
    editMessageCaption(caption, extra) {
      var _a4, _b;
      this.assert((_a4 = this.msgId) !== null && _a4 !== undefined ? _a4 : this.inlineMessageId, "editMessageCaption");
      return this.telegram.editMessageCaption((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, caption, extra);
    }
    editMessageMedia(media, extra) {
      var _a4, _b;
      this.assert((_a4 = this.msgId) !== null && _a4 !== undefined ? _a4 : this.inlineMessageId, "editMessageMedia");
      return this.telegram.editMessageMedia((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, media, extra);
    }
    editMessageReplyMarkup(markup) {
      var _a4, _b;
      this.assert((_a4 = this.msgId) !== null && _a4 !== undefined ? _a4 : this.inlineMessageId, "editMessageReplyMarkup");
      return this.telegram.editMessageReplyMarkup((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, markup);
    }
    editMessageLiveLocation(latitude, longitude, extra) {
      var _a4, _b;
      this.assert((_a4 = this.msgId) !== null && _a4 !== undefined ? _a4 : this.inlineMessageId, "editMessageLiveLocation");
      return this.telegram.editMessageLiveLocation((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, latitude, longitude, extra);
    }
    stopMessageLiveLocation(markup) {
      var _a4, _b;
      this.assert((_a4 = this.msgId) !== null && _a4 !== undefined ? _a4 : this.inlineMessageId, "stopMessageLiveLocation");
      return this.telegram.stopMessageLiveLocation((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, markup);
    }
    sendMessage(text, extra) {
      this.assert(this.chat, "sendMessage");
      return this.telegram.sendMessage(this.chat.id, text, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    reply(...args) {
      return this.sendMessage(...args);
    }
    getChat(...args) {
      this.assert(this.chat, "getChat");
      return this.telegram.getChat(this.chat.id, ...args);
    }
    exportChatInviteLink(...args) {
      this.assert(this.chat, "exportChatInviteLink");
      return this.telegram.exportChatInviteLink(this.chat.id, ...args);
    }
    createChatInviteLink(...args) {
      this.assert(this.chat, "createChatInviteLink");
      return this.telegram.createChatInviteLink(this.chat.id, ...args);
    }
    editChatInviteLink(...args) {
      this.assert(this.chat, "editChatInviteLink");
      return this.telegram.editChatInviteLink(this.chat.id, ...args);
    }
    revokeChatInviteLink(...args) {
      this.assert(this.chat, "revokeChatInviteLink");
      return this.telegram.revokeChatInviteLink(this.chat.id, ...args);
    }
    banChatMember(...args) {
      this.assert(this.chat, "banChatMember");
      return this.telegram.banChatMember(this.chat.id, ...args);
    }
    get kickChatMember() {
      return this.banChatMember;
    }
    unbanChatMember(...args) {
      this.assert(this.chat, "unbanChatMember");
      return this.telegram.unbanChatMember(this.chat.id, ...args);
    }
    restrictChatMember(...args) {
      this.assert(this.chat, "restrictChatMember");
      return this.telegram.restrictChatMember(this.chat.id, ...args);
    }
    promoteChatMember(...args) {
      this.assert(this.chat, "promoteChatMember");
      return this.telegram.promoteChatMember(this.chat.id, ...args);
    }
    setChatAdministratorCustomTitle(...args) {
      this.assert(this.chat, "setChatAdministratorCustomTitle");
      return this.telegram.setChatAdministratorCustomTitle(this.chat.id, ...args);
    }
    setChatPhoto(...args) {
      this.assert(this.chat, "setChatPhoto");
      return this.telegram.setChatPhoto(this.chat.id, ...args);
    }
    deleteChatPhoto(...args) {
      this.assert(this.chat, "deleteChatPhoto");
      return this.telegram.deleteChatPhoto(this.chat.id, ...args);
    }
    setChatTitle(...args) {
      this.assert(this.chat, "setChatTitle");
      return this.telegram.setChatTitle(this.chat.id, ...args);
    }
    setChatDescription(...args) {
      this.assert(this.chat, "setChatDescription");
      return this.telegram.setChatDescription(this.chat.id, ...args);
    }
    pinChatMessage(...args) {
      this.assert(this.chat, "pinChatMessage");
      return this.telegram.pinChatMessage(this.chat.id, ...args);
    }
    unpinChatMessage(...args) {
      this.assert(this.chat, "unpinChatMessage");
      return this.telegram.unpinChatMessage(this.chat.id, ...args);
    }
    unpinAllChatMessages(...args) {
      this.assert(this.chat, "unpinAllChatMessages");
      return this.telegram.unpinAllChatMessages(this.chat.id, ...args);
    }
    leaveChat(...args) {
      this.assert(this.chat, "leaveChat");
      return this.telegram.leaveChat(this.chat.id, ...args);
    }
    setChatPermissions(...args) {
      this.assert(this.chat, "setChatPermissions");
      return this.telegram.setChatPermissions(this.chat.id, ...args);
    }
    getChatAdministrators(...args) {
      this.assert(this.chat, "getChatAdministrators");
      return this.telegram.getChatAdministrators(this.chat.id, ...args);
    }
    getChatMember(...args) {
      this.assert(this.chat, "getChatMember");
      return this.telegram.getChatMember(this.chat.id, ...args);
    }
    getChatMembersCount(...args) {
      this.assert(this.chat, "getChatMembersCount");
      return this.telegram.getChatMembersCount(this.chat.id, ...args);
    }
    setPassportDataErrors(errors5) {
      this.assert(this.from, "setPassportDataErrors");
      return this.telegram.setPassportDataErrors(this.from.id, errors5);
    }
    sendPhoto(photo, extra) {
      this.assert(this.chat, "sendPhoto");
      return this.telegram.sendPhoto(this.chat.id, photo, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithPhoto(...args) {
      return this.sendPhoto(...args);
    }
    sendMediaGroup(media, extra) {
      this.assert(this.chat, "sendMediaGroup");
      return this.telegram.sendMediaGroup(this.chat.id, media, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithMediaGroup(...args) {
      return this.sendMediaGroup(...args);
    }
    sendAudio(audio, extra) {
      this.assert(this.chat, "sendAudio");
      return this.telegram.sendAudio(this.chat.id, audio, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithAudio(...args) {
      return this.sendAudio(...args);
    }
    sendDice(extra) {
      this.assert(this.chat, "sendDice");
      return this.telegram.sendDice(this.chat.id, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithDice(...args) {
      return this.sendDice(...args);
    }
    sendDocument(document2, extra) {
      this.assert(this.chat, "sendDocument");
      return this.telegram.sendDocument(this.chat.id, document2, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithDocument(...args) {
      return this.sendDocument(...args);
    }
    sendSticker(sticker, extra) {
      this.assert(this.chat, "sendSticker");
      return this.telegram.sendSticker(this.chat.id, sticker, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithSticker(...args) {
      return this.sendSticker(...args);
    }
    sendVideo(video, extra) {
      this.assert(this.chat, "sendVideo");
      return this.telegram.sendVideo(this.chat.id, video, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithVideo(...args) {
      return this.sendVideo(...args);
    }
    sendAnimation(animation, extra) {
      this.assert(this.chat, "sendAnimation");
      return this.telegram.sendAnimation(this.chat.id, animation, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithAnimation(...args) {
      return this.sendAnimation(...args);
    }
    sendVideoNote(videoNote, extra) {
      this.assert(this.chat, "sendVideoNote");
      return this.telegram.sendVideoNote(this.chat.id, videoNote, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithVideoNote(...args) {
      return this.sendVideoNote(...args);
    }
    sendInvoice(invoice, extra) {
      this.assert(this.chat, "sendInvoice");
      return this.telegram.sendInvoice(this.chat.id, invoice, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithInvoice(...args) {
      return this.sendInvoice(...args);
    }
    sendGame(game, extra) {
      this.assert(this.chat, "sendGame");
      return this.telegram.sendGame(this.chat.id, game, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithGame(...args) {
      return this.sendGame(...args);
    }
    sendVoice(voice, extra) {
      this.assert(this.chat, "sendVoice");
      return this.telegram.sendVoice(this.chat.id, voice, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithVoice(...args) {
      return this.sendVoice(...args);
    }
    sendPoll(poll, options, extra) {
      this.assert(this.chat, "sendPoll");
      return this.telegram.sendPoll(this.chat.id, poll, options, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithPoll(...args) {
      return this.sendPoll(...args);
    }
    sendQuiz(quiz, options, extra) {
      this.assert(this.chat, "sendQuiz");
      return this.telegram.sendQuiz(this.chat.id, quiz, options, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithQuiz(...args) {
      return this.sendQuiz(...args);
    }
    stopPoll(...args) {
      this.assert(this.chat, "stopPoll");
      return this.telegram.stopPoll(this.chat.id, ...args);
    }
    sendChatAction(action, extra) {
      this.assert(this.chat, "sendChatAction");
      return this.telegram.sendChatAction(this.chat.id, action, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    async persistentChatAction(action, callback, { intervalDuration, ...extra } = {}) {
      await this.sendChatAction(action, { ...extra });
      const timer = setInterval(() => this.sendChatAction(action, { ...extra }).catch((err) => {
        debug("Ignored error while persisting sendChatAction:", err);
      }), intervalDuration !== null && intervalDuration !== undefined ? intervalDuration : 4000);
      try {
        await callback();
      } finally {
        clearInterval(timer);
      }
    }
    replyWithChatAction(...args) {
      return this.sendChatAction(...args);
    }
    react(reaction, is_big) {
      this.assert(this.chat, "setMessageReaction");
      this.assert(this.msgId, "setMessageReaction");
      const emojis = reaction ? Array.isArray(reaction) ? reaction : [reaction] : undefined;
      const reactions = emojis === null || emojis === undefined ? undefined : emojis.map((emoji) => typeof emoji === "string" ? reactions_1.Digit.has(emoji[0]) ? { type: "custom_emoji", custom_emoji_id: emoji } : { type: "emoji", emoji } : emoji);
      return this.telegram.setMessageReaction(this.chat.id, this.msgId, reactions, is_big);
    }
    sendLocation(latitude, longitude, extra) {
      this.assert(this.chat, "sendLocation");
      return this.telegram.sendLocation(this.chat.id, latitude, longitude, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithLocation(...args) {
      return this.sendLocation(...args);
    }
    sendVenue(latitude, longitude, title, address7, extra) {
      this.assert(this.chat, "sendVenue");
      return this.telegram.sendVenue(this.chat.id, latitude, longitude, title, address7, { message_thread_id: getThreadId(this), ...extra });
    }
    replyWithVenue(...args) {
      return this.sendVenue(...args);
    }
    sendContact(phoneNumber, firstName, extra) {
      this.assert(this.chat, "sendContact");
      return this.telegram.sendContact(this.chat.id, phoneNumber, firstName, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithContact(...args) {
      return this.sendContact(...args);
    }
    getStickerSet(setName) {
      return this.telegram.getStickerSet(setName);
    }
    setChatStickerSet(setName) {
      this.assert(this.chat, "setChatStickerSet");
      return this.telegram.setChatStickerSet(this.chat.id, setName);
    }
    deleteChatStickerSet() {
      this.assert(this.chat, "deleteChatStickerSet");
      return this.telegram.deleteChatStickerSet(this.chat.id);
    }
    createForumTopic(...args) {
      this.assert(this.chat, "createForumTopic");
      return this.telegram.createForumTopic(this.chat.id, ...args);
    }
    editForumTopic(extra) {
      var _a4;
      this.assert(this.chat, "editForumTopic");
      this.assert((_a4 = this.message) === null || _a4 === undefined ? undefined : _a4.message_thread_id, "editForumTopic");
      return this.telegram.editForumTopic(this.chat.id, this.message.message_thread_id, extra);
    }
    closeForumTopic() {
      var _a4;
      this.assert(this.chat, "closeForumTopic");
      this.assert((_a4 = this.message) === null || _a4 === undefined ? undefined : _a4.message_thread_id, "closeForumTopic");
      return this.telegram.closeForumTopic(this.chat.id, this.message.message_thread_id);
    }
    reopenForumTopic() {
      var _a4;
      this.assert(this.chat, "reopenForumTopic");
      this.assert((_a4 = this.message) === null || _a4 === undefined ? undefined : _a4.message_thread_id, "reopenForumTopic");
      return this.telegram.reopenForumTopic(this.chat.id, this.message.message_thread_id);
    }
    deleteForumTopic() {
      var _a4;
      this.assert(this.chat, "deleteForumTopic");
      this.assert((_a4 = this.message) === null || _a4 === undefined ? undefined : _a4.message_thread_id, "deleteForumTopic");
      return this.telegram.deleteForumTopic(this.chat.id, this.message.message_thread_id);
    }
    unpinAllForumTopicMessages() {
      var _a4;
      this.assert(this.chat, "unpinAllForumTopicMessages");
      this.assert((_a4 = this.message) === null || _a4 === undefined ? undefined : _a4.message_thread_id, "unpinAllForumTopicMessages");
      return this.telegram.unpinAllForumTopicMessages(this.chat.id, this.message.message_thread_id);
    }
    editGeneralForumTopic(name) {
      this.assert(this.chat, "editGeneralForumTopic");
      return this.telegram.editGeneralForumTopic(this.chat.id, name);
    }
    closeGeneralForumTopic() {
      this.assert(this.chat, "closeGeneralForumTopic");
      return this.telegram.closeGeneralForumTopic(this.chat.id);
    }
    reopenGeneralForumTopic() {
      this.assert(this.chat, "reopenGeneralForumTopic");
      return this.telegram.reopenGeneralForumTopic(this.chat.id);
    }
    hideGeneralForumTopic() {
      this.assert(this.chat, "hideGeneralForumTopic");
      return this.telegram.hideGeneralForumTopic(this.chat.id);
    }
    unhideGeneralForumTopic() {
      this.assert(this.chat, "unhideGeneralForumTopic");
      return this.telegram.unhideGeneralForumTopic(this.chat.id);
    }
    unpinAllGeneralForumTopicMessages() {
      this.assert(this.chat, "unpinAllGeneralForumTopicMessages");
      return this.telegram.unpinAllGeneralForumTopicMessages(this.chat.id);
    }
    setStickerPositionInSet(sticker, position) {
      return this.telegram.setStickerPositionInSet(sticker, position);
    }
    setStickerSetThumb(...args) {
      return this.telegram.setStickerSetThumbnail(...args);
    }
    setStickerSetThumbnail(...args) {
      return this.telegram.setStickerSetThumbnail(...args);
    }
    setStickerMaskPosition(...args) {
      return this.telegram.setStickerMaskPosition(...args);
    }
    setStickerKeywords(...args) {
      return this.telegram.setStickerKeywords(...args);
    }
    setStickerEmojiList(...args) {
      return this.telegram.setStickerEmojiList(...args);
    }
    deleteStickerSet(...args) {
      return this.telegram.deleteStickerSet(...args);
    }
    setStickerSetTitle(...args) {
      return this.telegram.setStickerSetTitle(...args);
    }
    setCustomEmojiStickerSetThumbnail(...args) {
      return this.telegram.setCustomEmojiStickerSetThumbnail(...args);
    }
    deleteStickerFromSet(sticker) {
      return this.telegram.deleteStickerFromSet(sticker);
    }
    uploadStickerFile(...args) {
      this.assert(this.from, "uploadStickerFile");
      return this.telegram.uploadStickerFile(this.from.id, ...args);
    }
    createNewStickerSet(...args) {
      this.assert(this.from, "createNewStickerSet");
      return this.telegram.createNewStickerSet(this.from.id, ...args);
    }
    addStickerToSet(...args) {
      this.assert(this.from, "addStickerToSet");
      return this.telegram.addStickerToSet(this.from.id, ...args);
    }
    getMyCommands() {
      return this.telegram.getMyCommands();
    }
    setMyCommands(commands) {
      return this.telegram.setMyCommands(commands);
    }
    replyWithMarkdown(markdown, extra) {
      return this.reply(markdown, { parse_mode: "Markdown", ...extra });
    }
    replyWithMarkdownV2(markdown, extra) {
      return this.reply(markdown, { parse_mode: "MarkdownV2", ...extra });
    }
    replyWithHTML(html, extra) {
      return this.reply(html, { parse_mode: "HTML", ...extra });
    }
    deleteMessage(messageId) {
      this.assert(this.chat, "deleteMessage");
      if (typeof messageId !== "undefined")
        return this.telegram.deleteMessage(this.chat.id, messageId);
      this.assert(this.msgId, "deleteMessage");
      return this.telegram.deleteMessage(this.chat.id, this.msgId);
    }
    deleteMessages(messageIds) {
      this.assert(this.chat, "deleteMessages");
      return this.telegram.deleteMessages(this.chat.id, messageIds);
    }
    forwardMessage(chatId, extra) {
      this.assert(this.chat, "forwardMessage");
      this.assert(this.msgId, "forwardMessage");
      return this.telegram.forwardMessage(chatId, this.chat.id, this.msgId, extra);
    }
    forwardMessages(chatId, messageIds, extra) {
      this.assert(this.chat, "forwardMessages");
      return this.telegram.forwardMessages(chatId, this.chat.id, messageIds, extra);
    }
    copyMessage(chatId, extra) {
      this.assert(this.chat, "copyMessage");
      this.assert(this.msgId, "copyMessage");
      return this.telegram.copyMessage(chatId, this.chat.id, this.msgId, extra);
    }
    copyMessages(chatId, messageIds, extra) {
      var _a4;
      this.assert(this.chat, "copyMessages");
      return this.telegram.copyMessages(chatId, (_a4 = this.chat) === null || _a4 === undefined ? undefined : _a4.id, messageIds, extra);
    }
    approveChatJoinRequest(userId) {
      this.assert(this.chat, "approveChatJoinRequest");
      return this.telegram.approveChatJoinRequest(this.chat.id, userId);
    }
    declineChatJoinRequest(userId) {
      this.assert(this.chat, "declineChatJoinRequest");
      return this.telegram.declineChatJoinRequest(this.chat.id, userId);
    }
    banChatSenderChat(senderChatId) {
      this.assert(this.chat, "banChatSenderChat");
      return this.telegram.banChatSenderChat(this.chat.id, senderChatId);
    }
    unbanChatSenderChat(senderChatId) {
      this.assert(this.chat, "unbanChatSenderChat");
      return this.telegram.unbanChatSenderChat(this.chat.id, senderChatId);
    }
    setChatMenuButton(menuButton) {
      this.assert(this.chat, "setChatMenuButton");
      return this.telegram.setChatMenuButton({ chatId: this.chat.id, menuButton });
    }
    getChatMenuButton() {
      this.assert(this.chat, "getChatMenuButton");
      return this.telegram.getChatMenuButton({ chatId: this.chat.id });
    }
    setMyDefaultAdministratorRights(extra) {
      return this.telegram.setMyDefaultAdministratorRights(extra);
    }
    getMyDefaultAdministratorRights(extra) {
      return this.telegram.getMyDefaultAdministratorRights(extra);
    }
  }
  exports.Context = Context;
  exports.default = Context;
  var Msg = {
    isAccessible() {
      return "date" in this && this.date !== 0;
    },
    has(...keys) {
      return keys.some((key) => this[key] != null);
    }
  };
  var getThreadId = (ctx) => {
    const msg = ctx.msg;
    return (msg === null || msg === undefined ? undefined : msg.isAccessible()) ? msg.is_topic_message ? msg.message_thread_id : undefined : undefined;
  };
});

// node_modules/telegraf/lib/filters.js
var require_filters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.allOf = exports.anyOf = exports.callbackQuery = exports.editedChannelPost = exports.channelPost = exports.editedMessage = exports.message = undefined;
  var message = (...keys) => (update) => {
    if (!("message" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.message))
        return false;
    }
    return true;
  };
  exports.message = message;
  var editedMessage = (...keys) => (update) => {
    if (!("edited_message" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.edited_message))
        return false;
    }
    return true;
  };
  exports.editedMessage = editedMessage;
  var channelPost = (...keys) => (update) => {
    if (!("channel_post" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.channel_post))
        return false;
    }
    return true;
  };
  exports.channelPost = channelPost;
  var editedChannelPost = (...keys) => (update) => {
    if (!("edited_channel_post" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.edited_channel_post))
        return false;
    }
    return true;
  };
  exports.editedChannelPost = editedChannelPost;
  var callbackQuery = (...keys) => (update) => {
    if (!("callback_query" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.callback_query))
        return false;
    }
    return true;
  };
  exports.callbackQuery = callbackQuery;
  var anyOf = (...filters) => (update) => {
    for (const filter3 of filters)
      if (filter3(update))
        return true;
    return false;
  };
  exports.anyOf = anyOf;
  var allOf = (...filters) => (update) => {
    for (const filter3 of filters)
      if (!filter3(update))
        return false;
    return true;
  };
  exports.allOf = allOf;
});

// node_modules/telegraf/lib/core/helpers/args.js
var require_args = __commonJS((exports) => {
  var argsParser = function(str, entities = [], entityOffset = 0) {
    const mentions = {};
    for (const entity of entities)
      if (entity.type === "text_mention" || entity.type === "text_link")
        mentions[entity.offset - entityOffset] = entity.length;
    const args = [];
    let done = 0;
    let inside = undefined;
    let buf = "";
    function flush(to) {
      if (done !== to)
        args.push(buf + str.slice(done, to)), inside = undefined;
      buf = "";
      done = to + 1;
    }
    for (let i = 0;i < str.length; i++) {
      const char = str[i];
      const mention = mentions[i];
      if (mention) {
        flush(i);
        done--;
        i += mention;
        flush(i);
      } else if (char === SINGLE_QUOTE || char === DOUBLE_QUOTE)
        if (inside)
          if (inside === char)
            flush(i);
          else
            continue;
        else
          flush(i), inside = char;
      else if (char === " ")
        if (inside)
          continue;
        else
          flush(i);
      else if (char === "\n")
        flush(i);
      else if (char === "\\")
        buf += str.slice(done, i), done = ++i;
      else
        continue;
    }
    if (done < str.length)
      flush(str.length);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argsParser = undefined;
  var SINGLE_QUOTE = "'";
  var DOUBLE_QUOTE = '"';
  exports.argsParser = argsParser;
});

// node_modules/telegraf/lib/composer.js
var require_composer = __commonJS((exports) => {
  var always = function(x) {
    return () => x;
  };
  var escapeRegExp = function(s) {
    return s.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
  };
  var normaliseTriggers = function(triggers) {
    if (!Array.isArray(triggers))
      triggers = [triggers];
    return triggers.map((trigger) => {
      if (!trigger)
        throw new Error("Invalid trigger");
      if (typeof trigger === "function")
        return trigger;
      if (trigger instanceof RegExp)
        return (value = "") => {
          trigger.lastIndex = 0;
          return trigger.exec(value);
        };
      const regex = new RegExp(`^${escapeRegExp(trigger)}\$`);
      return (value) => regex.exec(value);
    });
  };
  var getEntities = function(msg) {
    var _a4, _b;
    if (msg == null)
      return [];
    if ("caption_entities" in msg)
      return (_a4 = msg.caption_entities) !== null && _a4 !== undefined ? _a4 : [];
    if ("entities" in msg)
      return (_b = msg.entities) !== null && _b !== undefined ? _b : [];
    return [];
  };
  var getText = function(msg) {
    if (msg == null)
      return;
    if ("caption" in msg)
      return msg.caption;
    if ("text" in msg)
      return msg.text;
    if ("data" in msg)
      return msg.data;
    if ("game_short_name" in msg)
      return msg.game_short_name;
    return;
  };
  var normaliseTextArguments = function(argument, prefix = "") {
    const args = Array.isArray(argument) ? argument : [argument];
    return args.filter(Boolean).map((arg) => prefix && typeof arg === "string" && !arg.startsWith(prefix) ? `${prefix}${arg}` : arg);
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Composer = undefined;
  var context_1 = __importDefault(require_context());
  var filters_1 = require_filters();
  var args_1 = require_args();
  var anoop = always(Promise.resolve());

  class Composer {
    constructor(...fns) {
      this.handler = Composer.compose(fns);
    }
    use(...fns) {
      this.handler = Composer.compose([this.handler, ...fns]);
      return this;
    }
    guard(guardFn, ...fns) {
      return this.use(Composer.guard(guardFn, ...fns));
    }
    on(filters, ...fns) {
      return this.use(Composer.on(filters, ...fns));
    }
    hears(triggers, ...fns) {
      return this.use(Composer.hears(triggers, ...fns));
    }
    command(command, ...fns) {
      return this.use(Composer.command(command, ...fns));
    }
    action(triggers, ...fns) {
      return this.use(Composer.action(triggers, ...fns));
    }
    inlineQuery(triggers, ...fns) {
      return this.use(Composer.inlineQuery(triggers, ...fns));
    }
    gameQuery(...fns) {
      return this.use(Composer.gameQuery(...fns));
    }
    reaction(reaction, ...fns) {
      return this.use(Composer.reaction(reaction, ...fns));
    }
    drop(predicate) {
      return this.use(Composer.drop(predicate));
    }
    filter(predicate) {
      return this.use(Composer.filter(predicate));
    }
    entity(predicate, ...fns) {
      return this.use(Composer.entity(predicate, ...fns));
    }
    email(email, ...fns) {
      return this.use(Composer.email(email, ...fns));
    }
    url(url, ...fns) {
      return this.use(Composer.url(url, ...fns));
    }
    textLink(link, ...fns) {
      return this.use(Composer.textLink(link, ...fns));
    }
    textMention(mention, ...fns) {
      return this.use(Composer.textMention(mention, ...fns));
    }
    mention(mention, ...fns) {
      return this.use(Composer.mention(mention, ...fns));
    }
    phone(number8, ...fns) {
      return this.use(Composer.phone(number8, ...fns));
    }
    hashtag(hashtag, ...fns) {
      return this.use(Composer.hashtag(hashtag, ...fns));
    }
    cashtag(cashtag, ...fns) {
      return this.use(Composer.cashtag(cashtag, ...fns));
    }
    spoiler(text, ...fns) {
      return this.use(Composer.spoiler(text, ...fns));
    }
    start(...fns) {
      const handler = Composer.compose(fns);
      return this.command("start", (ctx, next) => handler(Object.assign(ctx, { startPayload: ctx.payload }), next));
    }
    help(...fns) {
      return this.command("help", ...fns);
    }
    settings(...fns) {
      return this.command("settings", ...fns);
    }
    middleware() {
      return this.handler;
    }
    static reply(...args) {
      return (ctx) => ctx.reply(...args);
    }
    static catch(errorHandler, ...fns) {
      const handler = Composer.compose(fns);
      return (ctx, next) => Promise.resolve(handler(ctx, next)).catch((err) => errorHandler(err, ctx));
    }
    static fork(middleware) {
      const handler = Composer.unwrap(middleware);
      return async (ctx, next) => {
        await Promise.all([handler(ctx, anoop), next()]);
      };
    }
    static tap(middleware) {
      const handler = Composer.unwrap(middleware);
      return (ctx, next) => Promise.resolve(handler(ctx, anoop)).then(() => next());
    }
    static passThru() {
      return (ctx, next) => next();
    }
    static lazy(factoryFn) {
      if (typeof factoryFn !== "function") {
        throw new Error("Argument must be a function");
      }
      return (ctx, next) => Promise.resolve(factoryFn(ctx)).then((middleware) => Composer.unwrap(middleware)(ctx, next));
    }
    static log(logFn = console.log) {
      return (ctx, next) => {
        logFn(JSON.stringify(ctx.update, null, 2));
        return next();
      };
    }
    static branch(predicate, trueMiddleware, falseMiddleware) {
      if (typeof predicate !== "function") {
        return Composer.unwrap(predicate ? trueMiddleware : falseMiddleware);
      }
      return Composer.lazy((ctx) => Promise.resolve(predicate(ctx)).then((value) => value ? trueMiddleware : falseMiddleware));
    }
    static optional(predicate, ...fns) {
      return Composer.branch(predicate, Composer.compose(fns), Composer.passThru());
    }
    static filter(predicate) {
      return Composer.branch(predicate, Composer.passThru(), anoop);
    }
    static drop(predicate) {
      return Composer.branch(predicate, anoop, Composer.passThru());
    }
    static dispatch(routeFn, handlers) {
      return Composer.lazy((ctx) => Promise.resolve(routeFn(ctx)).then((value) => handlers[value]));
    }
    static guard(guardFn, ...fns) {
      return Composer.optional((ctx) => guardFn(ctx.update), ...fns);
    }
    static on(updateType, ...fns) {
      const filters = Array.isArray(updateType) ? updateType : [updateType];
      const predicate = (update) => {
        for (const filter3 of filters) {
          if (typeof filter3 !== "string" ? filter3(update) : (filter3 in update) || ("message" in update) && (filter3 in update.message)) {
            return true;
          }
        }
        return false;
      };
      return Composer.optional((ctx) => predicate(ctx.update), ...fns);
    }
    static entity(predicate, ...fns) {
      if (typeof predicate !== "function") {
        const entityTypes = normaliseTextArguments(predicate);
        return Composer.entity(({ type }) => entityTypes.includes(type), ...fns);
      }
      return Composer.optional((ctx) => {
        var _a4;
        const msg = (_a4 = ctx.message) !== null && _a4 !== undefined ? _a4 : ctx.channelPost;
        if (msg === undefined) {
          return false;
        }
        const text = getText(msg);
        const entities = getEntities(msg);
        if (text === undefined)
          return false;
        return entities.some((entity) => predicate(entity, text.substring(entity.offset, entity.offset + entity.length), ctx));
      }, ...fns);
    }
    static entityText(entityType, predicate, ...fns) {
      if (fns.length === 0) {
        return Array.isArray(predicate) ? Composer.entity(entityType, ...predicate) : Composer.entity(entityType, predicate);
      }
      const triggers = normaliseTriggers(predicate);
      return Composer.entity(({ type }, value, ctx) => {
        if (type !== entityType) {
          return false;
        }
        for (const trigger of triggers) {
          if (ctx.match = trigger(value, ctx)) {
            return true;
          }
        }
        return false;
      }, ...fns);
    }
    static email(email, ...fns) {
      return Composer.entityText("email", email, ...fns);
    }
    static phone(number8, ...fns) {
      return Composer.entityText("phone_number", number8, ...fns);
    }
    static url(url, ...fns) {
      return Composer.entityText("url", url, ...fns);
    }
    static textLink(link, ...fns) {
      return Composer.entityText("text_link", link, ...fns);
    }
    static textMention(mention, ...fns) {
      return Composer.entityText("text_mention", mention, ...fns);
    }
    static mention(mention, ...fns) {
      return Composer.entityText("mention", normaliseTextArguments(mention, "@"), ...fns);
    }
    static hashtag(hashtag, ...fns) {
      return Composer.entityText("hashtag", normaliseTextArguments(hashtag, "#"), ...fns);
    }
    static cashtag(cashtag, ...fns) {
      return Composer.entityText("cashtag", normaliseTextArguments(cashtag, "$"), ...fns);
    }
    static spoiler(text, ...fns) {
      return Composer.entityText("spoiler", text, ...fns);
    }
    static match(triggers, ...fns) {
      const handler = Composer.compose(fns);
      return (ctx, next) => {
        var _a4, _b, _c, _d;
        const text = (_c = (_b = (_a4 = getText(ctx.message)) !== null && _a4 !== undefined ? _a4 : getText(ctx.channelPost)) !== null && _b !== undefined ? _b : getText(ctx.callbackQuery)) !== null && _c !== undefined ? _c : (_d = ctx.inlineQuery) === null || _d === undefined ? undefined : _d.query;
        if (text === undefined)
          return next();
        for (const trigger of triggers) {
          const match = trigger(text, ctx);
          if (match)
            return handler(Object.assign(ctx, { match }), next);
        }
        return next();
      };
    }
    static hears(triggers, ...fns) {
      return Composer.on("text", Composer.match(normaliseTriggers(triggers), ...fns));
    }
    static command(command, ...fns) {
      if (fns.length === 0)
        return Composer.entity("bot_command", command);
      const triggers = normaliseTriggers(command);
      const filter3 = (0, filters_1.message)("text");
      const handler = Composer.compose(fns);
      return Composer.on(filter3, (ctx, next) => {
        const { entities } = ctx.message;
        const cmdEntity = entities === null || entities === undefined ? undefined : entities[0];
        if ((cmdEntity === null || cmdEntity === undefined ? undefined : cmdEntity.type) !== "bot_command")
          return next();
        if (cmdEntity.offset > 0)
          return next();
        const len = cmdEntity.length;
        const text = ctx.message.text;
        const [cmdPart, to] = text.slice(0, len).split("@");
        if (!cmdPart)
          return next();
        if (to && to.toLowerCase() !== ctx.me.toLowerCase())
          return next();
        const command2 = cmdPart.slice(1);
        for (const trigger of triggers) {
          const match = trigger(command2, ctx);
          if (match) {
            const payloadOffset = len + 1;
            const payload = text.slice(payloadOffset);
            const c = Object.assign(ctx, { match, command: command2, payload, args: [] });
            let _args = undefined;
            Object.defineProperty(c, "args", {
              enumerable: true,
              configurable: true,
              get() {
                if (_args != null)
                  return _args;
                return _args = (0, args_1.argsParser)(payload, entities, payloadOffset);
              },
              set(args) {
                _args = args;
              }
            });
            return handler(c, next);
          }
        }
        return next();
      });
    }
    static action(triggers, ...fns) {
      return Composer.on("callback_query", Composer.match(normaliseTriggers(triggers), ...fns));
    }
    static inlineQuery(triggers, ...fns) {
      return Composer.on("inline_query", Composer.match(normaliseTriggers(triggers), ...fns));
    }
    static reaction(reaction, ...fns) {
      const reactions = Array.isArray(reaction) ? reaction : [reaction];
      const handler = Composer.compose(fns);
      return Composer.on("message_reaction", (ctx, next) => {
        const match = reactions.find((r) => typeof r === "string" && r.startsWith("-") ? ctx.reactions.removed.has(r.slice(1)) : ctx.reactions.added.has(r));
        if (match)
          return handler(Object.assign(ctx, { match }), next);
        return next();
      });
    }
    static acl(userId, ...fns) {
      if (typeof userId === "function") {
        return Composer.optional(userId, ...fns);
      }
      const allowed = Array.isArray(userId) ? userId : [userId];
      return Composer.optional((ctx) => !ctx.from || allowed.includes(ctx.from.id), ...fns);
    }
    static memberStatus(status, ...fns) {
      const statuses = Array.isArray(status) ? status : [status];
      return Composer.optional(async (ctx) => {
        if (ctx.message === undefined)
          return false;
        const member = await ctx.getChatMember(ctx.message.from.id);
        return statuses.includes(member.status);
      }, ...fns);
    }
    static admin(...fns) {
      return Composer.memberStatus(["administrator", "creator"], ...fns);
    }
    static creator(...fns) {
      return Composer.memberStatus("creator", ...fns);
    }
    static chatType(type, ...fns) {
      const types15 = Array.isArray(type) ? type : [type];
      return Composer.optional((ctx) => {
        const chat = ctx.chat;
        return chat !== undefined && types15.includes(chat.type);
      }, ...fns);
    }
    static privateChat(...fns) {
      return Composer.chatType("private", ...fns);
    }
    static groupChat(...fns) {
      return Composer.chatType(["group", "supergroup"], ...fns);
    }
    static gameQuery(...fns) {
      return Composer.guard((0, filters_1.callbackQuery)("game_short_name"), ...fns);
    }
    static unwrap(handler) {
      if (!handler) {
        throw new Error("Handler is undefined");
      }
      return "middleware" in handler ? handler.middleware() : handler;
    }
    static compose(middlewares) {
      if (!Array.isArray(middlewares)) {
        throw new Error("Middlewares must be an array");
      }
      if (middlewares.length === 0) {
        return Composer.passThru();
      }
      if (middlewares.length === 1) {
        return Composer.unwrap(middlewares[0]);
      }
      return (ctx, next) => {
        let index = -1;
        return execute(0, ctx);
        async function execute(i, context) {
          var _a4;
          if (!(context instanceof context_1.default)) {
            throw new Error("next(ctx) called with invalid context");
          }
          if (i <= index) {
            throw new Error("next() called multiple times");
          }
          index = i;
          const handler = Composer.unwrap((_a4 = middlewares[i]) !== null && _a4 !== undefined ? _a4 : next);
          await handler(context, async (ctx2 = context) => {
            await execute(i + 1, ctx2);
          });
        }
      };
    }
  }
  exports.Composer = Composer;
  Composer.mount = Composer.on;
  exports.default = Composer;
});

// node_modules/telegraf/lib/core/helpers/compact.js
var require_compact = __commonJS((exports) => {
  var compactOptions = function(options) {
    if (!options) {
      return options;
    }
    const compacted = {};
    for (const key in options)
      if (Object.prototype.hasOwnProperty.call(options, key) && options[key] !== undefined)
        compacted[key] = options[key];
    return compacted;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compactOptions = undefined;
  exports.compactOptions = compactOptions;
});

// node_modules/telegraf/lib/core/network/webhook.js
var require_webhook = __commonJS((exports) => {
  var generateWebhook = function(filter3, updateHandler) {
    return async (req, res, next = () => {
      res.statusCode = 403;
      debug("Replying with status code", res.statusCode);
      res.end();
    }) => {
      debug("Incoming request", req.method, req.url);
      if (!filter3(req)) {
        debug("Webhook filter failed", req.method, req.url);
        return next();
      }
      let update;
      try {
        if (req.body != null) {
          let body = req.body;
          if (body instanceof Buffer)
            body = String(req.body);
          if (typeof body === "string")
            body = JSON.parse(body);
          update = body;
        } else {
          let body = "";
          for await (const chunk of req)
            body += String(chunk);
          update = JSON.parse(body);
        }
      } catch (error) {
        res.writeHead(415).end();
        debug("Failed to parse request body:", error);
        return;
      }
      return await updateHandler(update, res);
    };
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var debug_1 = __importDefault(require_src());
  var debug = (0, debug_1.default)("telegraf:webhook");
  exports.default = generateWebhook;
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS((exports, module) => {
  var pd = function(event) {
    const retv = privateData.get(event);
    console.assert(retv != null, "'this' is expected an Event object, but got", event);
    return retv;
  };
  var setCancelFlag = function(data) {
    if (data.passiveListener != null) {
      if (typeof console !== "undefined" && typeof console.error === "function") {
        console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
      }
      return;
    }
    if (!data.event.cancelable) {
      return;
    }
    data.canceled = true;
    if (typeof data.event.preventDefault === "function") {
      data.event.preventDefault();
    }
  };
  var Event2 = function(eventTarget, event) {
    privateData.set(this, {
      eventTarget,
      event,
      eventPhase: 2,
      currentTarget: eventTarget,
      canceled: false,
      stopped: false,
      immediateStopped: false,
      passiveListener: null,
      timeStamp: event.timeStamp || Date.now()
    });
    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
    const keys = Object.keys(event);
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (!(key in this)) {
        Object.defineProperty(this, key, defineRedirectDescriptor(key));
      }
    }
  };
  var defineRedirectDescriptor = function(key) {
    return {
      get() {
        return pd(this).event[key];
      },
      set(value) {
        pd(this).event[key] = value;
      },
      configurable: true,
      enumerable: true
    };
  };
  var defineCallDescriptor = function(key) {
    return {
      value() {
        const event = pd(this).event;
        return event[key].apply(event, arguments);
      },
      configurable: true,
      enumerable: true
    };
  };
  var defineWrapper = function(BaseEvent, proto) {
    const keys = Object.keys(proto);
    if (keys.length === 0) {
      return BaseEvent;
    }
    function CustomEvent2(eventTarget, event) {
      BaseEvent.call(this, eventTarget, event);
    }
    CustomEvent2.prototype = Object.create(BaseEvent.prototype, {
      constructor: { value: CustomEvent2, configurable: true, writable: true }
    });
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (!(key in BaseEvent.prototype)) {
        const descriptor = Object.getOwnPropertyDescriptor(proto, key);
        const isFunc = typeof descriptor.value === "function";
        Object.defineProperty(CustomEvent2.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
      }
    }
    return CustomEvent2;
  };
  var getWrapper = function(proto) {
    if (proto == null || proto === Object.prototype) {
      return Event2;
    }
    let wrapper = wrappers.get(proto);
    if (wrapper == null) {
      wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
      wrappers.set(proto, wrapper);
    }
    return wrapper;
  };
  var wrapEvent = function(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event);
  };
  var isStopped = function(event) {
    return pd(event).immediateStopped;
  };
  var setEventPhase = function(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
  };
  var setCurrentTarget = function(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
  };
  var setPassiveListener = function(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
  };
  var isObject2 = function(x) {
    return x !== null && typeof x === "object";
  };
  var getListeners = function(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
      throw new TypeError("'this' is expected an EventTarget object, but got another value.");
    }
    return listeners;
  };
  var defineEventAttributeDescriptor = function(eventName) {
    return {
      get() {
        const listeners = getListeners(this);
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE) {
            return node.listener;
          }
          node = node.next;
        }
        return null;
      },
      set(listener) {
        if (typeof listener !== "function" && !isObject2(listener)) {
          listener = null;
        }
        const listeners = getListeners(this);
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          node = node.next;
        }
        if (listener !== null) {
          const newNode = {
            listener,
            listenerType: ATTRIBUTE,
            passive: false,
            once: false,
            next: null
          };
          if (prev === null) {
            listeners.set(eventName, newNode);
          } else {
            prev.next = newNode;
          }
        }
      },
      configurable: true,
      enumerable: true
    };
  };
  var defineEventAttribute = function(eventTargetPrototype, eventName) {
    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
  };
  var defineCustomEventTarget = function(eventNames) {
    function CustomEventTarget() {
      EventTarget.call(this);
    }
    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
      constructor: {
        value: CustomEventTarget,
        configurable: true,
        writable: true
      }
    });
    for (let i = 0;i < eventNames.length; ++i) {
      defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    }
    return CustomEventTarget;
  };
  var EventTarget = function() {
    if (this instanceof EventTarget) {
      listenersMap.set(this, new Map);
      return;
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
      return defineCustomEventTarget(arguments[0]);
    }
    if (arguments.length > 0) {
      const types15 = new Array(arguments.length);
      for (let i = 0;i < arguments.length; ++i) {
        types15[i] = arguments[i];
      }
      return defineCustomEventTarget(types15);
    }
    throw new TypeError("Cannot call a class as a function");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var privateData = new WeakMap;
  var wrappers = new WeakMap;
  Event2.prototype = {
    get type() {
      return pd(this).event.type;
    },
    get target() {
      return pd(this).eventTarget;
    },
    get currentTarget() {
      return pd(this).currentTarget;
    },
    composedPath() {
      const currentTarget = pd(this).currentTarget;
      if (currentTarget == null) {
        return [];
      }
      return [currentTarget];
    },
    get NONE() {
      return 0;
    },
    get CAPTURING_PHASE() {
      return 1;
    },
    get AT_TARGET() {
      return 2;
    },
    get BUBBLING_PHASE() {
      return 3;
    },
    get eventPhase() {
      return pd(this).eventPhase;
    },
    stopPropagation() {
      const data = pd(this);
      data.stopped = true;
      if (typeof data.event.stopPropagation === "function") {
        data.event.stopPropagation();
      }
    },
    stopImmediatePropagation() {
      const data = pd(this);
      data.stopped = true;
      data.immediateStopped = true;
      if (typeof data.event.stopImmediatePropagation === "function") {
        data.event.stopImmediatePropagation();
      }
    },
    get bubbles() {
      return Boolean(pd(this).event.bubbles);
    },
    get cancelable() {
      return Boolean(pd(this).event.cancelable);
    },
    preventDefault() {
      setCancelFlag(pd(this));
    },
    get defaultPrevented() {
      return pd(this).canceled;
    },
    get composed() {
      return Boolean(pd(this).event.composed);
    },
    get timeStamp() {
      return pd(this).timeStamp;
    },
    get srcElement() {
      return pd(this).eventTarget;
    },
    get cancelBubble() {
      return pd(this).stopped;
    },
    set cancelBubble(value) {
      if (!value) {
        return;
      }
      const data = pd(this);
      data.stopped = true;
      if (typeof data.event.cancelBubble === "boolean") {
        data.event.cancelBubble = true;
      }
    },
    get returnValue() {
      return !pd(this).canceled;
    },
    set returnValue(value) {
      if (!value) {
        setCancelFlag(pd(this));
      }
    },
    initEvent() {
    }
  };
  Object.defineProperty(Event2.prototype, "constructor", {
    value: Event2,
    configurable: true,
    writable: true
  });
  if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event2.prototype, window.Event.prototype);
    wrappers.set(window.Event.prototype, Event2);
  }
  var listenersMap = new WeakMap;
  var CAPTURE = 1;
  var BUBBLE = 2;
  var ATTRIBUTE = 3;
  EventTarget.prototype = {
    addEventListener(eventName, listener, options) {
      if (listener == null) {
        return;
      }
      if (typeof listener !== "function" && !isObject2(listener)) {
        throw new TypeError("'listener' should be a function or an object.");
      }
      const listeners = getListeners(this);
      const optionsIsObj = isObject2(options);
      const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
      const listenerType = capture ? CAPTURE : BUBBLE;
      const newNode = {
        listener,
        listenerType,
        passive: optionsIsObj && Boolean(options.passive),
        once: optionsIsObj && Boolean(options.once),
        next: null
      };
      let node = listeners.get(eventName);
      if (node === undefined) {
        listeners.set(eventName, newNode);
        return;
      }
      let prev = null;
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          return;
        }
        prev = node;
        node = node.next;
      }
      prev.next = newNode;
    },
    removeEventListener(eventName, listener, options) {
      if (listener == null) {
        return;
      }
      const listeners = getListeners(this);
      const capture = isObject2(options) ? Boolean(options.capture) : Boolean(options);
      const listenerType = capture ? CAPTURE : BUBBLE;
      let prev = null;
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
          return;
        }
        prev = node;
        node = node.next;
      }
    },
    dispatchEvent(event) {
      if (event == null || typeof event.type !== "string") {
        throw new TypeError('"event.type" should be a string.');
      }
      const listeners = getListeners(this);
      const eventName = event.type;
      let node = listeners.get(eventName);
      if (node == null) {
        return true;
      }
      const wrappedEvent = wrapEvent(this, event);
      let prev = null;
      while (node != null) {
        if (node.once) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
        } else {
          prev = node;
        }
        setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
        if (typeof node.listener === "function") {
          try {
            node.listener.call(this, wrappedEvent);
          } catch (err) {
            if (typeof console !== "undefined" && typeof console.error === "function") {
              console.error(err);
            }
          }
        } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
          node.listener.handleEvent(wrappedEvent);
        }
        if (isStopped(wrappedEvent)) {
          break;
        }
        node = node.next;
      }
      setPassiveListener(wrappedEvent, null);
      setEventPhase(wrappedEvent, 0);
      setCurrentTarget(wrappedEvent, null);
      return !wrappedEvent.defaultPrevented;
    }
  };
  Object.defineProperty(EventTarget.prototype, "constructor", {
    value: EventTarget,
    configurable: true,
    writable: true
  });
  if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
  }
  exports.defineEventAttribute = defineEventAttribute;
  exports.EventTarget = EventTarget;
  exports.default = EventTarget;
  module.exports = EventTarget;
  module.exports.EventTarget = module.exports["default"] = EventTarget;
  module.exports.defineEventAttribute = defineEventAttribute;
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS((exports, module) => {
  var createAbortSignal = function() {
    const signal = Object.create(AbortSignal.prototype);
    eventTargetShim.EventTarget.call(signal);
    abortedFlags.set(signal, false);
    return signal;
  };
  var abortSignal = function(signal) {
    if (abortedFlags.get(signal) !== false) {
      return;
    }
    abortedFlags.set(signal, true);
    signal.dispatchEvent({ type: "abort" });
  };
  var getSignal = function(controller) {
    const signal = signals.get(controller);
    if (signal == null) {
      throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
    }
    return signal;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var eventTargetShim = require_event_target_shim();

  class AbortSignal extends eventTargetShim.EventTarget {
    constructor() {
      super();
      throw new TypeError("AbortSignal cannot be constructed directly");
    }
    get aborted() {
      const aborted = abortedFlags.get(this);
      if (typeof aborted !== "boolean") {
        throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
      }
      return aborted;
    }
  }
  eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
  var abortedFlags = new WeakMap;
  Object.defineProperties(AbortSignal.prototype, {
    aborted: { enumerable: true }
  });
  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
      configurable: true,
      value: "AbortSignal"
    });
  }

  class AbortController {
    constructor() {
      signals.set(this, createAbortSignal());
    }
    get signal() {
      return getSignal(this);
    }
    abort() {
      abortSignal(getSignal(this));
    }
  }
  var signals = new WeakMap;
  Object.defineProperties(AbortController.prototype, {
    signal: { enumerable: true },
    abort: { enumerable: true }
  });
  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
      configurable: true,
      value: "AbortController"
    });
  }
  exports.AbortController = AbortController;
  exports.AbortSignal = AbortSignal;
  exports.default = AbortController;
  module.exports = AbortController;
  module.exports.AbortController = module.exports["default"] = AbortController;
  module.exports.AbortSignal = AbortSignal;
});

// node_modules/telegraf/lib/core/network/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TelegramError = undefined;

  class TelegramError extends Error {
    constructor(response, on = {}) {
      super(`${response.error_code}: ${response.description}`);
      this.response = response;
      this.on = on;
    }
    get code() {
      return this.response.error_code;
    }
    get description() {
      return this.response.description;
    }
    get parameters() {
      return this.response.parameters;
    }
  }
  exports.TelegramError = TelegramError;
  exports.default = TelegramError;
});

// node_modules/telegraf/lib/core/network/polling.js
var require_polling = __commonJS((exports) => {
  var always = function(x) {
    return () => x;
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Polling = undefined;
  var abort_controller_1 = __importDefault(require_abort_controller());
  var debug_1 = __importDefault(require_src());
  var util_1 = import.meta.require("util");
  var error_1 = require_error();
  var debug = (0, debug_1.default)("telegraf:polling");
  var wait = (0, util_1.promisify)(setTimeout);
  var noop = always(Promise.resolve());

  class Polling {
    constructor(telegram, allowedUpdates) {
      this.telegram = telegram;
      this.allowedUpdates = allowedUpdates;
      this.abortController = new abort_controller_1.default;
      this.skipOffsetSync = false;
      this.offset = 0;
    }
    async* [Symbol.asyncIterator]() {
      var _a4, _b;
      debug("Starting long polling");
      do {
        try {
          const updates = await this.telegram.callApi("getUpdates", {
            timeout: 50,
            offset: this.offset,
            allowed_updates: this.allowedUpdates
          }, this.abortController);
          const last = updates[updates.length - 1];
          if (last !== undefined) {
            this.offset = last.update_id + 1;
          }
          yield updates;
        } catch (error) {
          const err = error;
          if (err.name === "AbortError")
            return;
          if (err.name === "FetchError" || err instanceof error_1.TelegramError && err.code === 429 || err instanceof error_1.TelegramError && err.code >= 500) {
            const retryAfter = (_b = (_a4 = err.parameters) === null || _a4 === undefined ? undefined : _a4.retry_after) !== null && _b !== undefined ? _b : 5;
            debug("Failed to fetch updates, retrying after %ds.", retryAfter, err);
            await wait(retryAfter * 1000);
            continue;
          }
          if (err instanceof error_1.TelegramError && (err.code === 401 || err.code === 409)) {
            this.skipOffsetSync = true;
            throw err;
          }
          throw err;
        }
      } while (!this.abortController.signal.aborted);
    }
    async syncUpdateOffset() {
      if (this.skipOffsetSync)
        return;
      debug("Syncing update offset...");
      await this.telegram.callApi("getUpdates", { offset: this.offset, limit: 1 });
    }
    async loop(handleUpdate) {
      if (this.abortController.signal.aborted)
        throw new Error("Polling instances must not be reused!");
      try {
        for await (const updates of this)
          await Promise.all(updates.map(handleUpdate));
      } finally {
        debug("Long polling stopped");
        this.stop();
        await this.syncUpdateOffset().catch(noop);
      }
    }
    stop() {
      this.abortController.abort();
    }
  }
  exports.Polling = Polling;
});

// node_modules/p-timeout/index.js
var require_p_timeout = __commonJS((exports, module) => {
  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  }
  var pTimeout = (promise, milliseconds, fallback, options) => {
    let timer;
    const cancelablePromise = new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve(promise);
        return;
      }
      options = {
        customTimers: { setTimeout, clearTimeout },
        ...options
      };
      timer = options.customTimers.setTimeout.call(undefined, () => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      (async () => {
        try {
          resolve(await promise);
        } catch (error) {
          reject(error);
        } finally {
          options.customTimers.clearTimeout.call(undefined, timer);
        }
      })();
    });
    cancelablePromise.clear = () => {
      clearTimeout(timer);
      timer = undefined;
    };
    return cancelablePromise;
  };
  module.exports = pTimeout;
  module.exports.default = pTimeout;
  module.exports.TimeoutError = TimeoutError;
});

// node_modules/telegraf/lib/core/helpers/check.js
var require_check = __commonJS((exports) => {
  var hasProp = function(obj, prop) {
    return obj !== undefined && prop in obj;
  };
  var hasPropType = function(obj, prop, type) {
    return hasProp(obj, prop) && type === typeof obj[prop];
  };
  var is2D = function(arr) {
    return Array.isArray(arr[0]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.is2D = exports.hasPropType = exports.hasProp = undefined;
  exports.hasProp = hasProp;
  exports.hasPropType = hasPropType;
  exports.is2D = is2D;
});

// node_modules/sandwich-stream/dist/sandwich-stream.js
var require_sandwich_stream = __commonJS((exports) => {
  var __rest2 = function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
      for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++)
        if (e.indexOf(p[i]) < 0)
          t[p[i]] = s[p[i]];
    }
    return t;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream = import.meta.require("stream");
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  class SandwichStream extends stream.Readable {
    constructor(_a4) {
      var { head, tail, separator } = _a4, remaining = __rest2(_a4, ["head", "tail", "separator"]);
      super(remaining);
      this.streamsActive = false;
      this.streams = [];
      this.newStreams = [];
      this.currentStream = null;
      this.head = head !== null && head !== undefined ? head : null;
      this.tail = tail !== null && tail !== undefined ? tail : null;
      this.separator = separator !== null && separator !== undefined ? separator : null;
    }
    add(newStream) {
      if (this.streamsActive === false) {
        this.streams.push(newStream);
        newStream.on("error", this.subStreamOnError.bind(this));
      } else {
        this.newStreams.push(newStream);
      }
      return this;
    }
    _read() {
      if (this.streamsActive === false) {
        this.streamsActive = true;
        this.pushHead();
        this.streamNextStream();
      }
    }
    subStreamOnError(err) {
      this.emit("error", err);
    }
    streamNextStream() {
      if (this.nextStream() === true) {
        this.bindCurrentStreamEvents();
      } else {
        this.pushTail();
        this.push(null);
      }
    }
    nextStream() {
      const tmp = this.streams.shift();
      this.currentStream = tmp !== undefined ? tmp : null;
      return this.currentStream !== null;
    }
    bindCurrentStreamEvents() {
      this.currentStream.on("readable", this.currentStreamOnReadable.bind(this));
      this.currentStream.on("end", this.currentStreamOnEnd.bind(this));
    }
    currentStreamOnReadable() {
      const tmp = this.currentStream.read();
      const data = tmp !== undefined && tmp !== null ? tmp : "";
      this.push(data);
    }
    currentStreamOnEnd() {
      this.pushSeparator();
      this.streams.concat(this.newStreams);
      this.newStreams = [];
      this.streamNextStream();
    }
    pushHead() {
      if (this.head !== null) {
        this.push(this.head);
      }
    }
    pushSeparator() {
      if (0 < this.streams.length && this.separator !== null) {
        this.push(this.separator);
      }
    }
    pushTail() {
      if (this.tail !== null) {
        this.push(this.tail);
      }
    }
  }
  exports.SandwichStream = SandwichStream;
  exports.default = SandwichStream;
});

// node_modules/telegraf/lib/core/network/multipart-stream.js
var require_multipart_stream = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream = __importStar(import.meta.require("stream"));
  var check_1 = require_check();
  var sandwich_stream_1 = __importDefault(require_sandwich_stream());
  var CRNL = "\r\n";

  class MultipartStream extends sandwich_stream_1.default {
    constructor(boundary) {
      super({
        head: `--${boundary}${CRNL}`,
        tail: `${CRNL}--${boundary}--`,
        separator: `${CRNL}--${boundary}${CRNL}`
      });
    }
    addPart(part) {
      const partStream = new stream.PassThrough;
      for (const [key, header] of Object.entries(part.headers)) {
        partStream.write(`${key}:${header}${CRNL}`);
      }
      partStream.write(CRNL);
      if (MultipartStream.isStream(part.body)) {
        part.body.pipe(partStream);
      } else {
        partStream.end(part.body);
      }
      this.add(partStream);
    }
    static isStream(stream2) {
      return typeof stream2 === "object" && stream2 !== null && (0, check_1.hasPropType)(stream2, "pipe", "function");
    }
  }
  exports.default = MultipartStream;
});

// node_modules/telegraf/lib/core/network/client.js
var require_client2 = __commonJS((exports) => {
  var includesMedia = function(payload) {
    return Object.entries(payload).some(([key, value]) => {
      if (key === "link_preview_options")
        return false;
      if (Array.isArray(value)) {
        return value.some(({ media }) => media && typeof media === "object" && (media.source || media.url));
      }
      return value && typeof value === "object" && ((0, check_1.hasProp)(value, "source") && value.source || (0, check_1.hasProp)(value, "url") && value.url || (0, check_1.hasPropType)(value, "media", "object") && ((0, check_1.hasProp)(value.media, "source") && value.media.source || (0, check_1.hasProp)(value.media, "url") && value.media.url));
    });
  };
  var replacer = function(_, value) {
    if (value == null)
      return;
    return value;
  };
  var buildJSONConfig = function(payload) {
    return Promise.resolve({
      method: "POST",
      compress: true,
      headers: { "content-type": "application/json", connection: "keep-alive" },
      body: JSON.stringify(payload, replacer)
    });
  };
  async function buildFormDataConfig(payload, agent) {
    for (const field of FORM_DATA_JSON_FIELDS) {
      if ((0, check_1.hasProp)(payload, field) && typeof payload[field] !== "string") {
        payload[field] = JSON.stringify(payload[field]);
      }
    }
    const boundary = crypto7.randomBytes(32).toString("hex");
    const formData = new multipart_stream_1.default(boundary);
    await Promise.all(Object.keys(payload).map((key) => attachFormValue(formData, key, payload[key], agent)));
    return {
      method: "POST",
      compress: true,
      headers: {
        "content-type": `multipart/form-data; boundary=${boundary}`,
        connection: "keep-alive"
      },
      body: formData
    };
  }
  async function attachFormValue(form, id, value, agent) {
    if (value == null) {
      return;
    }
    if (typeof value === "string" || typeof value === "boolean" || typeof value === "number") {
      form.addPart({
        headers: { "content-disposition": `form-data; name="${id}"` },
        body: `${value}`
      });
      return;
    }
    if (id === "thumb" || id === "thumbnail") {
      const attachmentId = crypto7.randomBytes(16).toString("hex");
      await attachFormMedia(form, value, attachmentId, agent);
      return form.addPart({
        headers: { "content-disposition": `form-data; name="${id}"` },
        body: `attach://${attachmentId}`
      });
    }
    if (Array.isArray(value)) {
      const items = await Promise.all(value.map(async (item) => {
        var _a4;
        if (typeof item.media !== "object") {
          return await Promise.resolve(item);
        }
        const attachmentId = crypto7.randomBytes(16).toString("hex");
        await attachFormMedia(form, item.media, attachmentId, agent);
        const thumb = (_a4 = item.thumb) !== null && _a4 !== undefined ? _a4 : item.thumbnail;
        if (typeof thumb === "object") {
          const thumbAttachmentId = crypto7.randomBytes(16).toString("hex");
          await attachFormMedia(form, thumb, thumbAttachmentId, agent);
          return {
            ...item,
            media: `attach://${attachmentId}`,
            thumbnail: `attach://${thumbAttachmentId}`
          };
        }
        return { ...item, media: `attach://${attachmentId}` };
      }));
      return form.addPart({
        headers: { "content-disposition": `form-data; name="${id}"` },
        body: JSON.stringify(items)
      });
    }
    if (value && typeof value === "object" && (0, check_1.hasProp)(value, "media") && (0, check_1.hasProp)(value, "type") && typeof value.media !== "undefined" && typeof value.type !== "undefined") {
      const attachmentId = crypto7.randomBytes(16).toString("hex");
      await attachFormMedia(form, value.media, attachmentId, agent);
      return form.addPart({
        headers: { "content-disposition": `form-data; name="${id}"` },
        body: JSON.stringify({
          ...value,
          media: `attach://${attachmentId}`
        })
      });
    }
    return await attachFormMedia(form, value, id, agent);
  }
  async function attachFormMedia(form, media, id, agent) {
    var _a4, _b, _c;
    let fileName = (_a4 = media.filename) !== null && _a4 !== undefined ? _a4 : `${id}.${(_b = DEFAULT_EXTENSIONS[id]) !== null && _b !== undefined ? _b : "dat"}`;
    if ("url" in media && media.url !== undefined) {
      const timeout = 500000;
      const res = await (0, node_fetch_1.default)(media.url, { agent, timeout });
      return form.addPart({
        headers: {
          "content-disposition": `form-data; name="${id}"; filename="${fileName}"`
        },
        body: res.body
      });
    }
    if ("source" in media && media.source) {
      let mediaSource = media.source;
      if (typeof media.source === "string") {
        const source = await (0, promises_1.realpath)(media.source);
        if ((await (0, promises_1.stat)(source)).isFile()) {
          fileName = (_c = media.filename) !== null && _c !== undefined ? _c : path.basename(media.source);
          mediaSource = await fs.createReadStream(media.source);
        } else {
          throw new TypeError(`Unable to upload '${media.source}', not a file`);
        }
      }
      if (isStream(mediaSource) || Buffer.isBuffer(mediaSource)) {
        form.addPart({
          headers: {
            "content-disposition": `form-data; name="${id}"; filename="${fileName}"`
          },
          body: mediaSource
        });
      }
    }
  }
  async function answerToWebhook(response, payload, options) {
    if (!includesMedia(payload)) {
      if (!response.headersSent) {
        response.setHeader("content-type", "application/json");
      }
      response.end(JSON.stringify(payload), "utf-8");
      return true;
    }
    const { headers, body } = await buildFormDataConfig(payload, options.attachmentAgent);
    if (!response.headersSent) {
      for (const [key, value] of Object.entries(headers)) {
        response.setHeader(key, value);
      }
    }
    await new Promise((resolve) => {
      response.on("finish", resolve);
      body.pipe(response);
    });
    return true;
  }
  var redactToken = function(error) {
    error.message = error.message.replace(/\/(bot|user)(\d+):[^/]+\//, "/$1$2:[REDACTED]/");
    throw error;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto7 = __importStar(import.meta.require("crypto"));
  var fs = __importStar(import.meta.require("fs"));
  var promises_1 = import.meta.require("fs/promises");
  var https = __importStar(import.meta.require("https"));
  var path = __importStar(import.meta.require("path"));
  var node_fetch_1 = __importDefault(import.meta.require("node-fetch"));
  var check_1 = require_check();
  var compact_1 = require_compact();
  var multipart_stream_1 = __importDefault(require_multipart_stream());
  var error_1 = __importDefault(require_error());
  var url_1 = import.meta.require("url");
  var debug = require_src()("telegraf:client");
  var { isStream } = multipart_stream_1.default;
  var WEBHOOK_REPLY_METHOD_ALLOWLIST = new Set([
    "answerCallbackQuery",
    "answerInlineQuery",
    "deleteMessage",
    "leaveChat",
    "sendChatAction"
  ]);
  var DEFAULT_EXTENSIONS = {
    audio: "mp3",
    photo: "jpg",
    sticker: "webp",
    video: "mp4",
    animation: "mp4",
    video_note: "mp4",
    voice: "ogg"
  };
  var DEFAULT_OPTIONS = {
    apiRoot: "https://api.telegram.org",
    apiMode: "bot",
    webhookReply: true,
    agent: new https.Agent({
      keepAlive: true,
      keepAliveMsecs: 1e4
    }),
    attachmentAgent: undefined,
    testEnv: false
  };
  var FORM_DATA_JSON_FIELDS = [
    "results",
    "reply_markup",
    "mask_position",
    "shipping_options",
    "errors"
  ];

  class ApiClient {
    constructor(token, options, response) {
      this.token = token;
      this.response = response;
      this.options = {
        ...DEFAULT_OPTIONS,
        ...(0, compact_1.compactOptions)(options)
      };
      if (this.options.apiRoot.startsWith("http://")) {
        this.options.agent = undefined;
      }
    }
    set webhookReply(enable) {
      this.options.webhookReply = enable;
    }
    get webhookReply() {
      return this.options.webhookReply;
    }
    async callApi(method, payload, { signal } = {}) {
      const { token, options, response } = this;
      if (options.webhookReply && (response === null || response === undefined ? undefined : response.writableEnded) === false && WEBHOOK_REPLY_METHOD_ALLOWLIST.has(method)) {
        debug("Call via webhook", method, payload);
        return await answerToWebhook(response, { method, ...payload }, options);
      }
      if (!token) {
        throw new error_1.default({
          error_code: 401,
          description: "Bot Token is required"
        });
      }
      debug("HTTP call", method, payload);
      const config6 = includesMedia(payload) ? await buildFormDataConfig({ method, ...payload }, options.attachmentAgent) : await buildJSONConfig(payload);
      const apiUrl = new url_1.URL(`./${options.apiMode}${token}${options.testEnv ? "/test" : ""}/${method}`, options.apiRoot);
      config6.agent = options.agent;
      config6.signal = signal;
      config6.timeout = 500000;
      const res = await (0, node_fetch_1.default)(apiUrl, config6).catch(redactToken);
      if (res.status >= 500) {
        const errorPayload = {
          error_code: res.status,
          description: res.statusText
        };
        throw new error_1.default(errorPayload, { method, payload });
      }
      const data = await res.json();
      if (!data.ok) {
        debug("API call failed", data);
        throw new error_1.default(data, { method, payload });
      }
      return data.result;
    }
  }
  exports.default = ApiClient;
});

// node_modules/telegraf/lib/core/helpers/formatting.js
var require_formatting = __commonJS((exports) => {
  var createFmt = function(kind, opts) {
    return function fmt(parts, ...items) {
      var _a4;
      parts = isArray(parts) ? parts : [parts];
      const result = (0, exports.join)((0, util_1.zip)(parts, items));
      if (kind) {
        (_a4 = result.entities) !== null && _a4 !== undefined || (result.entities = []);
        result.entities.unshift({
          type: kind,
          offset: 0,
          length: result.text.length,
          ...opts
        });
        result.parse_mode = undefined;
      }
      return result;
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.linkOrMention = exports.createFmt = exports.join = exports.FmtString = undefined;
  var util_1 = require_util();

  class FmtString {
    constructor(text, entities) {
      this.text = text;
      if (entities) {
        this.entities = entities;
        this.parse_mode = undefined;
      }
    }
    static normalise(content) {
      if (content instanceof FmtString)
        return content;
      return new FmtString(String(content));
    }
  }
  exports.FmtString = FmtString;
  var isArray = Array.isArray;
  var _add = (base3, next) => {
    var _a4;
    const len = base3.text.length;
    if (next instanceof FmtString) {
      base3.text = `${base3.text}${next.text}`;
      for (let i = 0;i < (((_a4 = next.entities) === null || _a4 === undefined ? undefined : _a4.length) || 0); i++) {
        const entity = next.entities[i];
        base3.entities.push({ ...entity, offset: entity.offset + len });
      }
    } else
      base3.text = `${base3.text}${next}`;
  };
  var join2 = (fragments, separator) => {
    const result = new FmtString("");
    result.entities = [];
    const iter = fragments[Symbol.iterator]();
    let curr = iter.next();
    while (!curr.done) {
      _add(result, curr.value);
      curr = iter.next();
      if (separator && !curr.done)
        _add(result, separator);
    }
    if (result.entities.length)
      result.parse_mode = undefined;
    else
      delete result.entities;
    return result;
  };
  exports.join = join2;
  exports.createFmt = createFmt;
  var linkOrMention = (content, data) => {
    const { text, entities = [] } = FmtString.normalise(content);
    entities.unshift(Object.assign(data, { offset: 0, length: text.length }));
    return new FmtString(text, entities);
  };
  exports.linkOrMention = linkOrMention;
});

// node_modules/telegraf/lib/format.js
var require_format2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mention = exports.link = exports.pre = exports.code = exports.quote = exports.underline = exports.strikethrough = exports.spoiler = exports.italic = exports.bold = exports.fmt = exports.join = exports.FmtString = undefined;
  var formatting_1 = require_formatting();
  Object.defineProperty(exports, "FmtString", { enumerable: true, get: function() {
    return formatting_1.FmtString;
  } });
  exports.join = formatting_1.join;
  exports.fmt = (0, formatting_1.createFmt)();
  exports.bold = (0, formatting_1.createFmt)("bold");
  exports.italic = (0, formatting_1.createFmt)("italic");
  exports.spoiler = (0, formatting_1.createFmt)("spoiler");
  exports.strikethrough = (0, formatting_1.createFmt)("strikethrough");
  exports.underline = (0, formatting_1.createFmt)("underline");
  exports.quote = (0, formatting_1.createFmt)("blockquote");
  exports.code = (0, formatting_1.createFmt)("code");
  var pre = (language) => (0, formatting_1.createFmt)("pre", { language });
  exports.pre = pre;
  var link = (content, url) => (0, formatting_1.linkOrMention)(content, { type: "text_link", url });
  exports.link = link;
  var mention = (name, user) => typeof user === "number" ? (0, exports.link)(name, "tg://user?id=" + user) : (0, formatting_1.linkOrMention)(name, {
    type: "text_mention",
    user
  });
  exports.mention = mention;
});

// node_modules/telegraf/lib/telegram.js
var require_telegram = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Telegram = undefined;
  var client_1 = __importDefault(require_client2());
  var path_1 = import.meta.require("path");
  var url_1 = import.meta.require("url");
  var format_1 = require_format2();
  var util_1 = require_util();

  class Telegram extends client_1.default {
    getMe() {
      return this.callApi("getMe", {});
    }
    getFile(fileId) {
      return this.callApi("getFile", { file_id: fileId });
    }
    async getFileLink(fileId) {
      if (typeof fileId === "string") {
        fileId = await this.getFile(fileId);
      } else if (fileId.file_path === undefined) {
        fileId = await this.getFile(fileId.file_id);
      }
      if (fileId.file_path !== undefined && (0, path_1.isAbsolute)(fileId.file_path)) {
        const url = new url_1.URL(this.options.apiRoot);
        url.port = "";
        url.pathname = fileId.file_path;
        url.protocol = "file:";
        return url;
      }
      return new url_1.URL(`./file/${this.options.apiMode}${this.token}${this.options.testEnv ? "/test" : ""}/${fileId.file_path}`, this.options.apiRoot);
    }
    getUpdates(timeout, limit, offset, allowedUpdates) {
      return this.callApi("getUpdates", {
        allowed_updates: allowedUpdates,
        limit,
        offset,
        timeout
      });
    }
    getWebhookInfo() {
      return this.callApi("getWebhookInfo", {});
    }
    getGameHighScores(userId, inlineMessageId, chatId, messageId) {
      return this.callApi("getGameHighScores", {
        user_id: userId,
        inline_message_id: inlineMessageId,
        chat_id: chatId,
        message_id: messageId
      });
    }
    setGameScore(userId, score, inlineMessageId, chatId, messageId, editMessage = true, force = false) {
      return this.callApi("setGameScore", {
        force,
        score,
        user_id: userId,
        inline_message_id: inlineMessageId,
        chat_id: chatId,
        message_id: messageId,
        disable_edit_message: !editMessage
      });
    }
    setWebhook(url, extra) {
      return this.callApi("setWebhook", {
        url,
        ...extra
      });
    }
    deleteWebhook(extra) {
      return this.callApi("deleteWebhook", {
        ...extra
      });
    }
    sendMessage(chatId, text, extra) {
      const t = format_1.FmtString.normalise(text);
      return this.callApi("sendMessage", { chat_id: chatId, ...extra, ...t });
    }
    forwardMessage(chatId, fromChatId, messageId, extra) {
      return this.callApi("forwardMessage", {
        chat_id: chatId,
        from_chat_id: fromChatId,
        message_id: messageId,
        ...extra
      });
    }
    forwardMessages(chatId, fromChatId, messageIds, extra) {
      return this.callApi("forwardMessages", {
        chat_id: chatId,
        from_chat_id: fromChatId,
        message_ids: messageIds,
        ...extra
      });
    }
    sendChatAction(chat_id, action, extra) {
      return this.callApi("sendChatAction", { chat_id, action, ...extra });
    }
    setMessageReaction(chat_id, message_id, reaction, is_big) {
      return this.callApi("setMessageReaction", {
        chat_id,
        message_id,
        reaction,
        is_big
      });
    }
    getUserProfilePhotos(userId, offset, limit) {
      return this.callApi("getUserProfilePhotos", {
        user_id: userId,
        offset,
        limit
      });
    }
    sendLocation(chatId, latitude, longitude, extra) {
      return this.callApi("sendLocation", {
        chat_id: chatId,
        latitude,
        longitude,
        ...extra
      });
    }
    sendVenue(chatId, latitude, longitude, title, address7, extra) {
      return this.callApi("sendVenue", {
        latitude,
        longitude,
        title,
        address: address7,
        chat_id: chatId,
        ...extra
      });
    }
    sendInvoice(chatId, invoice, extra) {
      return this.callApi("sendInvoice", {
        chat_id: chatId,
        ...invoice,
        ...extra
      });
    }
    sendContact(chatId, phoneNumber, firstName, extra) {
      return this.callApi("sendContact", {
        chat_id: chatId,
        phone_number: phoneNumber,
        first_name: firstName,
        ...extra
      });
    }
    sendPhoto(chatId, photo, extra) {
      return this.callApi("sendPhoto", {
        chat_id: chatId,
        photo,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendDice(chatId, extra) {
      return this.callApi("sendDice", { chat_id: chatId, ...extra });
    }
    sendDocument(chatId, document2, extra) {
      return this.callApi("sendDocument", {
        chat_id: chatId,
        document: document2,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendAudio(chatId, audio, extra) {
      return this.callApi("sendAudio", {
        chat_id: chatId,
        audio,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendSticker(chatId, sticker, extra) {
      return this.callApi("sendSticker", { chat_id: chatId, sticker, ...extra });
    }
    sendVideo(chatId, video, extra) {
      return this.callApi("sendVideo", {
        chat_id: chatId,
        video,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendAnimation(chatId, animation, extra) {
      return this.callApi("sendAnimation", {
        chat_id: chatId,
        animation,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendVideoNote(chatId, videoNote, extra) {
      return this.callApi("sendVideoNote", {
        chat_id: chatId,
        video_note: videoNote,
        ...extra
      });
    }
    sendVoice(chatId, voice, extra) {
      return this.callApi("sendVoice", {
        chat_id: chatId,
        voice,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendGame(chatId, gameName, extra) {
      return this.callApi("sendGame", {
        chat_id: chatId,
        game_short_name: gameName,
        ...extra
      });
    }
    sendMediaGroup(chatId, media, extra) {
      return this.callApi("sendMediaGroup", { chat_id: chatId, media, ...extra });
    }
    sendPoll(chatId, question, options, extra) {
      return this.callApi("sendPoll", {
        chat_id: chatId,
        type: "regular",
        question,
        options,
        ...extra
      });
    }
    sendQuiz(chatId, question, options, extra) {
      return this.callApi("sendPoll", {
        chat_id: chatId,
        type: "quiz",
        question,
        options,
        ...extra
      });
    }
    stopPoll(chatId, messageId, extra) {
      return this.callApi("stopPoll", {
        chat_id: chatId,
        message_id: messageId,
        ...extra
      });
    }
    getChat(chatId) {
      return this.callApi("getChat", { chat_id: chatId });
    }
    getChatAdministrators(chatId) {
      return this.callApi("getChatAdministrators", { chat_id: chatId });
    }
    getChatMember(chatId, userId) {
      return this.callApi("getChatMember", { chat_id: chatId, user_id: userId });
    }
    getChatMembersCount(chatId) {
      return this.callApi("getChatMembersCount", { chat_id: chatId });
    }
    answerInlineQuery(inlineQueryId, results, extra) {
      return this.callApi("answerInlineQuery", {
        inline_query_id: inlineQueryId,
        results,
        ...extra
      });
    }
    setChatPermissions(chatId, permissions, extra) {
      return this.callApi("setChatPermissions", {
        chat_id: chatId,
        permissions,
        ...extra
      });
    }
    banChatMember(chatId, userId, untilDate, extra) {
      return this.callApi("banChatMember", {
        chat_id: chatId,
        user_id: userId,
        until_date: untilDate,
        ...extra
      });
    }
    get kickChatMember() {
      return this.banChatMember;
    }
    promoteChatMember(chatId, userId, extra) {
      return this.callApi("promoteChatMember", {
        chat_id: chatId,
        user_id: userId,
        ...extra
      });
    }
    restrictChatMember(chatId, userId, extra) {
      return this.callApi("restrictChatMember", {
        chat_id: chatId,
        user_id: userId,
        ...extra
      });
    }
    setChatAdministratorCustomTitle(chatId, userId, title) {
      return this.callApi("setChatAdministratorCustomTitle", {
        chat_id: chatId,
        user_id: userId,
        custom_title: title
      });
    }
    exportChatInviteLink(chatId) {
      return this.callApi("exportChatInviteLink", { chat_id: chatId });
    }
    createChatInviteLink(chatId, extra) {
      return this.callApi("createChatInviteLink", {
        chat_id: chatId,
        ...extra
      });
    }
    createInvoiceLink(invoice) {
      return this.callApi("createInvoiceLink", {
        ...invoice
      });
    }
    editChatInviteLink(chatId, inviteLink, extra) {
      return this.callApi("editChatInviteLink", {
        chat_id: chatId,
        invite_link: inviteLink,
        ...extra
      });
    }
    revokeChatInviteLink(chatId, inviteLink) {
      return this.callApi("revokeChatInviteLink", {
        chat_id: chatId,
        invite_link: inviteLink
      });
    }
    setChatPhoto(chatId, photo) {
      return this.callApi("setChatPhoto", { chat_id: chatId, photo });
    }
    deleteChatPhoto(chatId) {
      return this.callApi("deleteChatPhoto", { chat_id: chatId });
    }
    setChatTitle(chatId, title) {
      return this.callApi("setChatTitle", { chat_id: chatId, title });
    }
    setChatDescription(chatId, description) {
      return this.callApi("setChatDescription", { chat_id: chatId, description });
    }
    pinChatMessage(chatId, messageId, extra) {
      return this.callApi("pinChatMessage", {
        chat_id: chatId,
        message_id: messageId,
        ...extra
      });
    }
    unpinChatMessage(chatId, messageId) {
      return this.callApi("unpinChatMessage", {
        chat_id: chatId,
        message_id: messageId
      });
    }
    unpinAllChatMessages(chatId) {
      return this.callApi("unpinAllChatMessages", { chat_id: chatId });
    }
    leaveChat(chatId) {
      return this.callApi("leaveChat", { chat_id: chatId });
    }
    unbanChatMember(chatId, userId, extra) {
      return this.callApi("unbanChatMember", {
        chat_id: chatId,
        user_id: userId,
        ...extra
      });
    }
    answerCbQuery(callbackQueryId, text, extra) {
      return this.callApi("answerCallbackQuery", {
        text,
        callback_query_id: callbackQueryId,
        ...extra
      });
    }
    answerGameQuery(callbackQueryId, url) {
      return this.callApi("answerCallbackQuery", {
        url,
        callback_query_id: callbackQueryId
      });
    }
    getUserChatBoosts(chat_id, user_id) {
      return this.callApi("getUserChatBoosts", {
        chat_id,
        user_id
      });
    }
    answerShippingQuery(shippingQueryId, ok, shippingOptions, errorMessage) {
      return this.callApi("answerShippingQuery", {
        ok,
        shipping_query_id: shippingQueryId,
        shipping_options: shippingOptions,
        error_message: errorMessage
      });
    }
    answerPreCheckoutQuery(preCheckoutQueryId, ok, errorMessage) {
      return this.callApi("answerPreCheckoutQuery", {
        ok,
        pre_checkout_query_id: preCheckoutQueryId,
        error_message: errorMessage
      });
    }
    answerWebAppQuery(webAppQueryId, result) {
      return this.callApi("answerWebAppQuery", {
        web_app_query_id: webAppQueryId,
        result
      });
    }
    editMessageText(chatId, messageId, inlineMessageId, text, extra) {
      const t = format_1.FmtString.normalise(text);
      return this.callApi("editMessageText", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        ...extra,
        ...t
      });
    }
    editMessageCaption(chatId, messageId, inlineMessageId, caption, extra) {
      return this.callApi("editMessageCaption", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        ...extra,
        ...(0, util_1.fmtCaption)({ caption })
      });
    }
    editMessageMedia(chatId, messageId, inlineMessageId, media, extra) {
      return this.callApi("editMessageMedia", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        media: (0, util_1.fmtCaption)(media),
        ...extra
      });
    }
    editMessageReplyMarkup(chatId, messageId, inlineMessageId, markup) {
      return this.callApi("editMessageReplyMarkup", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        reply_markup: markup
      });
    }
    editMessageLiveLocation(chatId, messageId, inlineMessageId, latitude, longitude, extra) {
      return this.callApi("editMessageLiveLocation", {
        latitude,
        longitude,
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        ...extra
      });
    }
    stopMessageLiveLocation(chatId, messageId, inlineMessageId, markup) {
      return this.callApi("stopMessageLiveLocation", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        reply_markup: markup
      });
    }
    deleteMessage(chatId, messageId) {
      return this.callApi("deleteMessage", {
        chat_id: chatId,
        message_id: messageId
      });
    }
    deleteMessages(chatId, messageIds) {
      return this.callApi("deleteMessages", {
        chat_id: chatId,
        message_ids: messageIds
      });
    }
    setChatStickerSet(chatId, setName) {
      return this.callApi("setChatStickerSet", {
        chat_id: chatId,
        sticker_set_name: setName
      });
    }
    deleteChatStickerSet(chatId) {
      return this.callApi("deleteChatStickerSet", { chat_id: chatId });
    }
    getForumTopicIconStickers() {
      return this.callApi("getForumTopicIconStickers", {});
    }
    createForumTopic(chat_id, name, extra) {
      return this.callApi("createForumTopic", {
        chat_id,
        name,
        ...extra
      });
    }
    editForumTopic(chat_id, message_thread_id, extra) {
      return this.callApi("editForumTopic", {
        chat_id,
        message_thread_id,
        ...extra
      });
    }
    closeForumTopic(chat_id, message_thread_id) {
      return this.callApi("closeForumTopic", {
        chat_id,
        message_thread_id
      });
    }
    reopenForumTopic(chat_id, message_thread_id) {
      return this.callApi("reopenForumTopic", {
        chat_id,
        message_thread_id
      });
    }
    deleteForumTopic(chat_id, message_thread_id) {
      return this.callApi("deleteForumTopic", {
        chat_id,
        message_thread_id
      });
    }
    unpinAllForumTopicMessages(chat_id, message_thread_id) {
      return this.callApi("unpinAllForumTopicMessages", {
        chat_id,
        message_thread_id
      });
    }
    editGeneralForumTopic(chat_id, name) {
      return this.callApi("editGeneralForumTopic", { chat_id, name });
    }
    closeGeneralForumTopic(chat_id) {
      return this.callApi("closeGeneralForumTopic", { chat_id });
    }
    reopenGeneralForumTopic(chat_id) {
      return this.callApi("reopenGeneralForumTopic", { chat_id });
    }
    hideGeneralForumTopic(chat_id) {
      return this.callApi("hideGeneralForumTopic", { chat_id });
    }
    unhideGeneralForumTopic(chat_id) {
      return this.callApi("unhideGeneralForumTopic", { chat_id });
    }
    unpinAllGeneralForumTopicMessages(chat_id) {
      return this.callApi("unpinAllGeneralForumTopicMessages", { chat_id });
    }
    getStickerSet(name) {
      return this.callApi("getStickerSet", { name });
    }
    uploadStickerFile(ownerId, sticker, sticker_format) {
      return this.callApi("uploadStickerFile", {
        user_id: ownerId,
        sticker_format,
        sticker
      });
    }
    createNewStickerSet(ownerId, name, title, stickerData) {
      return this.callApi("createNewStickerSet", {
        name,
        title,
        user_id: ownerId,
        ...stickerData
      });
    }
    addStickerToSet(ownerId, name, stickerData) {
      return this.callApi("addStickerToSet", {
        name,
        user_id: ownerId,
        ...stickerData
      });
    }
    setStickerPositionInSet(sticker, position) {
      return this.callApi("setStickerPositionInSet", {
        sticker,
        position
      });
    }
    get setStickerSetThumb() {
      return this.setStickerSetThumbnail;
    }
    setStickerSetThumbnail(name, userId, thumbnail) {
      return this.callApi("setStickerSetThumbnail", {
        name,
        user_id: userId,
        thumbnail
      });
    }
    setStickerMaskPosition(sticker, mask_position) {
      return this.callApi("setStickerMaskPosition", { sticker, mask_position });
    }
    setStickerKeywords(sticker, keywords) {
      return this.callApi("setStickerKeywords", { sticker, keywords });
    }
    setStickerEmojiList(sticker, emoji_list) {
      return this.callApi("setStickerEmojiList", { sticker, emoji_list });
    }
    deleteStickerSet(name) {
      return this.callApi("deleteStickerSet", { name });
    }
    setStickerSetTitle(name, title) {
      return this.callApi("setStickerSetTitle", { name, title });
    }
    setCustomEmojiStickerSetThumbnail(name, custom_emoji_id) {
      return this.callApi("setCustomEmojiStickerSetThumbnail", {
        name,
        custom_emoji_id
      });
    }
    deleteStickerFromSet(sticker) {
      return this.callApi("deleteStickerFromSet", { sticker });
    }
    getCustomEmojiStickers(custom_emoji_ids) {
      return this.callApi("getCustomEmojiStickers", { custom_emoji_ids });
    }
    setMyCommands(commands, extra) {
      return this.callApi("setMyCommands", { commands, ...extra });
    }
    deleteMyCommands(extra = {}) {
      return this.callApi("deleteMyCommands", extra);
    }
    getMyCommands(extra = {}) {
      return this.callApi("getMyCommands", extra);
    }
    setMyDescription(description, language_code) {
      return this.callApi("setMyDescription", { description, language_code });
    }
    setMyName(name, language_code) {
      return this.callApi("setMyName", { name, language_code });
    }
    getMyName(language_code) {
      return this.callApi("getMyName", { language_code });
    }
    getMyDescription(language_code) {
      return this.callApi("getMyDescription", { language_code });
    }
    setMyShortDescription(short_description, language_code) {
      return this.callApi("setMyShortDescription", {
        short_description,
        language_code
      });
    }
    getMyShortDescription(language_code) {
      return this.callApi("getMyShortDescription", { language_code });
    }
    setPassportDataErrors(userId, errors5) {
      return this.callApi("setPassportDataErrors", {
        user_id: userId,
        errors: errors5
      });
    }
    sendCopy(chatId, message, extra) {
      return this.copyMessage(chatId, message.chat.id, message.message_id, extra);
    }
    copyMessage(chatId, fromChatId, messageId, extra) {
      return this.callApi("copyMessage", {
        chat_id: chatId,
        from_chat_id: fromChatId,
        message_id: messageId,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    copyMessages(chatId, fromChatId, messageIds, extra) {
      return this.callApi("copyMessages", {
        chat_id: chatId,
        from_chat_id: fromChatId,
        message_ids: messageIds,
        ...extra
      });
    }
    approveChatJoinRequest(chatId, userId) {
      return this.callApi("approveChatJoinRequest", {
        chat_id: chatId,
        user_id: userId
      });
    }
    declineChatJoinRequest(chatId, userId) {
      return this.callApi("declineChatJoinRequest", {
        chat_id: chatId,
        user_id: userId
      });
    }
    banChatSenderChat(chatId, senderChatId, extra) {
      return this.callApi("banChatSenderChat", {
        chat_id: chatId,
        sender_chat_id: senderChatId,
        ...extra
      });
    }
    unbanChatSenderChat(chatId, senderChatId) {
      return this.callApi("unbanChatSenderChat", {
        chat_id: chatId,
        sender_chat_id: senderChatId
      });
    }
    setChatMenuButton({ chatId, menuButton } = {}) {
      return this.callApi("setChatMenuButton", {
        chat_id: chatId,
        menu_button: menuButton
      });
    }
    getChatMenuButton({ chatId } = {}) {
      return this.callApi("getChatMenuButton", {
        chat_id: chatId
      });
    }
    setMyDefaultAdministratorRights({ rights, forChannels } = {}) {
      return this.callApi("setMyDefaultAdministratorRights", {
        rights,
        for_channels: forChannels
      });
    }
    getMyDefaultAdministratorRights({ forChannels } = {}) {
      return this.callApi("getMyDefaultAdministratorRights", {
        for_channels: forChannels
      });
    }
    logOut() {
      return this.callApi("logOut", {});
    }
    close() {
      return this.callApi("close", {});
    }
  }
  exports.Telegram = Telegram;
  exports.default = Telegram;
});

// node_modules/buffer-fill/index.js
var require_buffer_fill = __commonJS((exports, module) => {
  var isSingleByte = function(val) {
    return val.length === 1 && val.charCodeAt(0) < 256;
  };
  var fillWithNumber = function(buffer, val, start, end) {
    if (start < 0 || end > buffer.length) {
      throw new RangeError("Out of range index");
    }
    start = start >>> 0;
    end = end === undefined ? buffer.length : end >>> 0;
    if (end > start) {
      buffer.fill(val, start, end);
    }
    return buffer;
  };
  var fillWithBuffer = function(buffer, val, start, end) {
    if (start < 0 || end > buffer.length) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return buffer;
    }
    start = start >>> 0;
    end = end === undefined ? buffer.length : end >>> 0;
    var pos = start;
    var len = val.length;
    while (pos <= end - len) {
      val.copy(buffer, pos);
      pos += len;
    }
    if (pos !== end) {
      val.copy(buffer, pos, 0, end - pos);
    }
    return buffer;
  };
  var fill = function(buffer, val, start, end, encoding4) {
    if (hasFullSupport) {
      return buffer.fill(val, start, end, encoding4);
    }
    if (typeof val === "number") {
      return fillWithNumber(buffer, val, start, end);
    }
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding4 = start;
        start = 0;
        end = buffer.length;
      } else if (typeof end === "string") {
        encoding4 = end;
        end = buffer.length;
      }
      if (encoding4 !== undefined && typeof encoding4 !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (encoding4 === "latin1") {
        encoding4 = "binary";
      }
      if (typeof encoding4 === "string" && !Buffer.isEncoding(encoding4)) {
        throw new TypeError("Unknown encoding: " + encoding4);
      }
      if (val === "") {
        return fillWithNumber(buffer, 0, start, end);
      }
      if (isSingleByte(val)) {
        return fillWithNumber(buffer, val.charCodeAt(0), start, end);
      }
      val = new Buffer(val, encoding4);
    }
    if (Buffer.isBuffer(val)) {
      return fillWithBuffer(buffer, val, start, end);
    }
    return fillWithNumber(buffer, 0, start, end);
  };
  var hasFullSupport = function() {
    try {
      if (!Buffer.isEncoding("latin1")) {
        return false;
      }
      var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
      buf.fill("ab", "ucs2");
      return buf.toString("hex") === "61006200";
    } catch (_) {
      return false;
    }
  }();
  module.exports = fill;
});

// node_modules/buffer-alloc-unsafe/index.js
var require_buffer_alloc_unsafe = __commonJS((exports, module) => {
  var allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    }
    if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
    if (Buffer.allocUnsafe) {
      return Buffer.allocUnsafe(size);
    } else {
      return new Buffer(size);
    }
  };
  module.exports = allocUnsafe;
});

// node_modules/buffer-alloc/index.js
var require_buffer_alloc = __commonJS((exports, module) => {
  var bufferFill = require_buffer_fill();
  var allocUnsafe = require_buffer_alloc_unsafe();
  module.exports = function alloc(size, fill, encoding4) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    }
    if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
    if (Buffer.alloc) {
      return Buffer.alloc(size, fill, encoding4);
    }
    var buffer = allocUnsafe(size);
    if (size === 0) {
      return buffer;
    }
    if (fill === undefined) {
      return bufferFill(buffer, 0);
    }
    if (typeof encoding4 !== "string") {
      encoding4 = undefined;
    }
    return bufferFill(buffer, fill, encoding4);
  };
});

// node_modules/safe-compare/index.js
var require_safe_compare = __commonJS((exports, module) => {
  var crypto7 = import.meta.require("crypto");
  var bufferAlloc = require_buffer_alloc();
  var safeCompare = function safeCompare(a, b) {
    var strA = String(a);
    var strB = String(b);
    var lenA = strA.length;
    var result = 0;
    if (lenA !== strB.length) {
      strB = strA;
      result = 1;
    }
    for (var i = 0;i < lenA; i++) {
      result |= strA.charCodeAt(i) ^ strB.charCodeAt(i);
    }
    return result === 0;
  };
  var nativeTimingSafeEqual = function nativeTimingSafeEqual(a, b) {
    var strA = String(a);
    var strB = String(b);
    var aLen = Buffer.byteLength(strA);
    var bLen = Buffer.byteLength(strB);
    var bufA = bufferAlloc(aLen, 0, "utf8");
    bufA.write(strA);
    var bufB = bufferAlloc(aLen, 0, "utf8");
    bufB.write(strB);
    return crypto7.timingSafeEqual(bufA, bufB) && aLen === bLen;
  };
  module.exports = typeof crypto7.timingSafeEqual !== "undefined" ? nativeTimingSafeEqual : safeCompare;
});

// node_modules/telegraf/lib/telegraf.js
var require_telegraf = __commonJS((exports) => {
  var always = function(x) {
    return () => x;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Telegraf = undefined;
  var crypto7 = __importStar(import.meta.require("crypto"));
  var http = __importStar(import.meta.require("http"));
  var https = __importStar(import.meta.require("https"));
  var composer_1 = require_composer();
  var compact_1 = require_compact();
  var context_1 = __importDefault(require_context());
  var debug_1 = __importDefault(require_src());
  var webhook_1 = __importDefault(require_webhook());
  var polling_1 = require_polling();
  var p_timeout_1 = __importDefault(require_p_timeout());
  var telegram_1 = __importDefault(require_telegram());
  var url_1 = import.meta.require("url");
  var safeCompare = require_safe_compare();
  var debug = (0, debug_1.default)("telegraf:main");
  var DEFAULT_OPTIONS = {
    telegram: {},
    handlerTimeout: 90000,
    contextType: context_1.default
  };
  var anoop = always(Promise.resolve());
  var TOKEN_HEADER = "x-telegram-bot-api-secret-token";

  class Telegraf extends composer_1.Composer {
    constructor(token, options) {
      super();
      this.context = {};
      this.webhookFilter = function(req) {
        const debug2 = (0, debug_1.default)("telegraf:webhook");
        if (req.method === "POST") {
          if (safeCompare(this.path, req.url)) {
            if (!this.secretToken)
              return true;
            else {
              const token2 = req.headers[TOKEN_HEADER];
              if (safeCompare(this.secretToken, token2))
                return true;
              else
                debug2("Secret token does not match:", token2, this.secretToken);
            }
          } else
            debug2("Path does not match:", req.url, this.path);
        } else
          debug2("Unexpected request method, not POST. Received:", req.method);
        return false;
      };
      this.handleError = (err, ctx) => {
        process.exitCode = 1;
        console.error("Unhandled error while processing", ctx.update);
        throw err;
      };
      this.options = {
        ...DEFAULT_OPTIONS,
        ...(0, compact_1.compactOptions)(options)
      };
      this.telegram = new telegram_1.default(token, this.options.telegram);
      debug("Created a `Telegraf` instance");
    }
    get token() {
      return this.telegram.token;
    }
    set webhookReply(webhookReply) {
      this.telegram.webhookReply = webhookReply;
    }
    get webhookReply() {
      return this.telegram.webhookReply;
    }
    catch(handler) {
      this.handleError = handler;
      return this;
    }
    webhookCallback(path = "/", opts = {}) {
      const { secretToken } = opts;
      return (0, webhook_1.default)(this.webhookFilter.bind({ hookPath: path, path, secretToken }), (update, res) => this.handleUpdate(update, res));
    }
    getDomainOpts(opts) {
      var _a4;
      const protocol = opts.domain.startsWith("https://") || opts.domain.startsWith("http://");
      if (protocol)
        debug("Unexpected protocol in domain, telegraf will use https:", opts.domain);
      const domain = protocol ? new url_1.URL(opts.domain).host : opts.domain;
      const path = (_a4 = opts.path) !== null && _a4 !== undefined ? _a4 : `/telegraf/${this.secretPathComponent()}`;
      const url = `https://${domain}${path}`;
      return { domain, path, url };
    }
    async createWebhook(opts) {
      const { domain, path, ...extra } = opts;
      const domainOpts = this.getDomainOpts({ domain, path });
      await this.telegram.setWebhook(domainOpts.url, extra);
      debug(`Webhook set to ${domainOpts.url}`);
      return this.webhookCallback(domainOpts.path, {
        secretToken: extra.secret_token
      });
    }
    startPolling(allowedUpdates = []) {
      this.polling = new polling_1.Polling(this.telegram, allowedUpdates);
      return this.polling.loop(async (update) => {
        await this.handleUpdate(update);
      });
    }
    startWebhook(path, tlsOptions, port, host, cb, secretToken) {
      const webhookCb = this.webhookCallback(path, { secretToken });
      const callback = typeof cb === "function" ? (req, res) => webhookCb(req, res, () => cb(req, res)) : webhookCb;
      this.webhookServer = tlsOptions != null ? https.createServer(tlsOptions, callback) : http.createServer(callback);
      this.webhookServer.listen(port, host, () => {
        debug("Webhook listening on port: %s", port);
      });
      return this;
    }
    secretPathComponent() {
      return crypto7.createHash("sha3-256").update(this.token).update(process.version).digest("hex");
    }
    async launch(config6 = {}, onLaunch) {
      var _a4, _b;
      const [cfg, onMe] = typeof config6 === "function" ? [{}, config6] : [config6, onLaunch];
      const drop_pending_updates = cfg.dropPendingUpdates;
      const allowed_updates = cfg.allowedUpdates;
      const webhook = cfg.webhook;
      debug("Connecting to Telegram");
      (_a4 = this.botInfo) !== null && _a4 !== undefined || (this.botInfo = await this.telegram.getMe());
      onMe === null || onMe === undefined || onMe();
      debug(`Launching @${this.botInfo.username}`);
      if (webhook === undefined) {
        await this.telegram.deleteWebhook({ drop_pending_updates });
        debug("Bot started with long polling");
        await this.startPolling(allowed_updates);
        return;
      }
      const domainOpts = this.getDomainOpts({
        domain: webhook.domain,
        path: (_b = webhook.path) !== null && _b !== undefined ? _b : webhook.hookPath
      });
      const { tlsOptions, port, host, cb, secretToken } = webhook;
      this.startWebhook(domainOpts.path, tlsOptions, port, host, cb, secretToken);
      await this.telegram.setWebhook(domainOpts.url, {
        drop_pending_updates,
        allowed_updates,
        ip_address: webhook.ipAddress,
        max_connections: webhook.maxConnections,
        secret_token: webhook.secretToken,
        certificate: webhook.certificate
      });
      debug(`Bot started with webhook @ ${domainOpts.url}`);
    }
    stop(reason = "unspecified") {
      var _a4, _b;
      debug("Stopping bot... Reason:", reason);
      if (this.polling === undefined && this.webhookServer === undefined) {
        throw new Error("Bot is not running!");
      }
      (_a4 = this.webhookServer) === null || _a4 === undefined || _a4.close();
      (_b = this.polling) === null || _b === undefined || _b.stop();
    }
    async handleUpdate(update, webhookResponse) {
      var _a4, _b;
      (_a4 = this.botInfo) !== null && _a4 !== undefined || (this.botInfo = (debug("Update %d is waiting for `botInfo` to be initialized", update.update_id), await ((_b = this.botInfoCall) !== null && _b !== undefined ? _b : this.botInfoCall = this.telegram.getMe())));
      debug("Processing update", update.update_id);
      const tg = new telegram_1.default(this.token, this.telegram.options, webhookResponse);
      const TelegrafContext = this.options.contextType;
      const ctx = new TelegrafContext(update, tg, this.botInfo);
      Object.assign(ctx, this.context);
      try {
        await (0, p_timeout_1.default)(Promise.resolve(this.middleware()(ctx, anoop)), this.options.handlerTimeout);
      } catch (err) {
        return await this.handleError(err, ctx);
      } finally {
        if ((webhookResponse === null || webhookResponse === undefined ? undefined : webhookResponse.writableEnded) === false) {
          webhookResponse.end();
        }
        debug("Finished processing update", update.update_id);
      }
    }
  }
  exports.Telegraf = Telegraf;
});

// node_modules/telegraf/lib/router.js
var require_router = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Router = undefined;
  var composer_1 = __importDefault(require_composer());

  class Router {
    constructor(routeFn, handlers = new Map) {
      this.routeFn = routeFn;
      this.handlers = handlers;
      this.otherwiseHandler = composer_1.default.passThru();
      if (typeof routeFn !== "function") {
        throw new Error("Missing routing function");
      }
    }
    on(route, ...fns) {
      if (fns.length === 0) {
        throw new TypeError("At least one handler must be provided");
      }
      this.handlers.set(route, composer_1.default.compose(fns));
      return this;
    }
    otherwise(...fns) {
      if (fns.length === 0) {
        throw new TypeError("At least one otherwise handler must be provided");
      }
      this.otherwiseHandler = composer_1.default.compose(fns);
      return this;
    }
    middleware() {
      return composer_1.default.lazy((ctx) => {
        var _a4;
        const result = this.routeFn(ctx);
        if (result == null) {
          return this.otherwiseHandler;
        }
        Object.assign(ctx, result.context);
        Object.assign(ctx.state, result.state);
        return (_a4 = this.handlers.get(result.route)) !== null && _a4 !== undefined ? _a4 : this.otherwiseHandler;
      });
    }
  }
  exports.Router = Router;
});

// node_modules/telegraf/lib/button.js
var require_button = __commonJS((exports) => {
  var text = function(text2, hide = false) {
    return { text: text2, hide };
  };
  var contactRequest = function(text2, hide = false) {
    return { text: text2, request_contact: true, hide };
  };
  var locationRequest = function(text2, hide = false) {
    return { text: text2, request_location: true, hide };
  };
  var pollRequest = function(text2, type, hide = false) {
    return { text: text2, request_poll: { type }, hide };
  };
  var userRequest = function(text2, request_id, extra, hide = false) {
    return {
      text: text2,
      request_users: { request_id, ...extra },
      hide
    };
  };
  var botRequest = function(text2, request_id, extra, hide = false) {
    return {
      text: text2,
      request_users: { request_id, user_is_bot: true, ...extra },
      hide
    };
  };
  var groupRequest = function(text2, request_id, extra, hide = false) {
    return {
      text: text2,
      request_chat: { request_id, chat_is_channel: false, ...extra },
      hide
    };
  };
  var channelRequest = function(text2, request_id, extra, hide = false) {
    return {
      text: text2,
      request_chat: { request_id, chat_is_channel: true, ...extra },
      hide
    };
  };
  var url = function(text2, url2, hide = false) {
    return { text: text2, url: url2, hide };
  };
  var callback = function(text2, data, hide = false) {
    return { text: text2, callback_data: data, hide };
  };
  var switchToChat = function(text2, value, hide = false) {
    return { text: text2, switch_inline_query: value, hide };
  };
  var switchToCurrentChat = function(text2, value, hide = false) {
    return { text: text2, switch_inline_query_current_chat: value, hide };
  };
  var game = function(text2, hide = false) {
    return { text: text2, callback_game: {}, hide };
  };
  var pay = function(text2, hide = false) {
    return { text: text2, pay: true, hide };
  };
  var login = function(text2, url2, opts = {}, hide = false) {
    return {
      text: text2,
      login_url: { ...opts, url: url2 },
      hide
    };
  };
  var webApp = function(text2, url2, hide = false) {
    return {
      text: text2,
      web_app: { url: url2 },
      hide
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.webApp = exports.login = exports.pay = exports.game = exports.switchToCurrentChat = exports.switchToChat = exports.callback = exports.url = exports.channelRequest = exports.groupRequest = exports.botRequest = exports.userRequest = exports.pollRequest = exports.locationRequest = exports.contactRequest = exports.text = undefined;
  exports.text = text;
  exports.contactRequest = contactRequest;
  exports.locationRequest = locationRequest;
  exports.pollRequest = pollRequest;
  exports.userRequest = userRequest;
  exports.botRequest = botRequest;
  exports.groupRequest = groupRequest;
  exports.channelRequest = channelRequest;
  exports.url = url;
  exports.callback = callback;
  exports.switchToChat = switchToChat;
  exports.switchToCurrentChat = switchToCurrentChat;
  exports.game = game;
  exports.pay = pay;
  exports.login = login;
  exports.webApp = webApp;
});

// node_modules/telegraf/lib/markup.js
var require_markup = __commonJS((exports) => {
  var removeKeyboard = function() {
    return new Markup({ remove_keyboard: true });
  };
  var forceReply = function() {
    return new Markup({ force_reply: true });
  };
  var keyboard = function(buttons, options) {
    const keyboard2 = buildKeyboard(buttons, {
      columns: 1,
      ...options
    });
    return new Markup({ keyboard: keyboard2 });
  };
  var inlineKeyboard = function(buttons, options) {
    const inlineKeyboard2 = buildKeyboard(buttons, {
      columns: buttons.length,
      ...options
    });
    return new Markup({ inline_keyboard: inlineKeyboard2 });
  };
  var buildKeyboard = function(buttons, options) {
    const result = [];
    if (!Array.isArray(buttons)) {
      return result;
    }
    if ((0, check_1.is2D)(buttons)) {
      return buttons.map((row) => row.filter((button) => !button.hide));
    }
    const wrapFn = options.wrap !== undefined ? options.wrap : (_btn, _index, currentRow2) => currentRow2.length >= options.columns;
    let currentRow = [];
    let index = 0;
    for (const btn of buttons.filter((button) => !button.hide)) {
      if (wrapFn(btn, index, currentRow) && currentRow.length > 0) {
        result.push(currentRow);
        currentRow = [];
      }
      currentRow.push(btn);
      index++;
    }
    if (currentRow.length > 0) {
      result.push(currentRow);
    }
    return result;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.inlineKeyboard = exports.keyboard = exports.forceReply = exports.removeKeyboard = exports.button = exports.Markup = undefined;
  var check_1 = require_check();

  class Markup {
    constructor(reply_markup) {
      this.reply_markup = reply_markup;
    }
    selective(value = true) {
      return new Markup({ ...this.reply_markup, selective: value });
    }
    placeholder(placeholder) {
      return new Markup({
        ...this.reply_markup,
        input_field_placeholder: placeholder
      });
    }
    resize(value = true) {
      return new Markup({
        ...this.reply_markup,
        resize_keyboard: value
      });
    }
    oneTime(value = true) {
      return new Markup({
        ...this.reply_markup,
        one_time_keyboard: value
      });
    }
    persistent(value = true) {
      return new Markup({
        ...this.reply_markup,
        is_persistent: value
      });
    }
  }
  exports.Markup = Markup;
  exports.button = __importStar(require_button());
  exports.removeKeyboard = removeKeyboard;
  exports.forceReply = forceReply;
  exports.keyboard = keyboard;
  exports.inlineKeyboard = inlineKeyboard;
});

// node_modules/telegraf/lib/telegram-types.js
var require_telegram_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Markup = undefined;
  var markup_1 = require_markup();
  Object.defineProperty(exports, "Markup", { enumerable: true, get: function() {
    return markup_1.Markup;
  } });
});

// node_modules/telegraf/lib/input.js
var require_input = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromFileId = exports.fromURL = exports.fromURLStream = exports.fromReadableStream = exports.fromBuffer = exports.fromLocalFile = undefined;
  var fromLocalFile = (path, filename) => ({ source: path, filename });
  exports.fromLocalFile = fromLocalFile;
  var fromBuffer = (buffer, filename) => ({ source: buffer, filename });
  exports.fromBuffer = fromBuffer;
  var fromReadableStream = (stream, filename) => ({ source: stream, filename });
  exports.fromReadableStream = fromReadableStream;
  var fromURLStream = (url, filename) => ({ url: url.toString(), filename });
  exports.fromURLStream = fromURLStream;
  var fromURL = (url) => url.toString();
  exports.fromURL = fromURL;
  var fromFileId = (fileId) => fileId;
  exports.fromFileId = fromFileId;
});

// node_modules/telegraf/lib/core/helpers/deunionize.js
var require_deunionize = __commonJS((exports) => {
  var deunionize = function(t) {
    return t;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deunionize = undefined;
  exports.deunionize = deunionize;
});

// node_modules/telegraf/lib/session.js
var require_session = __commonJS((exports) => {
  var session = function(options) {
    var _a4, _b, _c;
    const prop = (_a4 = options === null || options === undefined ? undefined : options.property) !== null && _a4 !== undefined ? _a4 : "session";
    const getSessionKey = (_b = options === null || options === undefined ? undefined : options.getSessionKey) !== null && _b !== undefined ? _b : defaultGetSessionKey;
    const store = (_c = options === null || options === undefined ? undefined : options.store) !== null && _c !== undefined ? _c : new MemorySessionStore;
    const cache = new Map;
    const concurrents = new Map;
    return async (ctx, next) => {
      var _a5;
      const updId = ctx.update.update_id;
      let released = false;
      function releaseChecks() {
        if (released && process.env.EXPERIMENTAL_SESSION_CHECKS)
          throw new Error("Session was accessed or assigned to after the middleware chain exhausted. This is a bug in your code. You're probably accessing session asynchronously and missing awaits.");
      }
      const key = await getSessionKey(ctx);
      if (!key) {
        ctx[prop] = undefined;
        return await next();
      }
      let cached = cache.get(key);
      if (cached) {
        debug(`(${updId}) found cached session, reusing from cache`);
        ++cached.counter;
      } else {
        debug(`(${updId}) did not find cached session`);
        let promise = concurrents.get(key);
        if (promise)
          debug(`(${updId}) found a concurrent request, reusing promise`);
        else {
          debug(`(${updId}) fetching from upstream store`);
          promise = store.get(key);
        }
        concurrents.set(key, promise);
        const upstream = await promise;
        concurrents.delete(key);
        debug(`(${updId}) updating cache`);
        const c2 = cache.get(key);
        if (c2) {
          c2.counter++;
          cached = c2;
        } else {
          cached = { ref: upstream !== null && upstream !== undefined ? upstream : (_a5 = options === null || options === undefined ? undefined : options.defaultSession) === null || _a5 === undefined ? undefined : _a5.call(options, ctx), counter: 1 };
          cache.set(key, cached);
        }
      }
      const c = cached;
      let touched = false;
      Object.defineProperty(ctx, prop, {
        get() {
          releaseChecks();
          touched = true;
          return c.ref;
        },
        set(value) {
          releaseChecks();
          touched = true;
          c.ref = value;
        }
      });
      try {
        await next();
        released = true;
      } finally {
        if (--c.counter === 0) {
          debug(`(${updId}) refcounter reached 0, removing cached`);
          cache.delete(key);
        }
        debug(`(${updId}) middlewares completed, checking session`);
        if (touched)
          if (c.ref == null) {
            debug(`(${updId}) ctx.${prop} missing, removing from store`);
            await store.delete(key);
          } else {
            debug(`(${updId}) ctx.${prop} found, updating store`);
            await store.set(key, c.ref);
          }
      }
    };
  };
  var defaultGetSessionKey = function(ctx) {
    var _a4, _b;
    const fromId = (_a4 = ctx.from) === null || _a4 === undefined ? undefined : _a4.id;
    const chatId = (_b = ctx.chat) === null || _b === undefined ? undefined : _b.id;
    if (fromId == null || chatId == null)
      return;
    return `${fromId}:${chatId}`;
  };
  var isSessionContext = function(ctx) {
    return "session" in ctx;
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSessionContext = exports.MemorySessionStore = exports.session = undefined;
  var debug_1 = __importDefault(require_src());
  var debug = (0, debug_1.default)("telegraf:session");
  exports.session = session;

  class MemorySessionStore {
    constructor(ttl = Infinity) {
      this.ttl = ttl;
      this.store = new Map;
    }
    get(name) {
      const entry = this.store.get(name);
      if (entry == null) {
        return;
      } else if (entry.expires < Date.now()) {
        this.delete(name);
        return;
      }
      return entry.session;
    }
    set(name, value) {
      const now = Date.now();
      this.store.set(name, { session: value, expires: now + this.ttl });
    }
    delete(name) {
      this.store.delete(name);
    }
  }
  exports.MemorySessionStore = MemorySessionStore;
  exports.isSessionContext = isSessionContext;
});

// node_modules/telegraf/lib/scenes/context.js
var require_context2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var composer_1 = __importDefault(require_composer());
  var debug_1 = __importDefault(require_src());
  var debug = (0, debug_1.default)("telegraf:scenes:context");
  var noop = () => Promise.resolve();
  var now = () => Math.floor(Date.now() / 1000);

  class SceneContextScene {
    constructor(ctx, scenes, options) {
      this.ctx = ctx;
      this.scenes = scenes;
      this.leaving = false;
      const fallbackSessionDefault = {};
      this.options = { defaultSession: fallbackSessionDefault, ...options };
    }
    get session() {
      var _a4, _b;
      const defaultSession = Object.assign({}, this.options.defaultSession);
      let session = (_b = (_a4 = this.ctx.session) === null || _a4 === undefined ? undefined : _a4.__scenes) !== null && _b !== undefined ? _b : defaultSession;
      if (session.expires !== undefined && session.expires < now()) {
        session = defaultSession;
      }
      if (this.ctx.session === undefined) {
        this.ctx.session = { __scenes: session };
      } else {
        this.ctx.session.__scenes = session;
      }
      return session;
    }
    get state() {
      var _a4;
      var _b;
      return (_a4 = (_b = this.session).state) !== null && _a4 !== undefined ? _a4 : _b.state = {};
    }
    set state(value) {
      this.session.state = { ...value };
    }
    get current() {
      var _a4;
      const sceneId = (_a4 = this.session.current) !== null && _a4 !== undefined ? _a4 : this.options.default;
      return sceneId === undefined || !this.scenes.has(sceneId) ? undefined : this.scenes.get(sceneId);
    }
    reset() {
      if (this.ctx.session !== undefined)
        this.ctx.session.__scenes = Object.assign({}, this.options.defaultSession);
    }
    async enter(sceneId, initialState = {}, silent = false) {
      var _a4, _b;
      if (!this.scenes.has(sceneId)) {
        throw new Error(`Can't find scene: ${sceneId}`);
      }
      if (!silent) {
        await this.leave();
      }
      debug("Entering scene", sceneId, initialState, silent);
      this.session.current = sceneId;
      this.state = initialState;
      const ttl = (_b = (_a4 = this.current) === null || _a4 === undefined ? undefined : _a4.ttl) !== null && _b !== undefined ? _b : this.options.ttl;
      if (ttl !== undefined) {
        this.session.expires = now() + ttl;
      }
      if (this.current === undefined || silent) {
        return;
      }
      const handler = "enterMiddleware" in this.current && typeof this.current.enterMiddleware === "function" ? this.current.enterMiddleware() : this.current.middleware();
      return await handler(this.ctx, noop);
    }
    reenter() {
      return this.session.current === undefined ? undefined : this.enter(this.session.current, this.state);
    }
    async leave() {
      if (this.leaving)
        return;
      debug("Leaving scene");
      try {
        this.leaving = true;
        if (this.current === undefined) {
          return;
        }
        const handler = "leaveMiddleware" in this.current && typeof this.current.leaveMiddleware === "function" ? this.current.leaveMiddleware() : composer_1.default.passThru();
        await handler(this.ctx, noop);
        return this.reset();
      } finally {
        this.leaving = false;
      }
    }
  }
  exports.default = SceneContextScene;
});

// node_modules/telegraf/lib/scenes/stage.js
var require_stage = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Stage = undefined;
  var session_1 = require_session();
  var context_1 = __importDefault(require_context2());
  var composer_1 = require_composer();

  class Stage extends composer_1.Composer {
    constructor(scenes = [], options) {
      super();
      this.options = { ...options };
      this.scenes = new Map;
      scenes.forEach((scene) => this.register(scene));
    }
    register(...scenes) {
      scenes.forEach((scene) => {
        if ((scene === null || scene === undefined ? undefined : scene.id) == null || typeof scene.middleware !== "function") {
          throw new Error("telegraf: Unsupported scene");
        }
        this.scenes.set(scene.id, scene);
      });
      return this;
    }
    middleware() {
      const handler = composer_1.Composer.compose([
        (ctx, next) => {
          const scenes = this.scenes;
          const scene = new context_1.default(ctx, scenes, this.options);
          ctx.scene = scene;
          return next();
        },
        super.middleware(),
        composer_1.Composer.lazy((ctx) => {
          var _a4;
          return (_a4 = ctx.scene.current) !== null && _a4 !== undefined ? _a4 : composer_1.Composer.passThru();
        })
      ]);
      return composer_1.Composer.optional(session_1.isSessionContext, handler);
    }
    static enter(...args) {
      return (ctx) => ctx.scene.enter(...args);
    }
    static reenter(...args) {
      return (ctx) => ctx.scene.reenter(...args);
    }
    static leave(...args) {
      return (ctx) => ctx.scene.leave(...args);
    }
  }
  exports.Stage = Stage;
});

// node_modules/telegraf/lib/scenes/base.js
var require_base = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseScene = undefined;
  var composer_1 = __importDefault(require_composer());
  var { compose } = composer_1.default;

  class BaseScene extends composer_1.default {
    constructor(id, options) {
      const opts = {
        handlers: [],
        enterHandlers: [],
        leaveHandlers: [],
        ...options
      };
      super(...opts.handlers);
      this.id = id;
      this.ttl = opts.ttl;
      this.enterHandler = compose(opts.enterHandlers);
      this.leaveHandler = compose(opts.leaveHandlers);
    }
    enter(...fns) {
      this.enterHandler = compose([this.enterHandler, ...fns]);
      return this;
    }
    leave(...fns) {
      this.leaveHandler = compose([this.leaveHandler, ...fns]);
      return this;
    }
    enterMiddleware() {
      return this.enterHandler;
    }
    leaveMiddleware() {
      return this.leaveHandler;
    }
  }
  exports.BaseScene = BaseScene;
  exports.default = BaseScene;
});

// node_modules/telegraf/lib/scenes/wizard/context.js
var require_context3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class WizardContextWizard {
    constructor(ctx, steps) {
      var _a4;
      this.ctx = ctx;
      this.steps = steps;
      this.state = ctx.scene.state;
      this.cursor = (_a4 = ctx.scene.session.cursor) !== null && _a4 !== undefined ? _a4 : 0;
    }
    get step() {
      return this.steps[this.cursor];
    }
    get cursor() {
      return this.ctx.scene.session.cursor;
    }
    set cursor(cursor) {
      this.ctx.scene.session.cursor = cursor;
    }
    selectStep(index) {
      this.cursor = index;
      return this;
    }
    next() {
      return this.selectStep(this.cursor + 1);
    }
    back() {
      return this.selectStep(this.cursor - 1);
    }
  }
  exports.default = WizardContextWizard;
});

// node_modules/telegraf/lib/scenes/wizard/index.js
var require_wizard = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WizardScene = undefined;
  var base_1 = __importDefault(require_base());
  var context_1 = __importDefault(require_context3());
  var composer_1 = __importDefault(require_composer());

  class WizardScene extends base_1.default {
    constructor(id, options, ...steps) {
      let opts;
      let s;
      if (typeof options === "function" || "middleware" in options) {
        opts = undefined;
        s = [options, ...steps];
      } else {
        opts = options;
        s = steps;
      }
      super(id, opts);
      this.steps = s;
    }
    middleware() {
      return composer_1.default.compose([
        (ctx, next) => {
          ctx.wizard = new context_1.default(ctx, this.steps);
          return next();
        },
        super.middleware(),
        (ctx, next) => {
          if (ctx.wizard.step === undefined) {
            ctx.wizard.selectStep(0);
            return ctx.scene.leave();
          }
          return composer_1.default.unwrap(ctx.wizard.step)(ctx, next);
        }
      ]);
    }
    enterMiddleware() {
      return composer_1.default.compose([this.enterHandler, this.middleware()]);
    }
  }
  exports.WizardScene = WizardScene;
});

// node_modules/telegraf/lib/scenes/index.js
var require_scenes = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WizardContextWizard = exports.WizardScene = exports.BaseScene = exports.SceneContextScene = exports.Stage = undefined;
  var stage_1 = require_stage();
  Object.defineProperty(exports, "Stage", { enumerable: true, get: function() {
    return stage_1.Stage;
  } });
  var context_1 = require_context2();
  Object.defineProperty(exports, "SceneContextScene", { enumerable: true, get: function() {
    return __importDefault(context_1).default;
  } });
  var base_1 = require_base();
  Object.defineProperty(exports, "BaseScene", { enumerable: true, get: function() {
    return base_1.BaseScene;
  } });
  var wizard_1 = require_wizard();
  Object.defineProperty(exports, "WizardScene", { enumerable: true, get: function() {
    return wizard_1.WizardScene;
  } });
  var context_2 = require_context3();
  Object.defineProperty(exports, "WizardContextWizard", { enumerable: true, get: function() {
    return __importDefault(context_2).default;
  } });
});

// node_modules/telegraf/lib/scenes.js
var require_scenes2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_scenes(), exports);
});

// node_modules/telegraf/lib/index.js
var require_lib = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k in mod2)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
          __createBinding(result, mod2, k);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Scenes = exports.MemorySessionStore = exports.session = exports.deunionize = exports.Format = exports.Input = exports.Markup = exports.Types = exports.Telegram = exports.TelegramError = exports.Router = exports.Composer = exports.Context = exports.Telegraf = undefined;
  var telegraf_1 = require_telegraf();
  Object.defineProperty(exports, "Telegraf", { enumerable: true, get: function() {
    return telegraf_1.Telegraf;
  } });
  var context_1 = require_context();
  Object.defineProperty(exports, "Context", { enumerable: true, get: function() {
    return context_1.Context;
  } });
  var composer_1 = require_composer();
  Object.defineProperty(exports, "Composer", { enumerable: true, get: function() {
    return composer_1.Composer;
  } });
  var router_1 = require_router();
  Object.defineProperty(exports, "Router", { enumerable: true, get: function() {
    return router_1.Router;
  } });
  var error_1 = require_error();
  Object.defineProperty(exports, "TelegramError", { enumerable: true, get: function() {
    return error_1.TelegramError;
  } });
  var telegram_1 = require_telegram();
  Object.defineProperty(exports, "Telegram", { enumerable: true, get: function() {
    return telegram_1.Telegram;
  } });
  exports.Types = __importStar(require_telegram_types());
  exports.Markup = __importStar(require_markup());
  exports.Input = __importStar(require_input());
  exports.Format = __importStar(require_format2());
  var deunionize_1 = require_deunionize();
  Object.defineProperty(exports, "deunionize", { enumerable: true, get: function() {
    return deunionize_1.deunionize;
  } });
  var session_1 = require_session();
  Object.defineProperty(exports, "session", { enumerable: true, get: function() {
    return session_1.session;
  } });
  Object.defineProperty(exports, "MemorySessionStore", { enumerable: true, get: function() {
    return session_1.MemorySessionStore;
  } });
  exports.Scenes = __importStar(require_scenes2());
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS((exports, module) => {
  (function(module2, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor;
      ctor.prototype.constructor = ctor;
    }
    function BN(number8, base3, endian) {
      if (BN.isBN(number8)) {
        return number8;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number8 !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number8 || 0, base3 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN;
    } else {
      exports2.BN = BN;
    }
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = import.meta.require("buffer").Buffer;
      }
    } catch (e) {
    }
    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN.prototype._init = function init(number8, base3, endian) {
      if (typeof number8 === "number") {
        return this._initNumber(number8, base3, endian);
      }
      if (typeof number8 === "object") {
        return this._initArray(number8, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number8 = number8.toString().replace(/\s+/g, "");
      var start = 0;
      if (number8[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number8.length) {
        if (base3 === 16) {
          this._parseHex(number8, start, endian);
        } else {
          this._parseBase(number8, base3, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN.prototype._initNumber = function _initNumber(number8, base3, endian) {
      if (number8 < 0) {
        this.negative = 1;
        number8 = -number8;
      }
      if (number8 < 67108864) {
        this.words = [number8 & 67108863];
        this.length = 1;
      } else if (number8 < 4503599627370496) {
        this.words = [
          number8 & 67108863,
          number8 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number8 < 9007199254740992);
        this.words = [
          number8 & 67108863,
          number8 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base3, endian);
    };
    BN.prototype._initArray = function _initArray(number8, base3, endian) {
      assert2(typeof number8.length === "number");
      if (number8.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number8.length / 3);
      this.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i = number8.length - 1, j = 0;i >= 0; i -= 3) {
          w = number8[i] | number8[i - 1] << 8 | number8[i - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0;i < number8.length; i += 3) {
          w = number8[i] | number8[i + 1] << 8 | number8[i + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string10, index) {
      var c = string10.charCodeAt(index);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert2(false, "Invalid character in " + string10);
      }
    }
    function parseHexByte(string10, lowerBound, index) {
      var r = parseHex4Bits(string10, index);
      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string10, index - 1) << 4;
      }
      return r;
    }
    BN.prototype._parseHex = function _parseHex(number8, start, endian) {
      this.length = Math.ceil((number8.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i = number8.length - 1;i >= start; i -= 2) {
          w = parseHexByte(number8, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number8.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start;i < number8.length; i += 2) {
          w = parseHexByte(number8, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul2) {
      var r = 0;
      var b = 0;
      var len = Math.min(str.length, end);
      for (var i = start;i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul2;
        if (c >= 49) {
          b = c - 49 + 10;
        } else if (c >= 17) {
          b = c - 17 + 10;
        } else {
          b = c;
        }
        assert2(c >= 0 && b < mul2, "Invalid character");
        r += b;
      }
      return r;
    }
    BN.prototype._parseBase = function _parseBase(number8, base3, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base3) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number8.length - start;
      var mod3 = total % limbLen;
      var end = Math.min(total, total - mod3) + start;
      var word = 0;
      for (var i = start;i < end; i += limbLen) {
        word = parseBase(number8, i, i + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod3 !== 0) {
        var pow4 = 1;
        word = parseBase(number8, i, number8.length, base3);
        for (i = 0;i < mod3; i++) {
          pow4 *= base3;
        }
        this.imuln(pow4);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src) {
      dest.words = src.words;
      dest.length = src.length;
      dest.negative = src.negative;
      dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };
    BN.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
      } catch (e) {
        BN.prototype.inspect = inspect;
      }
    } else {
      BN.prototype.inspect = inspect;
    }
    function inspect() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64000000,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      24300000,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN.prototype.toString = function toString(base3, padding) {
      base3 = base3 || 10;
      padding = padding | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0;i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modrn(groupBase).toString(base3);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros2[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer2, endian, length);
      };
    }
    BN.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
      }
      return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert2(byteLength <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength);
      return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0;i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0;i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r = 0;
      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r++;
      }
      return r;
    };
    BN.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0;bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 1;
      }
      return w;
    }
    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r = 0;
      for (var i = 0;i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26)
          break;
      }
      return r;
    };
    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0;i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN.prototype.iuand = function iuand(num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0;i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this._strip();
    };
    BN.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN.prototype.iuxor = function iuxor(num) {
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0;i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0;i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN.prototype.iadd = function iadd(num) {
      var r;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0;i < b.length; i++) {
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      for (;carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN.prototype.add = function add(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0;i < b.length; i++) {
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      for (;carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b = num.words[0] | 0;
      var r = a * b;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1;k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i = k - j | 0;
          a = self2.words[i] | 0;
          b = num.words[j] | 0;
          r = a * b + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo(self2, num, out) {
      var a = self2.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0;k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i = k - j;
          var a = self2.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x, y) {
      this.x = x;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;
      for (var i = 0;i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1)
        return x;
      var rb = 0;
      for (var i = 0;i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0;i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);
      for (var s = 1;s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for (var p = 0;p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j = 0;j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;
      for (N = N / 2 | 0;N; N = N >>> 1) {
        i++;
      }
      return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1)
        return;
      for (var i = 0;i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;
      for (var i = 0;i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 67108863;
        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;
      for (var i = 0;i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i = 2 * len;i < N; ++i) {
        rws[i] = 0;
      }
      assert2(carry === 0);
      assert2((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);
      for (var i = 0;i < N; i++) {
        ph[i] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);
      var _ = this.stub(N);
      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _, rwst, iwst, N, rbt);
      this.transform(nrws, _, nrwst, niwst, N, rbt);
      for (var i = 0;i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }
      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _, N, rbt);
      this.conjugate(rmws, _, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out._strip();
    };
    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i = 0;i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0)
        return new BN(1);
      var res = this;
      for (var i = 0;i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0)
          break;
      }
      if (++i < w.length) {
        for (var q = res.sqr();i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i;
      if (r !== 0) {
        var carry = 0;
        for (i = 0;i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i = this.length - 1;i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }
        for (i = 0;i < s; i++) {
          this.words[i] = 0;
        }
        this.length += s;
      }
      return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask2 = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0;i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
      }
      if (s === 0) {
      } else if (this.length > s) {
        this.length -= s;
        for (i = 0;i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1;i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask2;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s)
        return false;
      var w = this.words[s];
      return !!(w & q);
    };
    BN.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s) {
        return this;
      }
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask2 = 67108863 ^ 67108863 >>> r << r;
        this.words[this.length - 1] &= mask2;
      }
      return this._strip();
    };
    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0;i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0;i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul2, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0;i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul2;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (;i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i = 0;i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
      var m = a.length - b.length;
      var q;
      if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0;i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1;j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q._strip();
      }
      a._strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }
      var div2, mod3, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div2 = res.div.neg();
        }
        if (mode !== "div") {
          mod3 = res.mod.neg();
          if (positive && mod3.negative !== 0) {
            mod3.iadd(num);
          }
        }
        return {
          div: div2,
          mod: mod3
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div2 = res.div.neg();
        }
        return {
          div: div2,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod3 = res.mod.neg();
          if (positive && mod3.negative !== 0) {
            mod3.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod3
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod3 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod3.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN(1);
      var B = new BN(0);
      var C = new BN(0);
      var D = new BN(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1;(x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };
    BN.prototype._invmp = function _invmp(p) {
      assert2(p.negative === 0);
      assert2(!p.isZero());
      var a = this;
      var b = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1;(a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
      for (var shift = 0;a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r = a.cmp(b);
        if (r < 0) {
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };
    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }
      var carry = q;
      for (var i = s;carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b)
          continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };
    BN.red = function red(num) {
      return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p) {
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== undefined) {
          r.strip();
        } else {
          r._strip();
        }
      }
      return r;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output2) {
      var mask2 = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0;i < outLen; i++) {
        output2.words[i] = input.words[i];
      }
      output2.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output2.words[output2.length++] = prev & mask2;
      for (i = 10;i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0;i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0;i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime;
      if (name === "k256") {
        prime = new K256;
      } else if (name === "p224") {
        prime = new P224;
      } else if (name === "p192") {
        prime = new P192;
      } else if (name === "p25519") {
        prime = new P25519;
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime;
      return prime;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert2(a.negative === 0, "red works only with positives");
      assert2(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert2((a.negative | b.negative) === 0, "red works only with positives");
      assert2(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow4 = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow4);
      }
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert2(!q.isZero());
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c = this.pow(z2, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0;tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert2(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this);
      wnd[1] = a;
      for (var i = 2;i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1;i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1;j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
      if (a.isZero() || b.isZero())
        return new BN(0)._forceRed(this);
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(typeof module === "undefined" || module, exports);
});

// node_modules/@solana/web3.js/node_modules/bs58/node_modules/base-x/src/index.js
var require_src2 = __commonJS((exports, module) => {
  var base3 = function(ALPHABET) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE2 = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE2) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE2);
    function encode3(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer.from(source);
      }
      if (!_Buffer.isBuffer(source)) {
        throw new TypeError("Expected Buffer");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE2 >>> 0;
          carry = carry / BASE2 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return _Buffer.alloc(0);
      }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
          carry += BASE2 * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        psz++;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
      vch.fill(0, 0, zeroes);
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode2(string10) {
      var buffer = decodeUnsafe(string10);
      if (buffer) {
        return buffer;
      }
      throw new Error("Non-base" + BASE2 + " character");
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode2
    };
  };
  var _Buffer = require_safe_buffer().Buffer;
  module.exports = base3;
});

// node_modules/@solana/web3.js/node_modules/bs58/index.js
var require_bs58 = __commonJS((exports, module) => {
  var basex = require_src2();
  var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  module.exports = basex(ALPHABET);
});

// node_modules/borsh/node_modules/bs58/node_modules/base-x/src/index.js
var require_src3 = __commonJS((exports, module) => {
  var base3 = function(ALPHABET) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0;i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE2 = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE2) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE2);
    function encode3(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer.from(source);
      }
      if (!_Buffer.isBuffer(source)) {
        throw new TypeError("Expected Buffer");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1;(carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE2 >>> 0;
          carry = carry / BASE2 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return _Buffer.alloc(0);
      }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1;(carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
          carry += BASE2 * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        psz++;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
      vch.fill(0, 0, zeroes);
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode2(string10) {
      var buffer = decodeUnsafe(string10);
      if (buffer) {
        return buffer;
      }
      throw new Error("Non-base" + BASE2 + " character");
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode2
    };
  };
  var _Buffer = require_safe_buffer().Buffer;
  module.exports = base3;
});

// node_modules/borsh/node_modules/bs58/index.js
var require_bs582 = __commonJS((exports, module) => {
  var basex = require_src3();
  var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  module.exports = basex(ALPHABET);
});

// node_modules/text-encoding-utf-8/lib/encoding.lib.js
var require_encoding_lib = __commonJS((exports) => {
  var inRange = function(a, min2, max2) {
    return min2 <= a && a <= max2;
  };
  var ToDictionary = function(o) {
    if (o === undefined)
      return {};
    if (o === Object(o))
      return o;
    throw TypeError("Could not convert argument to dictionary");
  };
  var stringToCodePoints = function(string10) {
    var s = String(string10);
    var n = s.length;
    var i = 0;
    var u = [];
    while (i < n) {
      var c = s.charCodeAt(i);
      if (c < 55296 || c > 57343) {
        u.push(c);
      } else if (56320 <= c && c <= 57343) {
        u.push(65533);
      } else if (55296 <= c && c <= 56319) {
        if (i === n - 1) {
          u.push(65533);
        } else {
          var d = string10.charCodeAt(i + 1);
          if (56320 <= d && d <= 57343) {
            var a = c & 1023;
            var b = d & 1023;
            u.push(65536 + (a << 10) + b);
            i += 1;
          } else {
            u.push(65533);
          }
        }
      }
      i += 1;
    }
    return u;
  };
  var codePointsToString = function(code_points) {
    var s = "";
    for (var i = 0;i < code_points.length; ++i) {
      var cp = code_points[i];
      if (cp <= 65535) {
        s += String.fromCharCode(cp);
      } else {
        cp -= 65536;
        s += String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
      }
    }
    return s;
  };
  var Stream = function(tokens) {
    this.tokens = [].slice.call(tokens);
  };
  var decoderError = function(fatal, opt_code_point) {
    if (fatal)
      throw TypeError("Decoder error");
    return opt_code_point || 65533;
  };
  var TextDecoder2 = function(encoding4, options) {
    if (!(this instanceof TextDecoder2)) {
      return new TextDecoder2(encoding4, options);
    }
    encoding4 = encoding4 !== undefined ? String(encoding4).toLowerCase() : DEFAULT_ENCODING;
    if (encoding4 !== DEFAULT_ENCODING) {
      throw new Error("Encoding not supported. Only utf-8 is supported");
    }
    options = ToDictionary(options);
    this._streaming = false;
    this._BOMseen = false;
    this._decoder = null;
    this._fatal = Boolean(options["fatal"]);
    this._ignoreBOM = Boolean(options["ignoreBOM"]);
    Object.defineProperty(this, "encoding", { value: "utf-8" });
    Object.defineProperty(this, "fatal", { value: this._fatal });
    Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
  };
  var TextEncoder2 = function(encoding4, options) {
    if (!(this instanceof TextEncoder2))
      return new TextEncoder2(encoding4, options);
    encoding4 = encoding4 !== undefined ? String(encoding4).toLowerCase() : DEFAULT_ENCODING;
    if (encoding4 !== DEFAULT_ENCODING) {
      throw new Error("Encoding not supported. Only utf-8 is supported");
    }
    options = ToDictionary(options);
    this._streaming = false;
    this._encoder = null;
    this._options = { fatal: Boolean(options["fatal"]) };
    Object.defineProperty(this, "encoding", { value: "utf-8" });
  };
  var UTF8Decoder = function(options) {
    var fatal = options.fatal;
    var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
    this.handler = function(stream, bite) {
      if (bite === end_of_stream && utf8_bytes_needed !== 0) {
        utf8_bytes_needed = 0;
        return decoderError(fatal);
      }
      if (bite === end_of_stream)
        return finished;
      if (utf8_bytes_needed === 0) {
        if (inRange(bite, 0, 127)) {
          return bite;
        }
        if (inRange(bite, 194, 223)) {
          utf8_bytes_needed = 1;
          utf8_code_point = bite - 192;
        } else if (inRange(bite, 224, 239)) {
          if (bite === 224)
            utf8_lower_boundary = 160;
          if (bite === 237)
            utf8_upper_boundary = 159;
          utf8_bytes_needed = 2;
          utf8_code_point = bite - 224;
        } else if (inRange(bite, 240, 244)) {
          if (bite === 240)
            utf8_lower_boundary = 144;
          if (bite === 244)
            utf8_upper_boundary = 143;
          utf8_bytes_needed = 3;
          utf8_code_point = bite - 240;
        } else {
          return decoderError(fatal);
        }
        utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
        return null;
      }
      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
        utf8_lower_boundary = 128;
        utf8_upper_boundary = 191;
        stream.prepend(bite);
        return decoderError(fatal);
      }
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      utf8_bytes_seen += 1;
      utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
      if (utf8_bytes_seen !== utf8_bytes_needed)
        return null;
      var code_point = utf8_code_point;
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      return code_point;
    };
  };
  var UTF8Encoder = function(options) {
    var fatal = options.fatal;
    this.handler = function(stream, code_point) {
      if (code_point === end_of_stream)
        return finished;
      if (inRange(code_point, 0, 127))
        return code_point;
      var count, offset;
      if (inRange(code_point, 128, 2047)) {
        count = 1;
        offset = 192;
      } else if (inRange(code_point, 2048, 65535)) {
        count = 2;
        offset = 224;
      } else if (inRange(code_point, 65536, 1114111)) {
        count = 3;
        offset = 240;
      }
      var bytes7 = [(code_point >> 6 * count) + offset];
      while (count > 0) {
        var temp = code_point >> 6 * (count - 1);
        bytes7.push(128 | temp & 63);
        count -= 1;
      }
      return bytes7;
    };
  };
  var end_of_stream = -1;
  Stream.prototype = {
    endOfStream: function() {
      return !this.tokens.length;
    },
    read: function() {
      if (!this.tokens.length)
        return end_of_stream;
      return this.tokens.shift();
    },
    prepend: function(token) {
      if (Array.isArray(token)) {
        var tokens = token;
        while (tokens.length)
          this.tokens.unshift(tokens.pop());
      } else {
        this.tokens.unshift(token);
      }
    },
    push: function(token) {
      if (Array.isArray(token)) {
        var tokens = token;
        while (tokens.length)
          this.tokens.push(tokens.shift());
      } else {
        this.tokens.push(token);
      }
    }
  };
  var finished = -1;
  var DEFAULT_ENCODING = "utf-8";
  TextDecoder2.prototype = {
    decode: function decode(input, options) {
      var bytes7;
      if (typeof input === "object" && input instanceof ArrayBuffer) {
        bytes7 = new Uint8Array(input);
      } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
        bytes7 = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
      } else {
        bytes7 = new Uint8Array(0);
      }
      options = ToDictionary(options);
      if (!this._streaming) {
        this._decoder = new UTF8Decoder({ fatal: this._fatal });
        this._BOMseen = false;
      }
      this._streaming = Boolean(options["stream"]);
      var input_stream = new Stream(bytes7);
      var code_points = [];
      var result;
      while (!input_stream.endOfStream()) {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (result === null)
          continue;
        if (Array.isArray(result))
          code_points.push.apply(code_points, result);
        else
          code_points.push(result);
      }
      if (!this._streaming) {
        do {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (result === null)
            continue;
          if (Array.isArray(result))
            code_points.push.apply(code_points, result);
          else
            code_points.push(result);
        } while (!input_stream.endOfStream());
        this._decoder = null;
      }
      if (code_points.length) {
        if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
          if (code_points[0] === 65279) {
            this._BOMseen = true;
            code_points.shift();
          } else {
            this._BOMseen = true;
          }
        }
      }
      return codePointsToString(code_points);
    }
  };
  TextEncoder2.prototype = {
    encode: function encode(opt_string, options) {
      opt_string = opt_string ? String(opt_string) : "";
      options = ToDictionary(options);
      if (!this._streaming)
        this._encoder = new UTF8Encoder(this._options);
      this._streaming = Boolean(options["stream"]);
      var bytes7 = [];
      var input_stream = new Stream(stringToCodePoints(opt_string));
      var result;
      while (!input_stream.endOfStream()) {
        result = this._encoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (Array.isArray(result))
          bytes7.push.apply(bytes7, result);
        else
          bytes7.push(result);
      }
      if (!this._streaming) {
        while (true) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (Array.isArray(result))
            bytes7.push.apply(bytes7, result);
          else
            bytes7.push(result);
        }
        this._encoder = null;
      }
      return new Uint8Array(bytes7);
    }
  };
  exports.TextEncoder = TextEncoder2;
  exports.TextDecoder = TextDecoder2;
});

// node_modules/borsh/lib/index.js
var require_lib2 = __commonJS((exports) => {
  var baseEncode = function(value) {
    if (typeof value === "string") {
      value = Buffer.from(value, "utf8");
    }
    return bs58_1.default.encode(Buffer.from(value));
  };
  var baseDecode = function(value) {
    return Buffer.from(bs58_1.default.decode(value));
  };
  var handlingRangeError = function(target, propertyKey, propertyDescriptor) {
    const originalMethod = propertyDescriptor.value;
    propertyDescriptor.value = function(...args) {
      try {
        return originalMethod.apply(this, args);
      } catch (e) {
        if (e instanceof RangeError) {
          const code = e.code;
          if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
            throw new BorshError("Reached the end of buffer when deserializing");
          }
        }
        throw e;
      }
    };
  };
  var capitalizeFirstLetter = function(string10) {
    return string10.charAt(0).toUpperCase() + string10.slice(1);
  };
  var serializeField = function(schema, fieldName, value, fieldType, writer) {
    try {
      if (typeof fieldType === "string") {
        writer[`write${capitalizeFirstLetter(fieldType)}`](value);
      } else if (fieldType instanceof Array) {
        if (typeof fieldType[0] === "number") {
          if (value.length !== fieldType[0]) {
            throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
          }
          writer.writeFixedArray(value);
        } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
          if (value.length !== fieldType[1]) {
            throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
          }
          for (let i = 0;i < fieldType[1]; i++) {
            serializeField(schema, null, value[i], fieldType[0], writer);
          }
        } else {
          writer.writeArray(value, (item) => {
            serializeField(schema, fieldName, item, fieldType[0], writer);
          });
        }
      } else if (fieldType.kind !== undefined) {
        switch (fieldType.kind) {
          case "option": {
            if (value === null || value === undefined) {
              writer.writeU8(0);
            } else {
              writer.writeU8(1);
              serializeField(schema, fieldName, value, fieldType.type, writer);
            }
            break;
          }
          case "map": {
            writer.writeU32(value.size);
            value.forEach((val, key) => {
              serializeField(schema, fieldName, key, fieldType.key, writer);
              serializeField(schema, fieldName, val, fieldType.value, writer);
            });
            break;
          }
          default:
            throw new BorshError(`FieldType ${fieldType} unrecognized`);
        }
      } else {
        serializeStruct(schema, value, writer);
      }
    } catch (error) {
      if (error instanceof BorshError) {
        error.addToFieldPath(fieldName);
      }
      throw error;
    }
  };
  var serializeStruct = function(schema, obj, writer) {
    if (typeof obj.borshSerialize === "function") {
      obj.borshSerialize(writer);
      return;
    }
    const structSchema = schema.get(obj.constructor);
    if (!structSchema) {
      throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
    }
    if (structSchema.kind === "struct") {
      structSchema.fields.map(([fieldName, fieldType]) => {
        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
      });
    } else if (structSchema.kind === "enum") {
      const name = obj[structSchema.field];
      for (let idx = 0;idx < structSchema.values.length; ++idx) {
        const [fieldName, fieldType] = structSchema.values[idx];
        if (fieldName === name) {
          writer.writeU8(idx);
          serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
          break;
        }
      }
    } else {
      throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
    }
  };
  var serialize = function(schema, obj, Writer = BinaryWriter) {
    const writer = new Writer;
    serializeStruct(schema, obj, writer);
    return writer.toArray();
  };
  var deserializeField = function(schema, fieldName, fieldType, reader) {
    try {
      if (typeof fieldType === "string") {
        return reader[`read${capitalizeFirstLetter(fieldType)}`]();
      }
      if (fieldType instanceof Array) {
        if (typeof fieldType[0] === "number") {
          return reader.readFixedArray(fieldType[0]);
        } else if (typeof fieldType[1] === "number") {
          const arr = [];
          for (let i = 0;i < fieldType[1]; i++) {
            arr.push(deserializeField(schema, null, fieldType[0], reader));
          }
          return arr;
        } else {
          return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
        }
      }
      if (fieldType.kind === "option") {
        const option = reader.readU8();
        if (option) {
          return deserializeField(schema, fieldName, fieldType.type, reader);
        }
        return;
      }
      if (fieldType.kind === "map") {
        let map = new Map;
        const length = reader.readU32();
        for (let i = 0;i < length; i++) {
          const key = deserializeField(schema, fieldName, fieldType.key, reader);
          const val = deserializeField(schema, fieldName, fieldType.value, reader);
          map.set(key, val);
        }
        return map;
      }
      return deserializeStruct(schema, fieldType, reader);
    } catch (error) {
      if (error instanceof BorshError) {
        error.addToFieldPath(fieldName);
      }
      throw error;
    }
  };
  var deserializeStruct = function(schema, classType, reader) {
    if (typeof classType.borshDeserialize === "function") {
      return classType.borshDeserialize(reader);
    }
    const structSchema = schema.get(classType);
    if (!structSchema) {
      throw new BorshError(`Class ${classType.name} is missing in schema`);
    }
    if (structSchema.kind === "struct") {
      const result = {};
      for (const [fieldName, fieldType] of schema.get(classType).fields) {
        result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
      }
      return new classType(result);
    }
    if (structSchema.kind === "enum") {
      const idx = reader.readU8();
      if (idx >= structSchema.values.length) {
        throw new BorshError(`Enum index: ${idx} is out of range`);
      }
      const [fieldName, fieldType] = structSchema.values[idx];
      const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
      return new classType({ [fieldName]: fieldValue });
    }
    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
  };
  var deserialize = function(schema, classType, buffer, Reader = BinaryReader) {
    const reader = new Reader(buffer);
    const result = deserializeStruct(schema, classType, reader);
    if (reader.offset < buffer.length) {
      throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
    }
    return result;
  };
  var deserializeUnchecked = function(schema, classType, buffer, Reader = BinaryReader) {
    const reader = new Reader(buffer);
    return deserializeStruct(schema, classType, reader);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1;i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __importStar = exports && exports.__importStar || function(mod3) {
    if (mod3 && mod3.__esModule)
      return mod3;
    var result = {};
    if (mod3 != null) {
      for (var k in mod3)
        if (k !== "default" && Object.hasOwnProperty.call(mod3, k))
          __createBinding(result, mod3, k);
    }
    __setModuleDefault(result, mod3);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = undefined;
  var bn_js_1 = __importDefault(require_bn());
  var bs58_1 = __importDefault(require_bs582());
  var encoding4 = __importStar(require_encoding_lib());
  var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding4.TextDecoder : TextDecoder;
  var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
  exports.baseEncode = baseEncode;
  exports.baseDecode = baseDecode;
  var INITIAL_LENGTH = 1024;

  class BorshError extends Error {
    constructor(message) {
      super(message);
      this.fieldPath = [];
      this.originalMessage = message;
    }
    addToFieldPath(fieldName) {
      this.fieldPath.splice(0, 0, fieldName);
      this.message = this.originalMessage + ": " + this.fieldPath.join(".");
    }
  }
  exports.BorshError = BorshError;

  class BinaryWriter {
    constructor() {
      this.buf = Buffer.alloc(INITIAL_LENGTH);
      this.length = 0;
    }
    maybeResize() {
      if (this.buf.length < 16 + this.length) {
        this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
      }
    }
    writeU8(value) {
      this.maybeResize();
      this.buf.writeUInt8(value, this.length);
      this.length += 1;
    }
    writeU16(value) {
      this.maybeResize();
      this.buf.writeUInt16LE(value, this.length);
      this.length += 2;
    }
    writeU32(value) {
      this.maybeResize();
      this.buf.writeUInt32LE(value, this.length);
      this.length += 4;
    }
    writeU64(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
    }
    writeU128(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
    }
    writeU256(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
    }
    writeU512(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
    }
    writeBuffer(buffer) {
      this.buf = Buffer.concat([
        Buffer.from(this.buf.subarray(0, this.length)),
        buffer,
        Buffer.alloc(INITIAL_LENGTH)
      ]);
      this.length += buffer.length;
    }
    writeString(str) {
      this.maybeResize();
      const b = Buffer.from(str, "utf8");
      this.writeU32(b.length);
      this.writeBuffer(b);
    }
    writeFixedArray(array2) {
      this.writeBuffer(Buffer.from(array2));
    }
    writeArray(array2, fn) {
      this.maybeResize();
      this.writeU32(array2.length);
      for (const elem of array2) {
        this.maybeResize();
        fn(elem);
      }
    }
    toArray() {
      return this.buf.subarray(0, this.length);
    }
  }
  exports.BinaryWriter = BinaryWriter;

  class BinaryReader {
    constructor(buf) {
      this.buf = buf;
      this.offset = 0;
    }
    readU8() {
      const value = this.buf.readUInt8(this.offset);
      this.offset += 1;
      return value;
    }
    readU16() {
      const value = this.buf.readUInt16LE(this.offset);
      this.offset += 2;
      return value;
    }
    readU32() {
      const value = this.buf.readUInt32LE(this.offset);
      this.offset += 4;
      return value;
    }
    readU64() {
      const buf = this.readBuffer(8);
      return new bn_js_1.default(buf, "le");
    }
    readU128() {
      const buf = this.readBuffer(16);
      return new bn_js_1.default(buf, "le");
    }
    readU256() {
      const buf = this.readBuffer(32);
      return new bn_js_1.default(buf, "le");
    }
    readU512() {
      const buf = this.readBuffer(64);
      return new bn_js_1.default(buf, "le");
    }
    readBuffer(len) {
      if (this.offset + len > this.buf.length) {
        throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
      }
      const result = this.buf.slice(this.offset, this.offset + len);
      this.offset += len;
      return result;
    }
    readString() {
      const len = this.readU32();
      const buf = this.readBuffer(len);
      try {
        return textDecoder.decode(buf);
      } catch (e) {
        throw new BorshError(`Error decoding UTF-8 string: ${e}`);
      }
    }
    readFixedArray(len) {
      return new Uint8Array(this.readBuffer(len));
    }
    readArray(fn) {
      const len = this.readU32();
      const result = Array();
      for (let i = 0;i < len; ++i) {
        result.push(fn());
      }
      return result;
    }
  }
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU8", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU16", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU32", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU64", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU128", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU256", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU512", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readString", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readFixedArray", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readArray", null);
  exports.BinaryReader = BinaryReader;
  exports.serialize = serialize;
  exports.deserialize = deserialize;
  exports.deserializeUnchecked = deserializeUnchecked;
});

// node_modules/@solana/buffer-layout/lib/Layout.js
var require_Layout = __commonJS((exports) => {
  var checkUint8Array = function(b) {
    if (!(b instanceof Uint8Array)) {
      throw new TypeError("b must be a Uint8Array");
    }
  };
  var uint8ArrayToBuffer = function(b) {
    checkUint8Array(b);
    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
  };
  var nameWithProperty = function(name, lo) {
    if (lo.property) {
      return name + "[" + lo.property + "]";
    }
    return name;
  };
  var bindConstructorLayout = function(Class, layout) {
    if (typeof Class !== "function") {
      throw new TypeError("Class must be constructor");
    }
    if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
      throw new Error("Class is already bound to a layout");
    }
    if (!(layout && layout instanceof Layout)) {
      throw new TypeError("layout must be a Layout");
    }
    if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
      throw new Error("layout is already bound to a constructor");
    }
    Class.layout_ = layout;
    layout.boundConstructor_ = Class;
    layout.makeDestinationObject = () => new Class;
    Object.defineProperty(Class.prototype, "encode", {
      value(b, offset) {
        return layout.encode(this, b, offset);
      },
      writable: true
    });
    Object.defineProperty(Class, "decode", {
      value(b, offset) {
        return layout.decode(b, offset);
      },
      writable: true
    });
  };
  var divmodInt64 = function(src) {
    const hi32 = Math.floor(src / V2E32);
    const lo32 = src - hi32 * V2E32;
    return { hi32, lo32 };
  };
  var roundedInt64 = function(hi32, lo32) {
    return hi32 * V2E32 + lo32;
  };
  var fixBitwiseResult = function(v) {
    if (0 > v) {
      v += 4294967296;
    }
    return v;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = undefined;
  exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = undefined;
  var buffer_1 = import.meta.require("buffer");
  exports.checkUint8Array = checkUint8Array;
  exports.uint8ArrayToBuffer = uint8ArrayToBuffer;

  class Layout {
    constructor(span, property) {
      if (!Number.isInteger(span)) {
        throw new TypeError("span must be an integer");
      }
      this.span = span;
      this.property = property;
    }
    makeDestinationObject() {
      return {};
    }
    getSpan(b, offset) {
      if (0 > this.span) {
        throw new RangeError("indeterminate span");
      }
      return this.span;
    }
    replicate(property) {
      const rv = Object.create(this.constructor.prototype);
      Object.assign(rv, this);
      rv.property = property;
      return rv;
    }
    fromArray(values) {
      return;
    }
  }
  exports.Layout = Layout;
  exports.nameWithProperty = nameWithProperty;
  exports.bindConstructorLayout = bindConstructorLayout;

  class ExternalLayout extends Layout {
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  }
  exports.ExternalLayout = ExternalLayout;

  class GreedyCount extends ExternalLayout {
    constructor(elementSpan = 1, property) {
      if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
        throw new TypeError("elementSpan must be a (positive) integer");
      }
      super(-1, property);
      this.elementSpan = elementSpan;
    }
    isCount() {
      return true;
    }
    decode(b, offset = 0) {
      checkUint8Array(b);
      const rem = b.length - offset;
      return Math.floor(rem / this.elementSpan);
    }
    encode(src, b, offset) {
      return 0;
    }
  }
  exports.GreedyCount = GreedyCount;

  class OffsetLayout extends ExternalLayout {
    constructor(layout, offset = 0, property) {
      if (!(layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (!Number.isInteger(offset)) {
        throw new TypeError("offset must be integer or undefined");
      }
      super(layout.span, property || layout.property);
      this.layout = layout;
      this.offset = offset;
    }
    isCount() {
      return this.layout instanceof UInt || this.layout instanceof UIntBE;
    }
    decode(b, offset = 0) {
      return this.layout.decode(b, offset + this.offset);
    }
    encode(src, b, offset = 0) {
      return this.layout.encode(src, b, offset + this.offset);
    }
  }
  exports.OffsetLayout = OffsetLayout;

  class UInt extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);
      return this.span;
    }
  }
  exports.UInt = UInt;

  class UIntBE extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);
      return this.span;
    }
  }
  exports.UIntBE = UIntBE;

  class Int extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readIntLE(offset, this.span);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);
      return this.span;
    }
  }
  exports.Int = Int;

  class IntBE extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readIntBE(offset, this.span);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);
      return this.span;
    }
  }
  exports.IntBE = IntBE;
  var V2E32 = Math.pow(2, 32);

  class NearUInt64 extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b, offset = 0) {
      const buffer = uint8ArrayToBuffer(b);
      const lo32 = buffer.readUInt32LE(offset);
      const hi32 = buffer.readUInt32LE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b, offset = 0) {
      const split3 = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b);
      buffer.writeUInt32LE(split3.lo32, offset);
      buffer.writeUInt32LE(split3.hi32, offset + 4);
      return 8;
    }
  }
  exports.NearUInt64 = NearUInt64;

  class NearUInt64BE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b, offset = 0) {
      const buffer = uint8ArrayToBuffer(b);
      const hi32 = buffer.readUInt32BE(offset);
      const lo32 = buffer.readUInt32BE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b, offset = 0) {
      const split3 = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b);
      buffer.writeUInt32BE(split3.hi32, offset);
      buffer.writeUInt32BE(split3.lo32, offset + 4);
      return 8;
    }
  }
  exports.NearUInt64BE = NearUInt64BE;

  class NearInt64 extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b, offset = 0) {
      const buffer = uint8ArrayToBuffer(b);
      const lo32 = buffer.readUInt32LE(offset);
      const hi32 = buffer.readInt32LE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b, offset = 0) {
      const split3 = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b);
      buffer.writeUInt32LE(split3.lo32, offset);
      buffer.writeInt32LE(split3.hi32, offset + 4);
      return 8;
    }
  }
  exports.NearInt64 = NearInt64;

  class NearInt64BE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b, offset = 0) {
      const buffer = uint8ArrayToBuffer(b);
      const hi32 = buffer.readInt32BE(offset);
      const lo32 = buffer.readUInt32BE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b, offset = 0) {
      const split3 = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b);
      buffer.writeInt32BE(split3.hi32, offset);
      buffer.writeUInt32BE(split3.lo32, offset + 4);
      return 8;
    }
  }
  exports.NearInt64BE = NearInt64BE;

  class Float extends Layout {
    constructor(property) {
      super(4, property);
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readFloatLE(offset);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeFloatLE(src, offset);
      return 4;
    }
  }
  exports.Float = Float;

  class FloatBE extends Layout {
    constructor(property) {
      super(4, property);
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readFloatBE(offset);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeFloatBE(src, offset);
      return 4;
    }
  }
  exports.FloatBE = FloatBE;

  class Double extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readDoubleLE(offset);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeDoubleLE(src, offset);
      return 8;
    }
  }
  exports.Double = Double;

  class DoubleBE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b, offset = 0) {
      return uint8ArrayToBuffer(b).readDoubleBE(offset);
    }
    encode(src, b, offset = 0) {
      uint8ArrayToBuffer(b).writeDoubleBE(src, offset);
      return 8;
    }
  }
  exports.DoubleBE = DoubleBE;

  class Sequence extends Layout {
    constructor(elementLayout, count, property) {
      if (!(elementLayout instanceof Layout)) {
        throw new TypeError("elementLayout must be a Layout");
      }
      if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
        throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
        span = count * elementLayout.span;
      }
      super(span, property);
      this.elementLayout = elementLayout;
      this.count = count;
    }
    getSpan(b, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let span = 0;
      let count = this.count;
      if (count instanceof ExternalLayout) {
        count = count.decode(b, offset);
      }
      if (0 < this.elementLayout.span) {
        span = count * this.elementLayout.span;
      } else {
        let idx = 0;
        while (idx < count) {
          span += this.elementLayout.getSpan(b, offset + span);
          ++idx;
        }
      }
      return span;
    }
    decode(b, offset = 0) {
      const rv = [];
      let i = 0;
      let count = this.count;
      if (count instanceof ExternalLayout) {
        count = count.decode(b, offset);
      }
      while (i < count) {
        rv.push(this.elementLayout.decode(b, offset));
        offset += this.elementLayout.getSpan(b, offset);
        i += 1;
      }
      return rv;
    }
    encode(src, b, offset = 0) {
      const elo = this.elementLayout;
      const span = src.reduce((span2, v) => {
        return span2 + elo.encode(v, b, offset + span2);
      }, 0);
      if (this.count instanceof ExternalLayout) {
        this.count.encode(src.length, b, offset);
      }
      return span;
    }
  }
  exports.Sequence = Sequence;

  class Structure extends Layout {
    constructor(fields, property, decodePrefixes) {
      if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {
        throw new TypeError("fields must be array of Layout instances");
      }
      if (typeof property === "boolean" && decodePrefixes === undefined) {
        decodePrefixes = property;
        property = undefined;
      }
      for (const fd of fields) {
        if (0 > fd.span && fd.property === undefined) {
          throw new Error("fields cannot contain unnamed variable-length layout");
        }
      }
      let span = -1;
      try {
        span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
      } catch (e) {
      }
      super(span, property);
      this.fields = fields;
      this.decodePrefixes = !!decodePrefixes;
    }
    getSpan(b, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let span = 0;
      try {
        span = this.fields.reduce((span2, fd) => {
          const fsp = fd.getSpan(b, offset);
          offset += fsp;
          return span2 + fsp;
        }, 0);
      } catch (e) {
        throw new RangeError("indeterminate span");
      }
      return span;
    }
    decode(b, offset = 0) {
      checkUint8Array(b);
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          dest[fd.property] = fd.decode(b, offset);
        }
        offset += fd.getSpan(b, offset);
        if (this.decodePrefixes && b.length === offset) {
          break;
        }
      }
      return dest;
    }
    encode(src, b, offset = 0) {
      const firstOffset = offset;
      let lastOffset = 0;
      let lastWrote = 0;
      for (const fd of this.fields) {
        let span = fd.span;
        lastWrote = 0 < span ? span : 0;
        if (fd.property !== undefined) {
          const fv = src[fd.property];
          if (fv !== undefined) {
            lastWrote = fd.encode(fv, b, offset);
            if (0 > span) {
              span = fd.getSpan(b, offset);
            }
          }
        }
        lastOffset = offset;
        offset += span;
      }
      return lastOffset + lastWrote - firstOffset;
    }
    fromArray(values) {
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (fd.property !== undefined && 0 < values.length) {
          dest[fd.property] = values.shift();
        }
      }
      return dest;
    }
    layoutFor(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
      return;
    }
    offsetOf(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      let offset = 0;
      for (const fd of this.fields) {
        if (fd.property === property) {
          return offset;
        }
        if (0 > fd.span) {
          offset = -1;
        } else if (0 <= offset) {
          offset += fd.span;
        }
      }
      return;
    }
  }
  exports.Structure = Structure;

  class UnionDiscriminator {
    constructor(property) {
      this.property = property;
    }
    decode(b, offset) {
      throw new Error("UnionDiscriminator is abstract");
    }
    encode(src, b, offset) {
      throw new Error("UnionDiscriminator is abstract");
    }
  }
  exports.UnionDiscriminator = UnionDiscriminator;

  class UnionLayoutDiscriminator extends UnionDiscriminator {
    constructor(layout, property) {
      if (!(layout instanceof ExternalLayout && layout.isCount())) {
        throw new TypeError("layout must be an unsigned integer ExternalLayout");
      }
      super(property || layout.property || "variant");
      this.layout = layout;
    }
    decode(b, offset) {
      return this.layout.decode(b, offset);
    }
    encode(src, b, offset) {
      return this.layout.encode(src, b, offset);
    }
  }
  exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;

  class Union extends Layout {
    constructor(discr, defaultLayout, property) {
      let discriminator;
      if (discr instanceof UInt || discr instanceof UIntBE) {
        discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
      } else if (discr instanceof ExternalLayout && discr.isCount()) {
        discriminator = new UnionLayoutDiscriminator(discr);
      } else if (!(discr instanceof UnionDiscriminator)) {
        throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
      } else {
        discriminator = discr;
      }
      if (defaultLayout === undefined) {
        defaultLayout = null;
      }
      if (!(defaultLayout === null || defaultLayout instanceof Layout)) {
        throw new TypeError("defaultLayout must be null or a Layout");
      }
      if (defaultLayout !== null) {
        if (0 > defaultLayout.span) {
          throw new Error("defaultLayout must have constant span");
        }
        if (defaultLayout.property === undefined) {
          defaultLayout = defaultLayout.replicate("content");
        }
      }
      let span = -1;
      if (defaultLayout) {
        span = defaultLayout.span;
        if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {
          span += discriminator.layout.span;
        }
      }
      super(span, property);
      this.discriminator = discriminator;
      this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;
      this.defaultLayout = defaultLayout;
      this.registry = {};
      let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
      this.getSourceVariant = function(src) {
        return boundGetSourceVariant(src);
      };
      this.configGetSourceVariant = function(gsv) {
        boundGetSourceVariant = gsv.bind(this);
      };
    }
    getSpan(b, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      const vlo = this.getVariant(b, offset);
      if (!vlo) {
        throw new Error("unable to determine span for unrecognized variant");
      }
      return vlo.getSpan(b, offset);
    }
    defaultGetSourceVariant(src) {
      if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
        if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
          return;
        }
        const vlo = this.registry[src[this.discriminator.property]];
        if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
          return vlo;
        }
      } else {
        for (const tag2 in this.registry) {
          const vlo = this.registry[tag2];
          if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
            return vlo;
          }
        }
      }
      throw new Error("unable to infer src variant");
    }
    decode(b, offset = 0) {
      let dest;
      const dlo = this.discriminator;
      const discr = dlo.decode(b, offset);
      const clo = this.registry[discr];
      if (clo === undefined) {
        const defaultLayout = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dest = this.makeDestinationObject();
        dest[dlo.property] = discr;
        dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);
      } else {
        dest = clo.decode(b, offset);
      }
      return dest;
    }
    encode(src, b, offset = 0) {
      const vlo = this.getSourceVariant(src);
      if (vlo === undefined) {
        const dlo = this.discriminator;
        const clo = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dlo.encode(src[dlo.property], b, offset);
        return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);
      }
      return vlo.encode(src, b, offset);
    }
    addVariant(variant, layout, property) {
      const rv = new VariantLayout(this, variant, layout, property);
      this.registry[variant] = rv;
      return rv;
    }
    getVariant(vb, offset = 0) {
      let variant;
      if (vb instanceof Uint8Array) {
        variant = this.discriminator.decode(vb, offset);
      } else {
        variant = vb;
      }
      return this.registry[variant];
    }
  }
  exports.Union = Union;

  class VariantLayout extends Layout {
    constructor(union, variant, layout, property) {
      if (!(union instanceof Union)) {
        throw new TypeError("union must be a Union");
      }
      if (!Number.isInteger(variant) || 0 > variant) {
        throw new TypeError("variant must be a (non-negative) integer");
      }
      if (typeof layout === "string" && property === undefined) {
        property = layout;
        layout = null;
      }
      if (layout) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (union.defaultLayout !== null && 0 <= layout.span && layout.span > union.defaultLayout.span) {
          throw new Error("variant span exceeds span of containing union");
        }
        if (typeof property !== "string") {
          throw new TypeError("variant must have a String property");
        }
      }
      let span = union.span;
      if (0 > union.span) {
        span = layout ? layout.span : 0;
        if (0 <= span && union.usesPrefixDiscriminator) {
          span += union.discriminator.layout.span;
        }
      }
      super(span, property);
      this.union = union;
      this.variant = variant;
      this.layout = layout || null;
    }
    getSpan(b, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      let span = 0;
      if (this.layout) {
        span = this.layout.getSpan(b, offset + contentOffset);
      }
      return contentOffset + span;
    }
    decode(b, offset = 0) {
      const dest = this.makeDestinationObject();
      if (this !== this.union.getVariant(b, offset)) {
        throw new Error("variant mismatch");
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout) {
        dest[this.property] = this.layout.decode(b, offset + contentOffset);
      } else if (this.property) {
        dest[this.property] = true;
      } else if (this.union.usesPrefixDiscriminator) {
        dest[this.union.discriminator.property] = this.variant;
      }
      return dest;
    }
    encode(src, b, offset = 0) {
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {
        throw new TypeError("variant lacks property " + this.property);
      }
      this.union.discriminator.encode(this.variant, b, offset);
      let span = contentOffset;
      if (this.layout) {
        this.layout.encode(src[this.property], b, offset + contentOffset);
        span += this.layout.getSpan(b, offset + contentOffset);
        if (0 <= this.union.span && span > this.union.span) {
          throw new Error("encoded variant overruns containing union");
        }
      }
      return span;
    }
    fromArray(values) {
      if (this.layout) {
        return this.layout.fromArray(values);
      }
      return;
    }
  }
  exports.VariantLayout = VariantLayout;

  class BitStructure extends Layout {
    constructor(word, msb, property) {
      if (!(word instanceof UInt || word instanceof UIntBE)) {
        throw new TypeError("word must be a UInt or UIntBE layout");
      }
      if (typeof msb === "string" && property === undefined) {
        property = msb;
        msb = false;
      }
      if (4 < word.span) {
        throw new RangeError("word cannot exceed 32 bits");
      }
      super(word.span, property);
      this.word = word;
      this.msb = !!msb;
      this.fields = [];
      let value = 0;
      this._packedSetValue = function(v) {
        value = fixBitwiseResult(v);
        return this;
      };
      this._packedGetValue = function() {
        return value;
      };
    }
    decode(b, offset = 0) {
      const dest = this.makeDestinationObject();
      const value = this.word.decode(b, offset);
      this._packedSetValue(value);
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          dest[fd.property] = fd.decode(b);
        }
      }
      return dest;
    }
    encode(src, b, offset = 0) {
      const value = this.word.decode(b, offset);
      this._packedSetValue(value);
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          const fv = src[fd.property];
          if (fv !== undefined) {
            fd.encode(fv);
          }
        }
      }
      return this.word.encode(this._packedGetValue(), b, offset);
    }
    addField(bits, property) {
      const bf = new BitField(this, bits, property);
      this.fields.push(bf);
      return bf;
    }
    addBoolean(property) {
      const bf = new Boolean2(this, property);
      this.fields.push(bf);
      return bf;
    }
    fieldFor(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
      return;
    }
  }
  exports.BitStructure = BitStructure;

  class BitField {
    constructor(container, bits, property) {
      if (!(container instanceof BitStructure)) {
        throw new TypeError("container must be a BitStructure");
      }
      if (!Number.isInteger(bits) || 0 >= bits) {
        throw new TypeError("bits must be positive integer");
      }
      const totalBits = 8 * container.span;
      const usedBits = container.fields.reduce((sum2, fd) => sum2 + fd.bits, 0);
      if (bits + usedBits > totalBits) {
        throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
      }
      this.container = container;
      this.bits = bits;
      this.valueMask = (1 << bits) - 1;
      if (bits === 32) {
        this.valueMask = 4294967295;
      }
      this.start = usedBits;
      if (this.container.msb) {
        this.start = totalBits - usedBits - bits;
      }
      this.wordMask = fixBitwiseResult(this.valueMask << this.start);
      this.property = property;
    }
    decode(b, offset) {
      const word = this.container._packedGetValue();
      const wordValue = fixBitwiseResult(word & this.wordMask);
      const value = wordValue >>> this.start;
      return value;
    }
    encode(value) {
      if (typeof value !== "number" || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
        throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
      }
      const word = this.container._packedGetValue();
      const wordValue = fixBitwiseResult(value << this.start);
      this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
    }
  }
  exports.BitField = BitField;

  class Boolean2 extends BitField {
    constructor(container, property) {
      super(container, 1, property);
    }
    decode(b, offset) {
      return !!super.decode(b, offset);
    }
    encode(value) {
      if (typeof value === "boolean") {
        value = +value;
      }
      super.encode(value);
    }
  }
  exports.Boolean = Boolean2;

  class Blob extends Layout {
    constructor(length, property) {
      if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
        throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(length instanceof ExternalLayout)) {
        span = length;
      }
      super(span, property);
      this.length = length;
    }
    getSpan(b, offset) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b, offset);
      }
      return span;
    }
    decode(b, offset = 0) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b, offset);
      }
      return uint8ArrayToBuffer(b).slice(offset, offset + span);
    }
    encode(src, b, offset) {
      let span = this.length;
      if (this.length instanceof ExternalLayout) {
        span = src.length;
      }
      if (!(src instanceof Uint8Array && span === src.length)) {
        throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
      }
      if (offset + span > b.length) {
        throw new RangeError("encoding overruns Uint8Array");
      }
      const srcBuffer = uint8ArrayToBuffer(src);
      uint8ArrayToBuffer(b).write(srcBuffer.toString("hex"), offset, span, "hex");
      if (this.length instanceof ExternalLayout) {
        this.length.encode(span, b, offset);
      }
      return span;
    }
  }
  exports.Blob = Blob;

  class CString extends Layout {
    constructor(property) {
      super(-1, property);
    }
    getSpan(b, offset = 0) {
      checkUint8Array(b);
      let idx = offset;
      while (idx < b.length && b[idx] !== 0) {
        idx += 1;
      }
      return 1 + idx - offset;
    }
    decode(b, offset = 0) {
      const span = this.getSpan(b, offset);
      return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString("utf-8");
    }
    encode(src, b, offset = 0) {
      if (typeof src !== "string") {
        src = String(src);
      }
      const srcb = buffer_1.Buffer.from(src, "utf8");
      const span = srcb.length;
      if (offset + span > b.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      const buffer = uint8ArrayToBuffer(b);
      srcb.copy(buffer, offset);
      buffer[offset + span] = 0;
      return span + 1;
    }
  }
  exports.CString = CString;

  class UTF8 extends Layout {
    constructor(maxSpan, property) {
      if (typeof maxSpan === "string" && property === undefined) {
        property = maxSpan;
        maxSpan = undefined;
      }
      if (maxSpan === undefined) {
        maxSpan = -1;
      } else if (!Number.isInteger(maxSpan)) {
        throw new TypeError("maxSpan must be an integer");
      }
      super(-1, property);
      this.maxSpan = maxSpan;
    }
    getSpan(b, offset = 0) {
      checkUint8Array(b);
      return b.length - offset;
    }
    decode(b, offset = 0) {
      const span = this.getSpan(b, offset);
      if (0 <= this.maxSpan && this.maxSpan < span) {
        throw new RangeError("text length exceeds maxSpan");
      }
      return uint8ArrayToBuffer(b).slice(offset, offset + span).toString("utf-8");
    }
    encode(src, b, offset = 0) {
      if (typeof src !== "string") {
        src = String(src);
      }
      const srcb = buffer_1.Buffer.from(src, "utf8");
      const span = srcb.length;
      if (0 <= this.maxSpan && this.maxSpan < span) {
        throw new RangeError("text length exceeds maxSpan");
      }
      if (offset + span > b.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      srcb.copy(uint8ArrayToBuffer(b), offset);
      return span;
    }
  }
  exports.UTF8 = UTF8;

  class Constant extends Layout {
    constructor(value, property) {
      super(0, property);
      this.value = value;
    }
    decode(b, offset) {
      return this.value;
    }
    encode(src, b, offset) {
      return 0;
    }
  }
  exports.Constant = Constant;
  exports.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
  exports.offset = (layout, offset, property) => new OffsetLayout(layout, offset, property);
  exports.u8 = (property) => new UInt(1, property);
  exports.u16 = (property) => new UInt(2, property);
  exports.u24 = (property) => new UInt(3, property);
  exports.u32 = (property) => new UInt(4, property);
  exports.u40 = (property) => new UInt(5, property);
  exports.u48 = (property) => new UInt(6, property);
  exports.nu64 = (property) => new NearUInt64(property);
  exports.u16be = (property) => new UIntBE(2, property);
  exports.u24be = (property) => new UIntBE(3, property);
  exports.u32be = (property) => new UIntBE(4, property);
  exports.u40be = (property) => new UIntBE(5, property);
  exports.u48be = (property) => new UIntBE(6, property);
  exports.nu64be = (property) => new NearUInt64BE(property);
  exports.s8 = (property) => new Int(1, property);
  exports.s16 = (property) => new Int(2, property);
  exports.s24 = (property) => new Int(3, property);
  exports.s32 = (property) => new Int(4, property);
  exports.s40 = (property) => new Int(5, property);
  exports.s48 = (property) => new Int(6, property);
  exports.ns64 = (property) => new NearInt64(property);
  exports.s16be = (property) => new IntBE(2, property);
  exports.s24be = (property) => new IntBE(3, property);
  exports.s32be = (property) => new IntBE(4, property);
  exports.s40be = (property) => new IntBE(5, property);
  exports.s48be = (property) => new IntBE(6, property);
  exports.ns64be = (property) => new NearInt64BE(property);
  exports.f32 = (property) => new Float(property);
  exports.f32be = (property) => new FloatBE(property);
  exports.f64 = (property) => new Double(property);
  exports.f64be = (property) => new DoubleBE(property);
  exports.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
  exports.bits = (word, msb, property) => new BitStructure(word, msb, property);
  exports.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
  exports.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
  exports.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
  exports.blob = (length, property) => new Blob(length, property);
  exports.cstr = (property) => new CString(property);
  exports.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
  exports.constant = (value, property) => new Constant(value, property);
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS((exports, module) => {
  var fileUriToPath = function(uri) {
    if (typeof uri != "string" || uri.length <= 7 || uri.substring(0, 7) != "file://") {
      throw new TypeError("must pass in a file:// URI to convert to a file path");
    }
    var rest = decodeURI(uri.substring(7));
    var firstSlash = rest.indexOf("/");
    var host = rest.substring(0, firstSlash);
    var path = rest.substring(firstSlash + 1);
    if (host == "localhost")
      host = "";
    if (host) {
      host = sep + sep + host;
    }
    path = path.replace(/^(.+)\|/, "$1:");
    if (sep == "\\") {
      path = path.replace(/\//g, "\\");
    }
    if (/^.+\:/.test(path)) {
    } else {
      path = sep + path;
    }
    return host + path;
  };
  var sep = import.meta.require("path").sep || "/";
  module.exports = fileUriToPath;
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS((exports, module) => {
  var bindings = function(opts) {
    if (typeof opts == "string") {
      opts = { bindings: opts };
    } else if (!opts) {
      opts = {};
    }
    Object.keys(defaults).map(function(i2) {
      if (!(i2 in opts))
        opts[i2] = defaults[i2];
    });
    if (!opts.module_root) {
      opts.module_root = exports.getRoot(exports.getFileName());
    }
    if (path.extname(opts.bindings) != ".node") {
      opts.bindings += ".node";
    }
    var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : import.meta.require;
    var tries = [], i = 0, l = opts.try.length, n, b, err;
    for (;i < l; i++) {
      n = join2.apply(null, opts.try[i].map(function(p) {
        return opts[p] || p;
      }));
      tries.push(n);
      try {
        b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
        if (!opts.path) {
          b.path = n;
        }
        return b;
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
          throw e;
        }
      }
    }
    err = new Error("Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
      return opts.arrow + a;
    }).join("\n"));
    err.tries = tries;
    throw err;
  };
  var __filename = "/home/ujjujjuj/code/projects/switcher-freelance/tstrack/tracker/node_modules/bindings/bindings.js";
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var fileURLToPath = require_file_uri_to_path();
  var join2 = path.join;
  var dirname2 = path.dirname;
  var exists2 = fs.accessSync && function(path2) {
    try {
      fs.accessSync(path2);
    } catch (e) {
      return false;
    }
    return true;
  } || fs.existsSync || path.existsSync;
  var defaults = {
    arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
    compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
    platform: process.platform,
    arch: process.arch,
    nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
    version: process.versions.node,
    bindings: "bindings.node",
    try: [
      ["module_root", "build", "bindings"],
      ["module_root", "build", "Debug", "bindings"],
      ["module_root", "build", "Release", "bindings"],
      ["module_root", "out", "Debug", "bindings"],
      ["module_root", "Debug", "bindings"],
      ["module_root", "out", "Release", "bindings"],
      ["module_root", "Release", "bindings"],
      ["module_root", "build", "default", "bindings"],
      ["module_root", "compiled", "version", "platform", "arch", "bindings"],
      ["module_root", "addon-build", "release", "install-root", "bindings"],
      ["module_root", "addon-build", "debug", "install-root", "bindings"],
      ["module_root", "addon-build", "default", "install-root", "bindings"],
      ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
    ]
  };
  module.exports = exports = bindings;
  exports.getFileName = function getFileName(calling_file) {
    var { prepareStackTrace: origPST, stackTraceLimit: origSTL } = Error, dummy = {}, fileName;
    Error.stackTraceLimit = 10;
    Error.prepareStackTrace = function(e, st) {
      for (var i = 0, l = st.length;i < l; i++) {
        fileName = st[i].getFileName();
        if (fileName !== __filename) {
          if (calling_file) {
            if (fileName !== calling_file) {
              return;
            }
          } else {
            return;
          }
        }
      }
    };
    Error.captureStackTrace(dummy);
    dummy.stack;
    Error.prepareStackTrace = origPST;
    Error.stackTraceLimit = origSTL;
    var fileSchema = "file://";
    if (fileName.indexOf(fileSchema) === 0) {
      fileName = fileURLToPath(fileName);
    }
    return fileName;
  };
  exports.getRoot = function getRoot(file) {
    var dir = dirname2(file), prev;
    while (true) {
      if (dir === ".") {
        dir = process.cwd();
      }
      if (exists2(join2(dir, "package.json")) || exists2(join2(dir, "node_modules"))) {
        return dir;
      }
      if (prev === dir) {
        throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
      }
      prev = dir;
      dir = join2(dir, "..");
    }
  };
});

// node_modules/bigint-buffer/dist/node.js
var require_node4 = __commonJS((exports) => {
  var toBigIntLE = function(buf) {
    if (converter === undefined) {
      const reversed = Buffer.from(buf);
      reversed.reverse();
      const hex = reversed.toString("hex");
      if (hex.length === 0) {
        return BigInt(0);
      }
      return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, false);
  };
  var toBigIntBE = function(buf) {
    if (converter === undefined) {
      const hex = buf.toString("hex");
      if (hex.length === 0) {
        return BigInt(0);
      }
      return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, true);
  };
  var toBufferLE = function(num, width) {
    if (converter === undefined) {
      const hex = num.toString(16);
      const buffer = Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
      buffer.reverse();
      return buffer;
    }
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
  };
  var toBufferBE = function(num, width) {
    if (converter === undefined) {
      const hex = num.toString(16);
      return Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
    }
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var converter;
  {
    try {
      converter = require_bindings()("bigint_buffer");
    } catch (e) {
      console.warn("bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?)");
    }
  }
  exports.toBigIntLE = toBigIntLE;
  exports.toBigIntBE = toBigIntBE;
  exports.toBufferLE = toBufferLE;
  exports.toBufferBE = toBufferBE;
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var rng = function() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var validate2 = function(uuid3) {
    return typeof uuid3 === "string" && _regex.default.test(uuid3);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  var _default = validate2;
  exports.default = _default;
});

// node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringify = function(arr, offset = 0) {
    const uuid3 = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!(0, _validate.default)(uuid3)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid3;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  var _default = stringify;
  exports.default = _default;
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v1 = function(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || (0, _stringify.default)(b);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify());
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  var _default = v1;
  exports.default = _default;
});

// node_modules/uuid/dist/parse.js
var require_parse = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var parse = function(uuid3) {
    if (!(0, _validate.default)(uuid3)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid3.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid3.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid3.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid3.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid3.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = parse;
  exports.default = _default;
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringToBytes = function(str) {
    str = unescape(encodeURIComponent(str));
    const bytes7 = [];
    for (let i = 0;i < str.length; ++i) {
      bytes7.push(str.charCodeAt(i));
    }
    return bytes7;
  };
  var _default = function(name, version2, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (namespace.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes7 = new Uint8Array(16 + value.length);
      bytes7.set(namespace);
      bytes7.set(value, namespace.length);
      bytes7 = hashfunc(bytes7);
      bytes7[6] = bytes7[6] & 15 | version2;
      bytes7[8] = bytes7[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes7[i];
        }
        return buf;
      }
      return (0, _stringify.default)(bytes7);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  exports.URL = exports.DNS = undefined;
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse());
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var md5 = function(bytes7) {
    if (Array.isArray(bytes7)) {
      bytes7 = Buffer.from(bytes7);
    } else if (typeof bytes7 === "string") {
      bytes7 = Buffer.from(bytes7, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes7).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = md5;
  exports.default = _default;
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v4 = function(options, buf, offset) {
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.default)(rnds);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify());
  var _default = v4;
  exports.default = _default;
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var sha1 = function(bytes7) {
    if (Array.isArray(bytes7)) {
      bytes7 = Buffer.from(bytes7);
    } else if (typeof bytes7 === "string") {
      bytes7 = Buffer.from(bytes7, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes7).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = sha1;
  exports.default = _default;
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var version2 = function(uuid3) {
    if (!(0, _validate.default)(uuid3)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid3.substr(14, 1), 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = version2;
  exports.default = _default;
});

// node_modules/uuid/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse());
});

// node_modules/jayson/lib/generateRequest.js
var require_generateRequest = __commonJS((exports, module) => {
  var uuid3 = require_dist3().v4;
  var generateRequest = function(method, params, id, options) {
    if (typeof method !== "string") {
      throw new TypeError(method + " must be a string");
    }
    options = options || {};
    const version2 = typeof options.version === "number" ? options.version : 2;
    if (version2 !== 1 && version2 !== 2) {
      throw new TypeError(version2 + " must be 1 or 2");
    }
    const request = {
      method
    };
    if (version2 === 2) {
      request.jsonrpc = "2.0";
    }
    if (params) {
      if (typeof params !== "object" && !Array.isArray(params)) {
        throw new TypeError(params + " must be an object, array or omitted");
      }
      request.params = params;
    }
    if (typeof id === "undefined") {
      const generator = typeof options.generator === "function" ? options.generator : function() {
        return uuid3();
      };
      request.id = generator(request, options);
    } else if (version2 === 2 && id === null) {
      if (options.notificationIdNull) {
        request.id = null;
      }
    } else {
      request.id = id;
    }
    return request;
  };
  module.exports = generateRequest;
});

// node_modules/jayson/lib/client/browser/index.js
var require_browser2 = __commonJS((exports, module) => {
  var uuid3 = require_dist3().v4;
  var generateRequest = require_generateRequest();
  var ClientBrowser = function(callServer, options) {
    if (!(this instanceof ClientBrowser)) {
      return new ClientBrowser(callServer, options);
    }
    if (!options) {
      options = {};
    }
    this.options = {
      reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
      replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
      generator: typeof options.generator !== "undefined" ? options.generator : function() {
        return uuid3();
      },
      version: typeof options.version !== "undefined" ? options.version : 2,
      notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
    };
    this.callServer = callServer;
  };
  module.exports = ClientBrowser;
  ClientBrowser.prototype.request = function(method, params, id, callback) {
    const self2 = this;
    let request = null;
    const isBatch = Array.isArray(method) && typeof params === "function";
    if (this.options.version === 1 && isBatch) {
      throw new TypeError("JSON-RPC 1.0 does not support batching");
    }
    const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
    if (isBatch || isRaw) {
      callback = params;
      request = method;
    } else {
      if (typeof id === "function") {
        callback = id;
        id = undefined;
      }
      const hasCallback = typeof callback === "function";
      try {
        request = generateRequest(method, params, id, {
          generator: this.options.generator,
          version: this.options.version,
          notificationIdNull: this.options.notificationIdNull
        });
      } catch (err) {
        if (hasCallback) {
          return callback(err);
        }
        throw err;
      }
      if (!hasCallback) {
        return request;
      }
    }
    let message;
    try {
      message = JSON.stringify(request, this.options.replacer);
    } catch (err) {
      return callback(err);
    }
    this.callServer(message, function(err, response) {
      self2._parseResponse(err, response, callback);
    });
    return request;
  };
  ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
    if (err) {
      callback(err);
      return;
    }
    if (!responseText) {
      return callback();
    }
    let response;
    try {
      response = JSON.parse(responseText, this.options.reviver);
    } catch (err2) {
      return callback(err2);
    }
    if (callback.length === 3) {
      if (Array.isArray(response)) {
        const isError = function(res) {
          return typeof res.error !== "undefined";
        };
        const isNotError = function(res) {
          return !isError(res);
        };
        return callback(null, response.filter(isError), response.filter(isNotError));
      } else {
        return callback(null, response.error, response.result);
      }
    }
    callback(null, response);
  };
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  };
  module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS((exports, module) => {
  var _typeof = function(o) {
    "@babel/helpers - typeof";
    return module.exports = _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
  };
  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS((exports, module) => {
  var _regeneratorRuntime = function() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
      return e;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
      t2[e2] = r2.value;
    }, i = typeof Symbol == "function" ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
    function define3(t2, e2, r2) {
      return Object.defineProperty(t2, e2, {
        value: r2,
        enumerable: true,
        configurable: true,
        writable: true
      }), t2[e2];
    }
    try {
      define3({}, "");
    } catch (t2) {
      define3 = function define(t3, e2, r2) {
        return t3[e2] = r2;
      };
    }
    function wrap(t2, e2, r2, n2) {
      var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
      return o(a2, "_invoke", {
        value: makeInvokeMethod(t2, r2, c2)
      }), a2;
    }
    function tryCatch(t2, e2, r2) {
      try {
        return {
          type: "normal",
          arg: t2.call(e2, r2)
        };
      } catch (t3) {
        return {
          type: "throw",
          arg: t3
        };
      }
    }
    e.wrap = wrap;
    var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var p = {};
    define3(p, a, function() {
      return this;
    });
    var d = Object.getPrototypeOf, v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t2) {
      ["next", "throw", "return"].forEach(function(e2) {
        define3(t2, e2, function(t3) {
          return this._invoke(e2, t3);
        });
      });
    }
    function AsyncIterator(t2, e2) {
      function invoke(r3, o2, i2, a2) {
        var c2 = tryCatch(t2[r3], t2, o2);
        if (c2.type !== "throw") {
          var u2 = c2.arg, h2 = u2.value;
          return h2 && _typeof(h2) == "object" && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
            invoke("next", t3, i2, a2);
          }, function(t3) {
            invoke("throw", t3, i2, a2);
          }) : e2.resolve(h2).then(function(t3) {
            u2.value = t3, i2(u2);
          }, function(t3) {
            return invoke("throw", t3, i2, a2);
          });
        }
        a2(c2.arg);
      }
      var r2;
      o(this, "_invoke", {
        value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e2, r2, n2) {
      var o2 = h;
      return function(i2, a2) {
        if (o2 === f)
          throw new Error("Generator is already running");
        if (o2 === s) {
          if (i2 === "throw")
            throw a2;
          return {
            value: t,
            done: true
          };
        }
        for (n2.method = i2, n2.arg = a2;; ) {
          var c2 = n2.delegate;
          if (c2) {
            var u2 = maybeInvokeDelegate(c2, n2);
            if (u2) {
              if (u2 === y)
                continue;
              return u2;
            }
          }
          if (n2.method === "next")
            n2.sent = n2._sent = n2.arg;
          else if (n2.method === "throw") {
            if (o2 === h)
              throw o2 = s, n2.arg;
            n2.dispatchException(n2.arg);
          } else
            n2.method === "return" && n2.abrupt("return", n2.arg);
          o2 = f;
          var p2 = tryCatch(e2, r2, n2);
          if (p2.type === "normal") {
            if (o2 = n2.done ? s : l, p2.arg === y)
              continue;
            return {
              value: p2.arg,
              done: n2.done
            };
          }
          p2.type === "throw" && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
        }
      };
    }
    function maybeInvokeDelegate(e2, r2) {
      var n2 = r2.method, o2 = e2.iterator[n2];
      if (o2 === t)
        return r2.delegate = null, n2 === "throw" && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), r2.method === "throw") || n2 !== "return" && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
      var i2 = tryCatch(o2, e2.iterator, r2.arg);
      if (i2.type === "throw")
        return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
      var a2 = i2.arg;
      return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, r2.method !== "return" && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
    }
    function pushTryEntry(t2) {
      var e2 = {
        tryLoc: t2[0]
      };
      1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
    }
    function resetTryEntry(t2) {
      var e2 = t2.completion || {};
      e2.type = "normal", delete e2.arg, t2.completion = e2;
    }
    function Context(t2) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t2.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(e2) {
      if (e2 || e2 === "") {
        var r2 = e2[a];
        if (r2)
          return r2.call(e2);
        if (typeof e2.next == "function")
          return e2;
        if (!isNaN(e2.length)) {
          var o2 = -1, i2 = function next() {
            for (;++o2 < e2.length; )
              if (n.call(e2, o2))
                return next.value = e2[o2], next.done = false, next;
            return next.value = t, next.done = true, next;
          };
          return i2.next = i2;
        }
      }
      throw new TypeError(_typeof(e2) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    }), GeneratorFunction.displayName = define3(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
      var e2 = typeof t2 == "function" && t2.constructor;
      return !!e2 && (e2 === GeneratorFunction || (e2.displayName || e2.name) === "GeneratorFunction");
    }, e.mark = function(t2) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define3(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
    }, e.awrap = function(t2) {
      return {
        __await: t2
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define3(AsyncIterator.prototype, c, function() {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
      i2 === undefined && (i2 = Promise);
      var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
      return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
        return t3.done ? t3.value : a2.next();
      });
    }, defineIteratorMethods(g), define3(g, u, "Generator"), define3(g, a, function() {
      return this;
    }), define3(g, "toString", function() {
      return "[object Generator]";
    }), e.keys = function(t2) {
      var e2 = Object(t2), r2 = [];
      for (var n2 in e2)
        r2.push(n2);
      return r2.reverse(), function next() {
        for (;r2.length; ) {
          var t3 = r2.pop();
          if (t3 in e2)
            return next.value = t3, next.done = false, next;
        }
        return next.done = true, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2)
          for (var r2 in this)
            r2.charAt(0) === "t" && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      },
      stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if (t2.type === "throw")
          throw t2.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(e2) {
        if (this.done)
          throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1;o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if (i2.tryLoc === "root")
            return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc)
                return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc)
                return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc)
                return handle(i2.catchLoc, true);
            } else {
              if (!u2)
                throw new Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc)
                return handle(i2.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1;r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && (t2 === "break" || t2 === "continue") && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      },
      complete: function complete(t2, e2) {
        if (t2.type === "throw")
          throw t2.arg;
        return t2.type === "break" || t2.type === "continue" ? this.next = t2.arg : t2.type === "return" ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : t2.type === "normal" && e2 && (this.next = e2), y;
      },
      finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1;e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2)
            return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      },
      catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1;e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if (n2.type === "throw") {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = {
          iterator: values(e2),
          resultName: r2,
          nextLoc: n2
        }, this.method === "next" && (this.arg = t), y;
      }
    }, e;
  };
  var _typeof = require_typeof()["default"];
  module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS((exports, module) => {
  var runtime = require_regeneratorRuntime()();
  module.exports = runtime;
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
});

// node_modules/@babel/runtime/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS((exports, module) => {
  var asyncGeneratorStep = function(gen2, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen2[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  };
  var _asyncToGenerator = function(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen2 = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen2, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen2, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  };
  module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS((exports, module) => {
  var _classCallCheck = function(instance2, Constructor) {
    if (!(instance2 instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS((exports, module) => {
  var toPrimitive = function(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  };
  var _typeof = require_typeof()["default"];
  module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS((exports, module) => {
  var toPropertyKey = function(t) {
    var i = toPrimitive(t, "string");
    return _typeof(i) == "symbol" ? i : String(i);
  };
  var _typeof = require_typeof()["default"];
  var toPrimitive = require_toPrimitive();
  module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS((exports, module) => {
  var _defineProperties = function(target, props) {
    for (var i = 0;i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  };
  var _createClass = function(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  };
  var toPropertyKey = require_toPropertyKey();
  module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS((exports, module) => {
  var _setPrototypeOf = function(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _setPrototypeOf(o, p);
  };
  module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/inherits.js
var require_inherits2 = __commonJS((exports, module) => {
  var _inherits = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass)
      setPrototypeOf(subClass, superClass);
  };
  var setPrototypeOf = require_setPrototypeOf();
  module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS((exports, module) => {
  var _assertThisInitialized = function(self2) {
    if (self2 === undefined) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  };
  module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS((exports, module) => {
  var _possibleConstructorReturn = function(self2, call3) {
    if (call3 && (_typeof(call3) === "object" || typeof call3 === "function")) {
      return call3;
    } else if (call3 !== undefined) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return assertThisInitialized(self2);
  };
  var _typeof = require_typeof()["default"];
  var assertThisInitialized = require_assertThisInitialized();
  module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS((exports, module) => {
  var _getPrototypeOf = function(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _getPrototypeOf(o);
  };
  module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/eventemitter3/index.js
var require_eventemitter32 = __commonJS((exports, module) => {
  var Events = function() {
  };
  var EE = function(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  };
  var addListener = function(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  };
  var clearEvent = function(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  };
  var EventEmitter3 = function() {
    this._events = new Events;
    this._eventsCount = 0;
  };
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  EventEmitter3.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter3.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter3.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1);i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0;i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter3.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter3.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length;i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
  EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
  EventEmitter3.prefixed = prefix;
  EventEmitter3.EventEmitter = EventEmitter3;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter3;
  }
});

// node_modules/rpc-websockets/dist/lib/utils.js
var require_utils = __commonJS((exports) => {
  var createError = function(code, details) {
    var error = {
      code,
      message: errors5.get(code) || "Internal Server Error"
    };
    if (details)
      error["data"] = details;
    return error;
  };
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DefaultDataPack = undefined;
  exports.createError = createError;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var errors5 = new Map([[-32000, "Event not provided"], [-32600, "Invalid Request"], [-32601, "Method not found"], [-32602, "Invalid params"], [-32603, "Internal error"], [-32604, "Params not found"], [-32605, "Method forbidden"], [-32606, "Event forbidden"], [-32700, "Parse error"]]);
  var DefaultDataPack = function() {
    function DefaultDataPack2() {
      (0, _classCallCheck2["default"])(this, DefaultDataPack2);
    }
    (0, _createClass2["default"])(DefaultDataPack2, [{
      key: "encode",
      value: function encode(value) {
        return JSON.stringify(value);
      }
    }, {
      key: "decode",
      value: function decode(value) {
        return JSON.parse(value);
      }
    }]);
    return DefaultDataPack2;
  }();
  exports.DefaultDataPack = DefaultDataPack;
});

// node_modules/rpc-websockets/dist/lib/client.js
var require_client3 = __commonJS((exports) => {
  var _createSuper = function(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = (0, _getPrototypeOf2["default"])(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return (0, _possibleConstructorReturn2["default"])(this, result);
    };
  };
  var _isNativeReflectConstruct = function() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  };
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regenerator = _interopRequireDefault(require_regenerator());
  var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _inherits2 = _interopRequireDefault(require_inherits2());
  var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
  var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
  var _eventemitter = require_eventemitter32();
  var _utils = require_utils();
  var __rest2 = function(s, e) {
    var t = {};
    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    }
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var CommonClient = function(_EventEmitter) {
    (0, _inherits2["default"])(CommonClient2, _EventEmitter);
    var _super = _createSuper(CommonClient2);
    function CommonClient2(webSocketFactory) {
      var _this;
      var address7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "ws://localhost:8080";
      var _a4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var generate_request_id = arguments.length > 3 ? arguments[3] : undefined;
      var dataPack = arguments.length > 4 ? arguments[4] : undefined;
      (0, _classCallCheck2["default"])(this, CommonClient2);
      var _a$autoconnect = _a4.autoconnect, autoconnect = _a$autoconnect === undefined ? true : _a$autoconnect, _a$reconnect = _a4.reconnect, reconnect = _a$reconnect === undefined ? true : _a$reconnect, _a$reconnect_interval = _a4.reconnect_interval, reconnect_interval = _a$reconnect_interval === undefined ? 1000 : _a$reconnect_interval, _a$max_reconnects = _a4.max_reconnects, max_reconnects = _a$max_reconnects === undefined ? 5 : _a$max_reconnects, rest_options = __rest2(_a4, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
      _this = _super.call(this);
      _this.webSocketFactory = webSocketFactory;
      _this.queue = {};
      _this.rpc_id = 0;
      _this.address = address7;
      _this.autoconnect = autoconnect;
      _this.ready = false;
      _this.reconnect = reconnect;
      _this.reconnect_timer_id = undefined;
      _this.reconnect_interval = reconnect_interval;
      _this.max_reconnects = max_reconnects;
      _this.rest_options = rest_options;
      _this.current_reconnects = 0;
      _this.generate_request_id = generate_request_id || function() {
        return ++_this.rpc_id;
      };
      if (!dataPack)
        _this.dataPack = new _utils.DefaultDataPack;
      else
        _this.dataPack = dataPack;
      if (_this.autoconnect)
        _this._connect(_this.address, Object.assign({
          autoconnect: _this.autoconnect,
          reconnect: _this.reconnect,
          reconnect_interval: _this.reconnect_interval,
          max_reconnects: _this.max_reconnects
        }, _this.rest_options));
      return _this;
    }
    (0, _createClass2["default"])(CommonClient2, [{
      key: "connect",
      value: function connect() {
        if (this.socket)
          return;
        this._connect(this.address, Object.assign({
          autoconnect: this.autoconnect,
          reconnect: this.reconnect,
          reconnect_interval: this.reconnect_interval,
          max_reconnects: this.max_reconnects
        }, this.rest_options));
      }
    }, {
      key: "call",
      value: function call(method, params, timeout, ws_opts) {
        var _this2 = this;
        if (!ws_opts && (0, _typeof2["default"])(timeout) === "object") {
          ws_opts = timeout;
          timeout = null;
        }
        return new Promise(function(resolve, reject) {
          if (!_this2.ready)
            return reject(new Error("socket not ready"));
          var rpc_id = _this2.generate_request_id(method, params);
          var message = {
            jsonrpc: "2.0",
            method,
            params: params || undefined,
            id: rpc_id
          };
          _this2.socket.send(_this2.dataPack.encode(message), ws_opts, function(error) {
            if (error)
              return reject(error);
            _this2.queue[rpc_id] = {
              promise: [resolve, reject]
            };
            if (timeout) {
              _this2.queue[rpc_id].timeout = setTimeout(function() {
                delete _this2.queue[rpc_id];
                reject(new Error("reply timeout"));
              }, timeout);
            }
          });
        });
      }
    }, {
      key: "login",
      value: function() {
        var _login = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(params) {
          var resp;
          return _regenerator["default"].wrap(function _callee$(_context) {
            while (true) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return this.call("rpc.login", params);
                case 2:
                  resp = _context.sent;
                  if (resp) {
                    _context.next = 5;
                    break;
                  }
                  throw new Error("authentication failed");
                case 5:
                  return _context.abrupt("return", resp);
                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
        function login(_x) {
          return _login.apply(this, arguments);
        }
        return login;
      }()
    }, {
      key: "listMethods",
      value: function() {
        var _listMethods = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
          return _regenerator["default"].wrap(function _callee2$(_context2) {
            while (true) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return this.call("__listMethods");
                case 2:
                  return _context2.abrupt("return", _context2.sent);
                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));
        function listMethods() {
          return _listMethods.apply(this, arguments);
        }
        return listMethods;
      }()
    }, {
      key: "notify",
      value: function notify(method, params) {
        var _this3 = this;
        return new Promise(function(resolve, reject) {
          if (!_this3.ready)
            return reject(new Error("socket not ready"));
          var message = {
            jsonrpc: "2.0",
            method,
            params
          };
          _this3.socket.send(_this3.dataPack.encode(message), function(error) {
            if (error)
              return reject(error);
            resolve();
          });
        });
      }
    }, {
      key: "subscribe",
      value: function() {
        var _subscribe = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(event) {
          var result;
          return _regenerator["default"].wrap(function _callee3$(_context3) {
            while (true) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (typeof event === "string")
                    event = [event];
                  _context3.next = 3;
                  return this.call("rpc.on", event);
                case 3:
                  result = _context3.sent;
                  if (!(typeof event === "string" && result[event] !== "ok")) {
                    _context3.next = 6;
                    break;
                  }
                  throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);
                case 6:
                  return _context3.abrupt("return", result);
                case 7:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));
        function subscribe(_x2) {
          return _subscribe.apply(this, arguments);
        }
        return subscribe;
      }()
    }, {
      key: "unsubscribe",
      value: function() {
        var _unsubscribe = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(event) {
          var result;
          return _regenerator["default"].wrap(function _callee4$(_context4) {
            while (true) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  if (typeof event === "string")
                    event = [event];
                  _context4.next = 3;
                  return this.call("rpc.off", event);
                case 3:
                  result = _context4.sent;
                  if (!(typeof event === "string" && result[event] !== "ok")) {
                    _context4.next = 6;
                    break;
                  }
                  throw new Error("Failed unsubscribing from an event with: " + result);
                case 6:
                  return _context4.abrupt("return", result);
                case 7:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));
        function unsubscribe(_x3) {
          return _unsubscribe.apply(this, arguments);
        }
        return unsubscribe;
      }()
    }, {
      key: "close",
      value: function close(code, data) {
        this.socket.close(code || 1000, data);
      }
    }, {
      key: "_connect",
      value: function _connect(address7, options) {
        var _this4 = this;
        clearTimeout(this.reconnect_timer_id);
        this.socket = this.webSocketFactory(address7, options);
        this.socket.addEventListener("open", function() {
          _this4.ready = true;
          _this4.emit("open");
          _this4.current_reconnects = 0;
        });
        this.socket.addEventListener("message", function(_ref) {
          var message = _ref.data;
          if (message instanceof ArrayBuffer)
            message = Buffer.from(message).toString();
          try {
            message = _this4.dataPack.decode(message);
          } catch (error) {
            return;
          }
          if (message.notification && _this4.listeners(message.notification).length) {
            if (!Object.keys(message.params).length)
              return _this4.emit(message.notification);
            var args = [message.notification];
            if (message.params.constructor === Object)
              args.push(message.params);
            else
              for (var i = 0;i < message.params.length; i++) {
                args.push(message.params[i]);
              }
            return Promise.resolve().then(function() {
              _this4.emit.apply(_this4, args);
            });
          }
          if (!_this4.queue[message.id]) {
            if (message.method) {
              return Promise.resolve().then(function() {
                _this4.emit(message.method, message === null || message === undefined ? undefined : message.params);
              });
            }
            return;
          }
          if ("error" in message === "result" in message)
            _this4.queue[message.id].promise[1](new Error("Server response malformed. Response must include either \"result\" or \"error\", but not both."));
          if (_this4.queue[message.id].timeout)
            clearTimeout(_this4.queue[message.id].timeout);
          if (message.error)
            _this4.queue[message.id].promise[1](message.error);
          else
            _this4.queue[message.id].promise[0](message.result);
          delete _this4.queue[message.id];
        });
        this.socket.addEventListener("error", function(error) {
          return _this4.emit("error", error);
        });
        this.socket.addEventListener("close", function(_ref2) {
          var { code, reason } = _ref2;
          if (_this4.ready)
            setTimeout(function() {
              return _this4.emit("close", code, reason);
            }, 0);
          _this4.ready = false;
          _this4.socket = undefined;
          if (code === 1000)
            return;
          _this4.current_reconnects++;
          if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0))
            _this4.reconnect_timer_id = setTimeout(function() {
              return _this4._connect(address7, options);
            }, _this4.reconnect_interval);
        });
      }
    }]);
    return CommonClient2;
  }(_eventemitter.EventEmitter);
  exports.default = CommonClient;
});

// node_modules/rpc-websockets/dist/lib/client/websocket.js
var require_websocket = __commonJS((exports) => {
  var _default = function(address7, options) {
    return new _ws["default"](address7, options);
  };
  var _interopRequireDefault = require_interopRequireDefault();
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  var _ws = _interopRequireDefault(import.meta.require("ws"));
});

// src/index.ts
var config7 = __toESM(require_config(), 1);

// src/logger.ts
var import_winston = __toESM(require_winston(), 1);
var logger = import_winston.default.createLogger({
  level: "verbose",
  format: import_winston.default.format.combine(import_winston.default.format.colorize(), import_winston.default.format.simple()),
  transports: [
    new import_winston.default.transports.Console,
    new import_winston.default.transports.File({ filename: "warn.log", level: "warn" }),
    new import_winston.default.transports.File({ filename: "verbose.log", level: "verbose" })
  ]
});

// src/chains.ts
var client5 = __toESM(require_default2(), 1);

// node_modules/web3-errors/lib/esm/error_codes.js
var ERR_RESPONSE = 100;
var ERR_INVALID_RESPONSE = 101;
var ERR_FORMATTERS = 201;
var ERR_METHOD_NOT_IMPLEMENTED = 202;
var ERR_OPERATION_TIMEOUT = 203;
var ERR_OPERATION_ABORT = 204;
var ERR_ABI_ENCODING = 205;
var ERR_EXISTING_PLUGIN_NAMESPACE = 206;
var ERR_INVALID_METHOD_PARAMS = 207;
var ERR_CONTRACT = 300;
var ERR_CONTRACT_RESOLVER_MISSING = 301;
var ERR_CONTRACT_EXECUTION_REVERTED = 310;
var ERR_CONTRACT_TX_DATA_AND_INPUT = 311;
var ERR_TX = 400;
var ERR_TX_REVERT_TRANSACTION = 402;
var ERR_TX_REVERT_WITHOUT_REASON = 405;
var ERR_RAW_TX_UNDEFINED = 407;
var ERR_TX_INVALID_SENDER = 408;
var ERR_TX_MISSING_CUSTOM_CHAIN = 410;
var ERR_TX_MISSING_CUSTOM_CHAIN_ID = 411;
var ERR_TX_CHAIN_ID_MISMATCH = 412;
var ERR_TX_INVALID_CHAIN_INFO = 413;
var ERR_TX_MISSING_CHAIN_INFO = 414;
var ERR_TX_MISSING_GAS = 415;
var ERR_TX_INVALID_LEGACY_GAS = 416;
var ERR_TX_INVALID_FEE_MARKET_GAS = 417;
var ERR_TX_INVALID_FEE_MARKET_GAS_PRICE = 418;
var ERR_TX_INVALID_LEGACY_FEE_MARKET = 419;
var ERR_TX_INVALID_OBJECT = 420;
var ERR_TX_INVALID_NONCE_OR_CHAIN_ID = 421;
var ERR_TX_UNABLE_TO_POPULATE_NONCE = 422;
var ERR_TX_UNSUPPORTED_EIP_1559 = 423;
var ERR_TX_UNSUPPORTED_TYPE = 424;
var ERR_TX_DATA_AND_INPUT = 425;
var ERR_TX_POLLING_TIMEOUT = 426;
var ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL = 427;
var ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER = 428;
var ERR_TX_LOCAL_WALLET_NOT_AVAILABLE = 429;
var ERR_TX_NOT_FOUND = 430;
var ERR_TX_SEND_TIMEOUT = 431;
var ERR_TX_BLOCK_TIMEOUT = 432;
var ERR_TX_SIGNING = 433;
var ERR_TX_GAS_MISMATCH = 434;
var ERR_TX_CHAIN_MISMATCH = 435;
var ERR_TX_HARDFORK_MISMATCH = 436;
var ERR_TX_INVALID_RECEIVER = 437;
var ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR = 438;
var ERR_TX_INVALID_PROPERTIES_FOR_TYPE = 439;
var ERR_TX_MISSING_GAS_INNER_ERROR = 440;
var ERR_TX_GAS_MISMATCH_INNER_ERROR = 441;
var ERR_CONN = 500;
var ERR_CONN_NOT_OPEN = 503;
var ERR_CONN_MAX_ATTEMPTS = 505;
var ERR_CONN_PENDING_REQUESTS = 506;
var ERR_REQ_ALREADY_SENT = 507;
var ERR_PROVIDER = 600;
var ERR_INVALID_CLIENT = 602;
var ERR_SUBSCRIPTION = 603;
var ERR_WS_PROVIDER = 604;
var ERR_PRIVATE_KEY_LENGTH = 701;
var ERR_INVALID_PRIVATE_KEY = 702;
var ERR_UNSUPPORTED_KDF = 703;
var ERR_KEY_DERIVATION_FAIL = 704;
var ERR_KEY_VERSION_UNSUPPORTED = 705;
var ERR_INVALID_PASSWORD = 706;
var ERR_IV_LENGTH = 707;
var ERR_PBKDF2_ITERATIONS = 709;
var ERR_SIGNATURE_FAILED = 801;
var ERR_INVALID_SIGNATURE = 802;
var JSONRPC_ERR_REJECTED_REQUEST = 4001;
var JSONRPC_ERR_UNAUTHORIZED = 4100;
var JSONRPC_ERR_UNSUPPORTED_METHOD = 4200;
var JSONRPC_ERR_DISCONNECTED = 4900;
var JSONRPC_ERR_CHAIN_DISCONNECTED = 4901;
var ERR_ENS_UNSUPPORTED_NETWORK = 902;
var ERR_ENS_NETWORK_NOT_SYNCED = 903;
var ERR_INVALID_STRING = 1001;
var ERR_INVALID_BYTES = 1002;
var ERR_INVALID_NUMBER = 1003;
var ERR_INVALID_UNIT = 1004;
var ERR_INVALID_ADDRESS = 1005;
var ERR_INVALID_HEX = 1006;
var ERR_INVALID_BOOLEAN = 1008;
var ERR_INVALID_UNSIGNED_INTEGER = 1009;
var ERR_INVALID_SIZE = 1010;
var ERR_INVALID_LARGE_VALUE = 1011;
var ERR_INVALID_BLOCK = 1012;
var ERR_INVALID_NIBBLE_WIDTH = 1014;
var ERR_VALIDATION = 1100;
var ERR_CORE_HARDFORK_MISMATCH = 1101;
var ERR_SCHEMA_FORMAT = 1200;
var ERR_RPC_INVALID_JSON = -32700;
var ERR_RPC_INVALID_REQUEST = -32600;
var ERR_RPC_INVALID_METHOD = -32601;
var ERR_RPC_INVALID_PARAMS = -32602;
var ERR_RPC_INTERNAL_ERROR = -32603;
var ERR_RPC_INVALID_INPUT = -32000;
var ERR_RPC_MISSING_RESOURCE = -32001;
var ERR_RPC_UNAVAILABLE_RESOURCE = -32002;
var ERR_RPC_TRANSACTION_REJECTED = -32003;
var ERR_RPC_UNSUPPORTED_METHOD = -32004;
var ERR_RPC_LIMIT_EXCEEDED = -32005;
var ERR_RPC_NOT_SUPPORTED = -32006;
// node_modules/web3-errors/lib/esm/web3_error_base.js
class BaseWeb3Error extends Error {
  constructor(msg, innerError) {
    super(msg);
    this.innerError = innerError;
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(new.target.constructor);
    } else {
      this.stack = new Error().stack;
    }
  }
  static convertToString(value, unquotValue = false) {
    if (value === null || value === undefined)
      return "undefined";
    const result = JSON.stringify(value, (_, v) => typeof v === "bigint" ? v.toString() : v);
    return unquotValue && ["bigint", "string"].includes(typeof value) ? result.replace(/['\\"]+/g, "") : result;
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      innerError: this.innerError
    };
  }
}

class InvalidValueError extends BaseWeb3Error {
  constructor(value, msg) {
    super(`Invalid value given "${BaseWeb3Error.convertToString(value, true)}". Error: ${msg}.`);
    this.name = this.constructor.name;
  }
}
// node_modules/web3-errors/lib/esm/errors/account_errors.js
class PrivateKeyLengthError extends BaseWeb3Error {
  constructor() {
    super(`Private key must be 32 bytes.`);
    this.code = ERR_PRIVATE_KEY_LENGTH;
  }
}

class InvalidPrivateKeyError extends BaseWeb3Error {
  constructor() {
    super(`Invalid Private Key, Not a valid string or uint8Array`);
    this.code = ERR_INVALID_PRIVATE_KEY;
  }
}

class InvalidSignatureError extends BaseWeb3Error {
  constructor(errorDetails) {
    super(`"${errorDetails}"`);
    this.code = ERR_INVALID_SIGNATURE;
  }
}

class InvalidKdfError extends BaseWeb3Error {
  constructor() {
    super(`Invalid key derivation function`);
    this.code = ERR_UNSUPPORTED_KDF;
  }
}

class KeyDerivationError extends BaseWeb3Error {
  constructor() {
    super(`Key derivation failed - possibly wrong password`);
    this.code = ERR_KEY_DERIVATION_FAIL;
  }
}

class KeyStoreVersionError extends BaseWeb3Error {
  constructor() {
    super("Unsupported key store version");
    this.code = ERR_KEY_VERSION_UNSUPPORTED;
  }
}

class InvalidPasswordError extends BaseWeb3Error {
  constructor() {
    super("Password cannot be empty");
    this.code = ERR_INVALID_PASSWORD;
  }
}

class IVLengthError extends BaseWeb3Error {
  constructor() {
    super("Initialization vector must be 16 bytes");
    this.code = ERR_IV_LENGTH;
  }
}

class PBKDF2IterationsError extends BaseWeb3Error {
  constructor() {
    super("c > 1000, pbkdf2 is less secure with less iterations");
    this.code = ERR_PBKDF2_ITERATIONS;
  }
}
// node_modules/web3-errors/lib/esm/errors/connection_errors.js
class ConnectionError extends BaseWeb3Error {
  constructor(message, event) {
    super(message);
    this.code = ERR_CONN;
    if (event) {
      this.errorCode = event.code;
      this.errorReason = event.reason;
    }
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { errorCode: this.errorCode, errorReason: this.errorReason });
  }
}
class ConnectionNotOpenError extends ConnectionError {
  constructor(event) {
    super("Connection not open", event);
    this.code = ERR_CONN_NOT_OPEN;
  }
}
class MaxAttemptsReachedOnReconnectingError extends ConnectionError {
  constructor(numberOfAttempts) {
    super(`Maximum number of reconnect attempts reached! (${numberOfAttempts})`);
    this.code = ERR_CONN_MAX_ATTEMPTS;
  }
}

class PendingRequestsOnReconnectingError extends ConnectionError {
  constructor() {
    super("CONNECTION ERROR: Provider started to reconnect before the response got received!");
    this.code = ERR_CONN_PENDING_REQUESTS;
  }
}

class RequestAlreadySentError extends ConnectionError {
  constructor(id) {
    super(`Request already sent with following id: ${id}`);
    this.code = ERR_REQ_ALREADY_SENT;
  }
}
// node_modules/web3-errors/lib/esm/errors/contract_errors.js
class Web3ContractError extends BaseWeb3Error {
  constructor(message, receipt) {
    super(message);
    this.code = ERR_CONTRACT;
    this.receipt = receipt;
  }
}

class ResolverMethodMissingError extends BaseWeb3Error {
  constructor(address, name) {
    super(`The resolver at ${address} does not implement requested method: "${name}".`);
    this.address = address;
    this.name = name;
    this.code = ERR_CONTRACT_RESOLVER_MISSING;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { address: this.address, name: this.name });
  }
}
class Eip838ExecutionError extends Web3ContractError {
  constructor(error) {
    super(error.message || "Error");
    this.name = "name" in error && error.name || this.constructor.name;
    this.stack = "stack" in error && error.stack || undefined;
    this.code = error.code;
    if (typeof error.data === "object") {
      let originalError;
      if ("originalError" in error.data) {
        originalError = error.data.originalError;
      } else {
        originalError = error.data;
      }
      this.data = originalError.data;
      this.innerError = new Eip838ExecutionError(originalError);
    } else {
      this.data = error.data;
    }
  }
  setDecodedProperties(errorName, errorSignature, errorArgs) {
    this.errorName = errorName;
    this.errorSignature = errorSignature;
    this.errorArgs = errorArgs;
  }
  toJSON() {
    let json = Object.assign(Object.assign({}, super.toJSON()), { data: this.data });
    if (this.errorName) {
      json = Object.assign(Object.assign({}, json), { errorName: this.errorName, errorSignature: this.errorSignature, errorArgs: this.errorArgs });
    }
    return json;
  }
}

class ContractExecutionError extends Web3ContractError {
  constructor(rpcError) {
    super("Error happened while trying to execute a function inside a smart contract");
    this.code = ERR_CONTRACT_EXECUTION_REVERTED;
    this.innerError = new Eip838ExecutionError(rpcError);
  }
}

class ContractTransactionDataAndInputError extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`data: ${(_a = value.data) !== null && _a !== undefined ? _a : "undefined"}, input: ${(_b = value.input) !== null && _b !== undefined ? _b : "undefined"}`, 'You can\'t have "data" and "input" as properties of a contract at the same time, please use either "data" or "input" instead.');
    this.code = ERR_CONTRACT_TX_DATA_AND_INPUT;
  }
}
// node_modules/web3-errors/lib/esm/errors/ens_errors.js
class ENSUnsupportedNetworkError extends BaseWeb3Error {
  constructor(networkType) {
    super(`ENS is not supported on network ${networkType}`);
    this.code = ERR_ENS_UNSUPPORTED_NETWORK;
  }
}

class ENSNetworkNotSyncedError extends BaseWeb3Error {
  constructor() {
    super(`Network not synced`);
    this.code = ERR_ENS_NETWORK_NOT_SYNCED;
  }
}
// node_modules/web3-errors/lib/esm/errors/generic_errors.js
class InvalidMethodParamsError extends BaseWeb3Error {
  constructor(hint) {
    super(`Invalid parameters passed. "${typeof hint !== "undefined" ? hint : ""}"`);
    this.hint = hint;
    this.code = ERR_INVALID_METHOD_PARAMS;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { hint: this.hint });
  }
}

class FormatterError extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_FORMATTERS;
  }
}

class MethodNotImplementedError extends BaseWeb3Error {
  constructor() {
    super("The method you're trying to call is not implemented.");
    this.code = ERR_METHOD_NOT_IMPLEMENTED;
  }
}

class OperationTimeoutError extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_OPERATION_TIMEOUT;
  }
}

class OperationAbortError extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_OPERATION_ABORT;
  }
}

class AbiError extends BaseWeb3Error {
  constructor(message, props) {
    super(message);
    this.code = ERR_ABI_ENCODING;
    this.props = props !== null && props !== undefined ? props : {};
  }
}

class ExistingPluginNamespaceError extends BaseWeb3Error {
  constructor(pluginNamespace) {
    super(`A plugin with the namespace: ${pluginNamespace} has already been registered.`);
    this.code = ERR_EXISTING_PLUGIN_NAMESPACE;
  }
}
// node_modules/web3-errors/lib/esm/errors/provider_errors.js
class ProviderError extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_PROVIDER;
  }
}
class InvalidClientError extends BaseWeb3Error {
  constructor(clientUrl) {
    super(`Client URL "${clientUrl}" is invalid.`);
    this.code = ERR_INVALID_CLIENT;
  }
}

class SubscriptionError extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_SUBSCRIPTION;
  }
}

class Web3WSProviderError extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_WS_PROVIDER;
  }
}
// node_modules/web3-errors/lib/esm/errors/signature_errors.js
class SignatureError extends InvalidValueError {
  constructor() {
    super(...arguments);
    this.code = ERR_SIGNATURE_FAILED;
  }
}
// node_modules/web3-errors/lib/esm/errors/transaction_errors.js
var transactionTimeoutHint = function(transactionHash) {
  return `Please make sure your transaction was properly sent and there are no previous pending transaction for the same account. However, be aware that it might still be mined!\n\tTransaction Hash: ${transactionHash ? transactionHash.toString() : "not available"}`;
};

class TransactionError extends BaseWeb3Error {
  constructor(message, receipt) {
    super(message);
    this.receipt = receipt;
    this.code = ERR_TX;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { receipt: this.receipt });
  }
}
class TransactionRevertInstructionError extends BaseWeb3Error {
  constructor(reason, signature, receipt, data) {
    super(`Transaction has been reverted by the EVM${receipt === undefined ? "" : `:\n ${BaseWeb3Error.convertToString(receipt)}`}`);
    this.reason = reason;
    this.signature = signature;
    this.receipt = receipt;
    this.data = data;
    this.code = ERR_TX_REVERT_TRANSACTION;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { reason: this.reason, signature: this.signature, receipt: this.receipt, data: this.data });
  }
}

class TransactionRevertWithCustomError extends TransactionRevertInstructionError {
  constructor(reason, customErrorName, customErrorDecodedSignature, customErrorArguments, signature, receipt, data) {
    super(reason);
    this.reason = reason;
    this.customErrorName = customErrorName;
    this.customErrorDecodedSignature = customErrorDecodedSignature;
    this.customErrorArguments = customErrorArguments;
    this.signature = signature;
    this.receipt = receipt;
    this.data = data;
    this.code = ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { reason: this.reason, customErrorName: this.customErrorName, customErrorDecodedSignature: this.customErrorDecodedSignature, customErrorArguments: this.customErrorArguments, signature: this.signature, receipt: this.receipt, data: this.data });
  }
}
class TransactionRevertedWithoutReasonError extends TransactionError {
  constructor(receipt) {
    super(`Transaction has been reverted by the EVM${receipt === undefined ? "" : `:\n ${BaseWeb3Error.convertToString(receipt)}`}`, receipt);
    this.code = ERR_TX_REVERT_WITHOUT_REASON;
  }
}
class UndefinedRawTransactionError extends TransactionError {
  constructor() {
    super(`Raw transaction undefined`);
    this.code = ERR_RAW_TX_UNDEFINED;
  }
}

class TransactionNotFound extends TransactionError {
  constructor() {
    super("Transaction not found");
    this.code = ERR_TX_NOT_FOUND;
  }
}

class InvalidTransactionWithSender extends InvalidValueError {
  constructor(value) {
    super(value, "invalid transaction with invalid sender");
    this.code = ERR_TX_INVALID_SENDER;
  }
}

class InvalidTransactionWithReceiver extends InvalidValueError {
  constructor(value) {
    super(value, "invalid transaction with invalid receiver");
    this.code = ERR_TX_INVALID_RECEIVER;
  }
}
class MissingCustomChainError extends InvalidValueError {
  constructor() {
    super("MissingCustomChainError", "If tx.common is provided it must have tx.common.customChain");
    this.code = ERR_TX_MISSING_CUSTOM_CHAIN;
  }
}

class MissingCustomChainIdError extends InvalidValueError {
  constructor() {
    super("MissingCustomChainIdError", "If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId");
    this.code = ERR_TX_MISSING_CUSTOM_CHAIN_ID;
  }
}

class ChainIdMismatchError extends InvalidValueError {
  constructor(value) {
    super(JSON.stringify(value), "Chain Id doesnt match in tx.chainId tx.common.customChain.chainId");
    this.code = ERR_TX_CHAIN_ID_MISMATCH;
  }
}

class ChainMismatchError extends InvalidValueError {
  constructor(value) {
    super(JSON.stringify(value), "Chain doesnt match in tx.chain tx.common.basechain");
    this.code = ERR_TX_CHAIN_MISMATCH;
  }
}

class HardforkMismatchError extends InvalidValueError {
  constructor(value) {
    super(JSON.stringify(value), "hardfork doesnt match in tx.hardfork tx.common.hardfork");
    this.code = ERR_TX_HARDFORK_MISMATCH;
  }
}

class CommonOrChainAndHardforkError extends InvalidValueError {
  constructor() {
    super("CommonOrChainAndHardforkError", "Please provide the common object or the chain and hardfork property but not all together.");
    this.code = ERR_TX_INVALID_CHAIN_INFO;
  }
}

class MissingChainOrHardforkError extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super("MissingChainOrHardforkError", `When specifying chain and hardfork, both values must be defined. Received "chain": ${(_a = value.chain) !== null && _a !== undefined ? _a : "undefined"}, "hardfork": ${(_b = value.hardfork) !== null && _b !== undefined ? _b : "undefined"}`);
    this.code = ERR_TX_MISSING_CHAIN_INFO;
  }
}

class MissingGasInnerError extends BaseWeb3Error {
  constructor() {
    super('Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions');
    this.code = ERR_TX_MISSING_GAS_INNER_ERROR;
  }
}

class MissingGasError extends InvalidValueError {
  constructor(value) {
    var _a, _b, _c, _d;
    super(`gas: ${(_a = value.gas) !== null && _a !== undefined ? _a : "undefined"}, gasPrice: ${(_b = value.gasPrice) !== null && _b !== undefined ? _b : "undefined"}, maxPriorityFeePerGas: ${(_c = value.maxPriorityFeePerGas) !== null && _c !== undefined ? _c : "undefined"}, maxFeePerGas: ${(_d = value.maxFeePerGas) !== null && _d !== undefined ? _d : "undefined"}`, '"gas" is missing');
    this.code = ERR_TX_MISSING_GAS;
    this.innerError = new MissingGasInnerError;
  }
}

class TransactionGasMismatchInnerError extends BaseWeb3Error {
  constructor() {
    super('Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions, not both');
    this.code = ERR_TX_GAS_MISMATCH_INNER_ERROR;
  }
}

class TransactionGasMismatchError extends InvalidValueError {
  constructor(value) {
    var _a, _b, _c, _d;
    super(`gas: ${(_a = value.gas) !== null && _a !== undefined ? _a : "undefined"}, gasPrice: ${(_b = value.gasPrice) !== null && _b !== undefined ? _b : "undefined"}, maxPriorityFeePerGas: ${(_c = value.maxPriorityFeePerGas) !== null && _c !== undefined ? _c : "undefined"}, maxFeePerGas: ${(_d = value.maxFeePerGas) !== null && _d !== undefined ? _d : "undefined"}`, "transaction must specify legacy or fee market gas properties, not both");
    this.code = ERR_TX_GAS_MISMATCH;
    this.innerError = new TransactionGasMismatchInnerError;
  }
}

class InvalidGasOrGasPrice extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`gas: ${(_a = value.gas) !== null && _a !== undefined ? _a : "undefined"}, gasPrice: ${(_b = value.gasPrice) !== null && _b !== undefined ? _b : "undefined"}`, "Gas or gasPrice is lower than 0");
    this.code = ERR_TX_INVALID_LEGACY_GAS;
  }
}

class InvalidMaxPriorityFeePerGasOrMaxFeePerGas extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`maxPriorityFeePerGas: ${(_a = value.maxPriorityFeePerGas) !== null && _a !== undefined ? _a : "undefined"}, maxFeePerGas: ${(_b = value.maxFeePerGas) !== null && _b !== undefined ? _b : "undefined"}`, "maxPriorityFeePerGas or maxFeePerGas is lower than 0");
    this.code = ERR_TX_INVALID_FEE_MARKET_GAS;
  }
}

class Eip1559GasPriceError extends InvalidValueError {
  constructor(value) {
    super(value, "eip-1559 transactions don't support gasPrice");
    this.code = ERR_TX_INVALID_FEE_MARKET_GAS_PRICE;
  }
}

class UnsupportedFeeMarketError extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`maxPriorityFeePerGas: ${(_a = value.maxPriorityFeePerGas) !== null && _a !== undefined ? _a : "undefined"}, maxFeePerGas: ${(_b = value.maxFeePerGas) !== null && _b !== undefined ? _b : "undefined"}`, "pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas");
    this.code = ERR_TX_INVALID_LEGACY_FEE_MARKET;
  }
}

class InvalidTransactionObjectError extends InvalidValueError {
  constructor(value) {
    super(value, "invalid transaction object");
    this.code = ERR_TX_INVALID_OBJECT;
  }
}

class InvalidNonceOrChainIdError extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`nonce: ${(_a = value.nonce) !== null && _a !== undefined ? _a : "undefined"}, chainId: ${(_b = value.chainId) !== null && _b !== undefined ? _b : "undefined"}`, "Nonce or chainId is lower than 0");
    this.code = ERR_TX_INVALID_NONCE_OR_CHAIN_ID;
  }
}

class UnableToPopulateNonceError extends InvalidValueError {
  constructor() {
    super("UnableToPopulateNonceError", "unable to populate nonce, no from address available");
    this.code = ERR_TX_UNABLE_TO_POPULATE_NONCE;
  }
}

class Eip1559NotSupportedError extends InvalidValueError {
  constructor() {
    super("Eip1559NotSupportedError", "Network doesn't support eip-1559");
    this.code = ERR_TX_UNSUPPORTED_EIP_1559;
  }
}

class UnsupportedTransactionTypeError extends InvalidValueError {
  constructor(value) {
    super(value, "unsupported transaction type");
    this.code = ERR_TX_UNSUPPORTED_TYPE;
  }
}

class TransactionDataAndInputError extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`data: ${(_a = value.data) !== null && _a !== undefined ? _a : "undefined"}, input: ${(_b = value.input) !== null && _b !== undefined ? _b : "undefined"}`, 'You can\'t have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.');
    this.code = ERR_TX_DATA_AND_INPUT;
  }
}

class TransactionSendTimeoutError extends BaseWeb3Error {
  constructor(value) {
    super(`The connected Ethereum Node did not respond within ${value.numberOfSeconds} seconds, please make sure your transaction was properly sent and you are connected to a healthy Node. Be aware that transaction might still be pending or mined!\n\tTransaction Hash: ${value.transactionHash ? value.transactionHash.toString() : "not available"}`);
    this.code = ERR_TX_SEND_TIMEOUT;
  }
}

class TransactionPollingTimeoutError extends BaseWeb3Error {
  constructor(value) {
    super(`Transaction was not mined within ${value.numberOfSeconds} seconds. ${transactionTimeoutHint(value.transactionHash)}`);
    this.code = ERR_TX_POLLING_TIMEOUT;
  }
}

class TransactionBlockTimeoutError extends BaseWeb3Error {
  constructor(value) {
    super(`Transaction started at ${value.starterBlockNumber} but was not mined within ${value.numberOfBlocks} blocks. ${transactionTimeoutHint(value.transactionHash)}`);
    this.code = ERR_TX_BLOCK_TIMEOUT;
  }
}

class TransactionMissingReceiptOrBlockHashError extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`receipt: ${JSON.stringify(value.receipt)}, blockHash: ${(_a = value.blockHash) === null || _a === undefined ? undefined : _a.toString()}, transactionHash: ${(_b = value.transactionHash) === null || _b === undefined ? undefined : _b.toString()}`, `Receipt missing or blockHash null`);
    this.code = ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL;
  }
}

class TransactionReceiptMissingBlockNumberError extends InvalidValueError {
  constructor(value) {
    super(`receipt: ${JSON.stringify(value.receipt)}`, `Receipt missing block number`);
    this.code = ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER;
  }
}

class TransactionSigningError extends BaseWeb3Error {
  constructor(errorDetails) {
    super(`Invalid signature. "${errorDetails}"`);
    this.code = ERR_TX_SIGNING;
  }
}

class LocalWalletNotAvailableError extends InvalidValueError {
  constructor() {
    super("LocalWalletNotAvailableError", `Attempted to index account in local wallet, but no wallet is available`);
    this.code = ERR_TX_LOCAL_WALLET_NOT_AVAILABLE;
  }
}

class InvalidPropertiesForTransactionTypeError extends BaseWeb3Error {
  constructor(validationError, txType) {
    const invalidPropertyNames = [];
    validationError.forEach((error) => invalidPropertyNames.push(error.keyword));
    super(`The following properties are invalid for the transaction type ${txType}: ${invalidPropertyNames.join(", ")}`);
    this.code = ERR_TX_INVALID_PROPERTIES_FOR_TYPE;
  }
}
// node_modules/web3-errors/lib/esm/errors/utils_errors.js
class InvalidBytesError extends InvalidValueError {
  constructor(value) {
    super(value, "can not parse as byte data");
    this.code = ERR_INVALID_BYTES;
  }
}

class InvalidNumberError extends InvalidValueError {
  constructor(value) {
    super(value, "can not parse as number data");
    this.code = ERR_INVALID_NUMBER;
  }
}

class InvalidAddressError extends InvalidValueError {
  constructor(value) {
    super(value, "invalid ethereum address");
    this.code = ERR_INVALID_ADDRESS;
  }
}

class InvalidStringError extends InvalidValueError {
  constructor(value) {
    super(value, "not a valid string");
    this.code = ERR_INVALID_STRING;
  }
}

class InvalidUnitError extends InvalidValueError {
  constructor(value) {
    super(value, "invalid unit");
    this.code = ERR_INVALID_UNIT;
  }
}

class HexProcessingError extends InvalidValueError {
  constructor(value) {
    super(value, "can not be converted to hex");
    this.code = ERR_INVALID_HEX;
  }
}

class NibbleWidthError extends InvalidValueError {
  constructor(value) {
    super(value, "value greater than the nibble width");
    this.code = ERR_INVALID_NIBBLE_WIDTH;
  }
}
class InvalidBooleanError extends InvalidValueError {
  constructor(value) {
    super(value, "not a valid boolean.");
    this.code = ERR_INVALID_BOOLEAN;
  }
}

class InvalidUnsignedIntegerError extends InvalidValueError {
  constructor(value) {
    super(value, "not a valid unsigned integer.");
    this.code = ERR_INVALID_UNSIGNED_INTEGER;
  }
}

class InvalidSizeError extends InvalidValueError {
  constructor(value) {
    super(value, "invalid size given.");
    this.code = ERR_INVALID_SIZE;
  }
}

class InvalidLargeValueError extends InvalidValueError {
  constructor(value) {
    super(value, "value is larger than size.");
    this.code = ERR_INVALID_LARGE_VALUE;
  }
}

class InvalidBlockError extends InvalidValueError {
  constructor(value) {
    super(value, "invalid string given");
    this.code = ERR_INVALID_BLOCK;
  }
}
// node_modules/web3-errors/lib/esm/errors/response_errors.js
var isResponseWithError = (response) => !Array.isArray(response) && response.jsonrpc === "2.0" && !!response && (response.result === undefined || response.result === null) && ("error" in response) && (typeof response.id === "number" || typeof response.id === "string");
var buildErrorMessage = (response) => isResponseWithError(response) ? response.error.message : "";

class ResponseError extends BaseWeb3Error {
  constructor(response, message, request) {
    var _a;
    super(message !== null && message !== undefined ? message : `Returned error: ${Array.isArray(response) ? response.map((r) => buildErrorMessage(r)).join(",") : buildErrorMessage(response)}`);
    this.code = ERR_RESPONSE;
    if (!message) {
      this.data = Array.isArray(response) ? response.map((r) => {
        var _a2;
        return (_a2 = r.error) === null || _a2 === undefined ? undefined : _a2.data;
      }) : (_a = response === null || response === undefined ? undefined : response.error) === null || _a === undefined ? undefined : _a.data;
    }
    this.request = request;
    let errorOrErrors;
    if (`error` in response) {
      errorOrErrors = response.error;
    } else if (response instanceof Array) {
      errorOrErrors = response.map((r) => r.error);
    }
    this.innerError = errorOrErrors;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { data: this.data, request: this.request });
  }
}

class InvalidResponseError extends ResponseError {
  constructor(result, request) {
    super(result, undefined, request);
    this.code = ERR_INVALID_RESPONSE;
    let errorOrErrors;
    if (`error` in result) {
      errorOrErrors = result.error;
    } else if (result instanceof Array) {
      errorOrErrors = result.map((r) => r.error);
    }
    this.innerError = errorOrErrors;
  }
}
// node_modules/web3-errors/lib/esm/errors/core_errors.js
class ConfigHardforkMismatchError extends BaseWeb3Error {
  constructor(defaultHardfork, commonHardFork) {
    super(`Web3Config hardfork doesnt match in defaultHardfork ${defaultHardfork} and common.hardfork ${commonHardFork}`);
    this.code = ERR_CORE_HARDFORK_MISMATCH;
  }
}

class ConfigChainMismatchError extends BaseWeb3Error {
  constructor(defaultHardfork, commonHardFork) {
    super(`Web3Config chain doesnt match in defaultHardfork ${defaultHardfork} and common.hardfork ${commonHardFork}`);
    this.code = ERR_CORE_HARDFORK_MISMATCH;
  }
}
// node_modules/web3-errors/lib/esm/errors/rpc_error_messages.js
var genericRpcErrorMessageTemplate = "An Rpc error has occured with a code of *code*";
var RpcErrorMessages = {
  [ERR_RPC_INVALID_JSON]: {
    message: "Parse error",
    description: "Invalid JSON"
  },
  [ERR_RPC_INVALID_REQUEST]: {
    message: "Invalid request",
    description: "JSON is not a valid request object	"
  },
  [ERR_RPC_INVALID_METHOD]: {
    message: "Method not found",
    description: "Method does not exist	"
  },
  [ERR_RPC_INVALID_PARAMS]: {
    message: "Invalid params",
    description: "Invalid method parameters"
  },
  [ERR_RPC_INTERNAL_ERROR]: {
    message: "Internal error",
    description: "Internal JSON-RPC error"
  },
  [ERR_RPC_INVALID_INPUT]: {
    message: "Invalid input",
    description: "Missing or invalid parameters"
  },
  [ERR_RPC_MISSING_RESOURCE]: {
    message: "Resource not found",
    description: "Requested resource not found"
  },
  [ERR_RPC_UNAVAILABLE_RESOURCE]: {
    message: "Resource unavailable",
    description: "Requested resource not available"
  },
  [ERR_RPC_TRANSACTION_REJECTED]: {
    message: "Transaction rejected",
    description: "Transaction creation failed"
  },
  [ERR_RPC_UNSUPPORTED_METHOD]: {
    message: "Method not supported",
    description: "Method is not implemented"
  },
  [ERR_RPC_LIMIT_EXCEEDED]: {
    message: "Limit exceeded",
    description: "Request exceeds defined limit"
  },
  [ERR_RPC_NOT_SUPPORTED]: {
    message: "JSON-RPC version not supported",
    description: "Version of JSON-RPC protocol is not supported"
  },
  [JSONRPC_ERR_REJECTED_REQUEST]: {
    name: "User Rejected Request",
    message: "The user rejected the request."
  },
  [JSONRPC_ERR_UNAUTHORIZED]: {
    name: "Unauthorized",
    message: "The requested method and/or account has not been authorized by the user."
  },
  [JSONRPC_ERR_UNSUPPORTED_METHOD]: {
    name: "Unsupported Method",
    message: "The Provider does not support the requested method."
  },
  [JSONRPC_ERR_DISCONNECTED]: {
    name: "Disconnected",
    message: "The Provider is disconnected from all chains."
  },
  [JSONRPC_ERR_CHAIN_DISCONNECTED]: {
    name: "Chain Disconnected",
    message: "The Provider is not connected to the requested chain."
  },
  "0-999": {
    name: "",
    message: "Not used."
  },
  1000: {
    name: "Normal Closure",
    message: "The connection successfully completed the purpose for which it was created."
  },
  1001: {
    name: "Going Away",
    message: "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection."
  },
  1002: {
    name: "Protocol error",
    message: "The endpoint is terminating the connection due to a protocol error."
  },
  1003: {
    name: "Unsupported Data",
    message: "The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)"
  },
  1004: {
    name: "Reserved",
    message: "Reserved. A meaning might be defined in the future."
  },
  1005: {
    name: "No Status Rcvd",
    message: "Reserved. Indicates that no status code was provided even though one was expected."
  },
  1006: {
    name: "Abnormal Closure",
    message: "Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected."
  },
  1007: {
    name: "Invalid frame payload data",
    message: "The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message)."
  },
  1008: {
    name: "Policy Violation",
    message: "The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable."
  },
  1009: {
    name: "Message Too Big",
    message: "The endpoint is terminating the connection because a data frame was received that is too large."
  },
  1010: {
    name: "Mandatory Ext.",
    message: "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't."
  },
  1011: {
    name: "Internal Error",
    message: "The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request."
  },
  1012: {
    name: "Service Restart",
    message: "The server is terminating the connection because it is restarting."
  },
  1013: {
    name: "Try Again Later",
    message: "The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients."
  },
  1014: {
    name: "Bad Gateway",
    message: "The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code."
  },
  1015: {
    name: "TLS handshake",
    message: "Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified)."
  },
  "1016-2999": {
    name: "",
    message: "For definition by future revisions of the WebSocket Protocol specification, and for definition by extension specifications."
  },
  "3000-3999": {
    name: "",
    message: "For use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by the WebSocket protocol."
  },
  "4000-4999": {
    name: "",
    message: "For private use, and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by the WebSocket protocol."
  }
};

// node_modules/web3-errors/lib/esm/errors/rpc_errors.js
class RpcError extends BaseWeb3Error {
  constructor(rpcError, message) {
    super(message !== null && message !== undefined ? message : genericRpcErrorMessageTemplate.replace("*code*", rpcError.error.code.toString()));
    this.code = rpcError.error.code;
    this.id = rpcError.id;
    this.jsonrpc = rpcError.jsonrpc;
    this.jsonRpcError = rpcError.error;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { error: this.jsonRpcError, id: this.id, jsonRpc: this.jsonrpc });
  }
}

class EIP1193ProviderRpcError extends BaseWeb3Error {
  constructor(code, data) {
    var _a, _b, _c, _d;
    if (!code) {
      super();
    } else if ((_a = RpcErrorMessages[code]) === null || _a === undefined ? undefined : _a.message) {
      super(RpcErrorMessages[code].message);
    } else {
      const statusCodeRange = Object.keys(RpcErrorMessages).find((statusCode) => typeof statusCode === "string" && code >= parseInt(statusCode.split("-")[0], 10) && code <= parseInt(statusCode.split("-")[1], 10));
      super((_c = (_b = RpcErrorMessages[statusCodeRange !== null && statusCodeRange !== undefined ? statusCodeRange : ""]) === null || _b === undefined ? undefined : _b.message) !== null && _c !== undefined ? _c : genericRpcErrorMessageTemplate.replace("*code*", (_d = code === null || code === undefined ? undefined : code.toString()) !== null && _d !== undefined ? _d : '""'));
    }
    this.code = code;
    this.data = data;
  }
}

class ParseError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_JSON].message);
    this.code = ERR_RPC_INVALID_JSON;
  }
}

class InvalidRequestError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_REQUEST].message);
    this.code = ERR_RPC_INVALID_REQUEST;
  }
}

class MethodNotFoundError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_METHOD].message);
    this.code = ERR_RPC_INVALID_METHOD;
  }
}

class InvalidParamsError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_PARAMS].message);
    this.code = ERR_RPC_INVALID_PARAMS;
  }
}

class InternalError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INTERNAL_ERROR].message);
    this.code = ERR_RPC_INTERNAL_ERROR;
  }
}

class InvalidInputError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_INPUT].message);
    this.code = ERR_RPC_INVALID_INPUT;
  }
}

class MethodNotSupported extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_UNSUPPORTED_METHOD].message);
    this.code = ERR_RPC_UNSUPPORTED_METHOD;
  }
}

class ResourceUnavailableError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_UNAVAILABLE_RESOURCE].message);
    this.code = ERR_RPC_UNAVAILABLE_RESOURCE;
  }
}

class ResourcesNotFoundError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_MISSING_RESOURCE].message);
    this.code = ERR_RPC_MISSING_RESOURCE;
  }
}

class VersionNotSupportedError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_NOT_SUPPORTED].message);
    this.code = ERR_RPC_NOT_SUPPORTED;
  }
}

class TransactionRejectedError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_TRANSACTION_REJECTED].message);
    this.code = ERR_RPC_TRANSACTION_REJECTED;
  }
}

class LimitExceededError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_LIMIT_EXCEEDED].message);
    this.code = ERR_RPC_LIMIT_EXCEEDED;
  }
}
var rpcErrorsMap = new Map;
rpcErrorsMap.set(ERR_RPC_INVALID_JSON, { error: ParseError });
rpcErrorsMap.set(ERR_RPC_INVALID_REQUEST, {
  error: InvalidRequestError
});
rpcErrorsMap.set(ERR_RPC_INVALID_METHOD, {
  error: MethodNotFoundError
});
rpcErrorsMap.set(ERR_RPC_INVALID_PARAMS, { error: InvalidParamsError });
rpcErrorsMap.set(ERR_RPC_INTERNAL_ERROR, { error: InternalError });
rpcErrorsMap.set(ERR_RPC_INVALID_INPUT, { error: InvalidInputError });
rpcErrorsMap.set(ERR_RPC_UNSUPPORTED_METHOD, {
  error: MethodNotSupported
});
rpcErrorsMap.set(ERR_RPC_UNAVAILABLE_RESOURCE, {
  error: ResourceUnavailableError
});
rpcErrorsMap.set(ERR_RPC_TRANSACTION_REJECTED, {
  error: TransactionRejectedError
});
rpcErrorsMap.set(ERR_RPC_MISSING_RESOURCE, {
  error: ResourcesNotFoundError
});
rpcErrorsMap.set(ERR_RPC_NOT_SUPPORTED, {
  error: VersionNotSupportedError
});
rpcErrorsMap.set(ERR_RPC_LIMIT_EXCEEDED, { error: LimitExceededError });
// node_modules/web3-errors/lib/esm/errors/schema_errors.js
class SchemaFormatError extends BaseWeb3Error {
  constructor(type) {
    super(`Format for the type ${type} is unsupported`);
    this.type = type;
    this.code = ERR_SCHEMA_FORMAT;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { type: this.type });
  }
}
// node_modules/web3-utils/lib/esm/index.js
var exports_esm = {};
__export(exports_esm, {
  waitWithTimeout: () => {
    {
      return waitWithTimeout;
    }
  },
  validateResponse: () => {
    {
      return validateResponse;
    }
  },
  uuidV4: () => {
    {
      return uuidV4;
    }
  },
  utf8ToHex: () => {
    {
      return utf8ToHex;
    }
  },
  utf8ToBytes: () => {
    {
      return utf8ToBytes2;
    }
  },
  uint8ArrayEquals: () => {
    {
      return uint8ArrayEquals;
    }
  },
  uint8ArrayConcat: () => {
    {
      return uint8ArrayConcat;
    }
  },
  toWei: () => {
    {
      return toWei;
    }
  },
  toUtf8: () => {
    {
      return toUtf8;
    }
  },
  toTwosComplement: () => {
    {
      return toTwosComplement;
    }
  },
  toPayload: () => {
    {
      return toPayload;
    }
  },
  toNumber: () => {
    {
      return toNumber;
    }
  },
  toHex: () => {
    {
      return toHex;
    }
  },
  toDecimal: () => {
    {
      return toDecimal;
    }
  },
  toChecksumAddress: () => {
    {
      return toChecksumAddress;
    }
  },
  toBool: () => {
    {
      return toBool;
    }
  },
  toBigInt: () => {
    {
      return toBigInt;
    }
  },
  toBatchPayload: () => {
    {
      return toBatchPayload;
    }
  },
  toAscii: () => {
    {
      return toAscii;
    }
  },
  stringToHex: () => {
    {
      return stringToHex;
    }
  },
  soliditySha3Raw: () => {
    {
      return soliditySha3Raw;
    }
  },
  soliditySha3: () => {
    {
      return soliditySha3;
    }
  },
  sha3Raw: () => {
    {
      return sha3Raw;
    }
  },
  sha3: () => {
    {
      return sha32;
    }
  },
  setRequestIdStart: () => {
    {
      return setRequestIdStart;
    }
  },
  rightPad: () => {
    {
      return rightPad;
    }
  },
  rejectIfTimeout: () => {
    {
      return rejectIfTimeout;
    }
  },
  rejectIfConditionAtInterval: () => {
    {
      return rejectIfConditionAtInterval;
    }
  },
  randomHex: () => {
    {
      return randomHex;
    }
  },
  randomBytes: () => {
    {
      return randomBytes2;
    }
  },
  processSolidityEncodePackedArgs: () => {
    {
      return processSolidityEncodePackedArgs;
    }
  },
  pollTillDefinedAndReturnIntervalId: () => {
    {
      return pollTillDefinedAndReturnIntervalId;
    }
  },
  pollTillDefined: () => {
    {
      return pollTillDefined;
    }
  },
  padRight: () => {
    {
      return padRight;
    }
  },
  padLeft: () => {
    {
      return padLeft2;
    }
  },
  numberToHex: () => {
    {
      return numberToHex2;
    }
  },
  mergeDeep: () => {
    {
      return mergeDeep;
    }
  },
  leftPad: () => {
    {
      return leftPad;
    }
  },
  keccak256Wrapper: () => {
    {
      return keccak256Wrapper;
    }
  },
  keccak256: () => {
    {
      return keccak256Wrapper;
    }
  },
  jsonRpc: () => {
    {
      return exports_json_rpc;
    }
  },
  isValidResponse: () => {
    {
      return isValidResponse;
    }
  },
  isUserEthereumAddressInBloom: () => {
    {
      return isUserEthereumAddressInBloom2;
    }
  },
  isUint8Array: () => {
    {
      return isUint8Array2;
    }
  },
  isTopicInBloom: () => {
    {
      return isTopicInBloom2;
    }
  },
  isTopic: () => {
    {
      return isTopic2;
    }
  },
  isSubscriptionResult: () => {
    {
      return isSubscriptionResult;
    }
  },
  isResponseWithResult: () => {
    {
      return isResponseWithResult;
    }
  },
  isResponseWithNotification: () => {
    {
      return isResponseWithNotification;
    }
  },
  isResponseWithError: () => {
    {
      return isResponseWithError2;
    }
  },
  isResponseRpcError: () => {
    {
      return isResponseRpcError;
    }
  },
  isPromise: () => {
    {
      return isPromise;
    }
  },
  isNullish: () => {
    {
      return isNullish2;
    }
  },
  isInBloom: () => {
    {
      return isInBloom2;
    }
  },
  isHexStrict: () => {
    {
      return isHexStrict2;
    }
  },
  isHex: () => {
    {
      return isHex2;
    }
  },
  isDataFormat: () => {
    {
      return isDataFormat;
    }
  },
  isContractInitOptions: () => {
    {
      return isContractInitOptions;
    }
  },
  isContractAddressInBloom: () => {
    {
      return isContractAddressInBloom2;
    }
  },
  isBloom: () => {
    {
      return isBloom2;
    }
  },
  isBatchResponse: () => {
    {
      return isBatchResponse;
    }
  },
  isBatchRequest: () => {
    {
      return isBatchRequest;
    }
  },
  isAddress: () => {
    {
      return isAddress2;
    }
  },
  hexToUtf8: () => {
    {
      return hexToUtf8;
    }
  },
  hexToString: () => {
    {
      return hexToString;
    }
  },
  hexToNumberString: () => {
    {
      return hexToNumberString;
    }
  },
  hexToNumber: () => {
    {
      return hexToNumber2;
    }
  },
  hexToBytes: () => {
    {
      return hexToBytes;
    }
  },
  hexToAscii: () => {
    {
      return hexToAscii;
    }
  },
  getStorageSlotNumForLongString: () => {
    {
      return getStorageSlotNumForLongString;
    }
  },
  fromWei: () => {
    {
      return fromWei;
    }
  },
  fromUtf8: () => {
    {
      return fromUtf8;
    }
  },
  fromTwosComplement: () => {
    {
      return fromTwosComplement;
    }
  },
  fromDecimal: () => {
    {
      return fromDecimal;
    }
  },
  fromAscii: () => {
    {
      return fromAscii;
    }
  },
  format: () => {
    {
      return format;
    }
  },
  ethUnitMap: () => {
    {
      return ethUnitMap;
    }
  },
  encodePacked: () => {
    {
      return encodePacked;
    }
  },
  convertScalarValue: () => {
    {
      return convertScalarValue;
    }
  },
  convert: () => {
    {
      return convert;
    }
  },
  compareBlockNumbers: () => {
    {
      return compareBlockNumbers;
    }
  },
  checkAddressCheckSum: () => {
    {
      return checkAddressCheckSum2;
    }
  },
  bytesToUint8Array: () => {
    {
      return bytesToUint8Array;
    }
  },
  bytesToHex: () => {
    {
      return bytesToHex2;
    }
  },
  asciiToHex: () => {
    {
      return asciiToHex;
    }
  },
  Web3DeferredPromise: () => {
    {
      return Web3DeferredPromise;
    }
  },
  SocketProvider: () => {
    {
      return SocketProvider;
    }
  },
  EventEmitter: () => {
    {
      return EventEmitter2;
    }
  },
  Eip1193Provider: () => {
    {
      return Eip1193Provider;
    }
  },
  ChunkResponseParser: () => {
    {
      return ChunkResponseParser;
    }
  }
});

// node_modules/@noble/hashes/esm/_assert.js
var number = function(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
};
var bool = function(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
};
var isBytes = function(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
};
var bytes = function(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
};
var hash = function(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
};
var exists = function(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
};
var output = function(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
};
var assert = { number, bool, bytes, hash, exists, output };
var _assert_default = assert;

// node_modules/@noble/hashes/esm/_u64.js
var fromBig = function(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
};
var split = function(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0;i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
};
var add = function(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
};
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (_h, l) => l;
var rotr32L = (h, _l) => h;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var _u64_default = u64;

// node_modules/@noble/hashes/esm/cryptoNode.js
import * as nc from "crypto";
var crypto2 = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : undefined;

// node_modules/@noble/hashes/esm/utils.js
var isBytes2 = function(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
};
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!isBytes2(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0;i < arrays.length; i++) {
    const a = arrays[i];
    if (!isBytes2(a))
      throw new Error("Uint8Array expected");
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0;i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function checkOpts(defaults, opts) {
  if (opts !== undefined && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
class Hash {
  clone() {
    return this._cloneInto();
  }
}
var toStr = {}.toString;

// node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds;round < 24; round++) {
    for (let x = 0;x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0;x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0;y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0;t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0;y < 50; y += 10) {
      for (let x = 0;x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0;x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R = _1n, x = 1, y = 0;round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0;j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t ^= _1n << (_1n << BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);

class Keccak extends Hash {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0;i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length;pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/ethereum-cryptography/esm/utils.js
function bytesToUtf8(data) {
  if (!(data instanceof Uint8Array)) {
    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
  }
  return new TextDecoder().decode(data);
}
function equalsBytes(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0;i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function wrapHash(hash2) {
  return (msg) => {
    _assert_default.bytes(msg);
    return hash2(msg);
  };
}
var assertBool = _assert_default.bool;
var assertBytes = _assert_default.bytes;
var crypto4 = (() => {
  const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;
  const nodeRequire = typeof module_utils !== "undefined" && typeof module_utils.require === "function" && module_utils.require.bind(module_utils);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
    web: webCrypto
  };
})();

// node_modules/ethereum-cryptography/esm/keccak.js
var keccak224 = wrapHash(keccak_224);
var keccak256 = (() => {
  const k = wrapHash(keccak_256);
  k.create = keccak_256.create;
  return k;
})();
var keccak384 = wrapHash(keccak_384);
var keccak512 = wrapHash(keccak_512);

// node_modules/zod/lib/index.mjs
var setErrorMap = function(map) {
  overrideErrorMap = map;
};
var getErrorMap = function() {
  return overrideErrorMap;
};
var addIssueToContext = function(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
};
var processCreateParams = function(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== undefined ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== undefined ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
};
var isValidIP = function(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
};
var floatSafeRemainder = function(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
};
var deepPartialify = function(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
};
var mergeValues = function(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
};
var createZodEnum = function(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};

class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+\$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z\$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z\$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z\$`);
    }
  }
};

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/web3-validator/lib/esm/errors.js
var errorFormatter = (error) => {
  if (error.message) {
    return error.message;
  }
  return "unspecified error";
};

class Web3ValidatorError extends BaseWeb3Error {
  constructor(errors) {
    super();
    this.code = ERR_VALIDATION;
    this.errors = errors;
    super.message = `Web3 validator found ${errors.length} error[s]:\n${this._compileErrors().join("\n")}`;
  }
  _compileErrors() {
    return this.errors.map(errorFormatter);
  }
}

// node_modules/web3-validator/lib/esm/utils.js
var exports_utils = {};
__export(exports_utils, {
  uint8ArrayToHexString: () => {
    {
      return uint8ArrayToHexString;
    }
  },
  transformJsonDataToAbiFormat: () => {
    {
      return transformJsonDataToAbiFormat;
    }
  },
  parseBaseType: () => {
    {
      return parseBaseType;
    }
  },
  padLeft: () => {
    {
      return padLeft;
    }
  },
  numberToHex: () => {
    {
      return numberToHex;
    }
  },
  hexToUint8Array: () => {
    {
      return hexToUint8Array;
    }
  },
  hexToNumber: () => {
    {
      return hexToNumber;
    }
  },
  fetchArrayElement: () => {
    {
      return fetchArrayElement;
    }
  },
  ethAbiToJsonSchema: () => {
    {
      return ethAbiToJsonSchema;
    }
  },
  ensureIfUint8Array: () => {
    {
      return ensureIfUint8Array;
    }
  },
  codePointToInt: () => {
    {
      return codePointToInt;
    }
  },
  abiSchemaToJsonSchema: () => {
    {
      return abiSchemaToJsonSchema;
    }
  }
});

// node_modules/web3-validator/lib/esm/constants.js
var VALID_ETH_BASE_TYPES = ["bool", "int", "uint", "bytes", "string", "address", "tuple"];

// node_modules/web3-validator/lib/esm/validation/abi.js
var isAbiParameterSchema = (schema) => typeof schema === "object" && ("type" in schema) && ("name" in schema);

// node_modules/web3-validator/lib/esm/validation/string.js
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
    return false;
  if (typeof length !== "undefined" && length > 0 && value.length !== 2 + 2 * length)
    return false;
  return true;
}
function isHexPrefixed(str) {
  if (typeof str !== "string") {
    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);
  }
  return str.startsWith("0x");
}
var isString = (value) => typeof value === "string";
var isHexStrict = (hex) => typeof hex === "string" && /^((-)?0x[0-9a-f]+|(0x))$/i.test(hex);
var isHex = (hex) => typeof hex === "number" || typeof hex === "bigint" || typeof hex === "string" && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(hex);
var validateNoLeadingZeroes = function(values) {
  for (const [k, v] of Object.entries(values)) {
    if (v !== undefined && v.length > 0 && v[0] === 0) {
      throw new Error(`${k} cannot have leading zeroes, received: ${v.toString()}`);
    }
  }
};

// node_modules/web3-validator/lib/esm/utils.js
function uint8ArrayToHexString(uint8Array) {
  let hexString = "0x";
  for (const e of uint8Array) {
    const hex = e.toString(16);
    hexString += hex.length === 1 ? `0${hex}` : hex;
  }
  return hexString;
}
var charCodeToBase16 = function(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return;
};
function hexToUint8Array(hex) {
  let offset = 0;
  if (hex.startsWith("0") && (hex[1] === "x" || hex[1] === "X")) {
    offset = 2;
  }
  if (hex.length % 2 !== 0) {
    throw new InvalidBytesError(`hex string has odd length: ${hex}`);
  }
  const length = (hex.length - offset) / 2;
  const bytes2 = new Uint8Array(length);
  for (let index = 0, j = offset;index < length; index += 1) {
    const nibbleLeft = charCodeToBase16(hex.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hex.charCodeAt(j++));
    if (nibbleLeft === undefined || nibbleRight === undefined) {
      throw new InvalidBytesError(`Invalid byte sequence ("${hex[j - 2]}${hex[j - 1]}" in "${hex}").`);
    }
    bytes2[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes2;
}
function ensureIfUint8Array(data) {
  var _a;
  if (!(data instanceof Uint8Array) && ((_a = data === null || data === undefined ? undefined : data.constructor) === null || _a === undefined ? undefined : _a.name) === "Uint8Array") {
    return Uint8Array.from(data);
  }
  return data;
}
var extraTypes = ["hex", "number", "blockNumber", "blockNumberOrTag", "filter", "bloom"];
var parseBaseType = (type) => {
  let strippedType = type.replace(/ /, "");
  let baseTypeSize;
  let isArray = false;
  let arraySizes = [];
  if (type.includes("[")) {
    strippedType = strippedType.slice(0, strippedType.indexOf("["));
    arraySizes = [...type.matchAll(/(?:\[(\d*)\])/g)].map((match) => parseInt(match[1], 10)).map((size) => Number.isNaN(size) ? -1 : size);
    isArray = arraySizes.length > 0;
  }
  if (VALID_ETH_BASE_TYPES.includes(strippedType)) {
    return { baseType: strippedType, isArray, baseTypeSize, arraySizes };
  }
  if (strippedType.startsWith("int")) {
    baseTypeSize = parseInt(strippedType.substring(3), 10);
    strippedType = "int";
  } else if (strippedType.startsWith("uint")) {
    baseTypeSize = parseInt(type.substring(4), 10);
    strippedType = "uint";
  } else if (strippedType.startsWith("bytes")) {
    baseTypeSize = parseInt(strippedType.substring(5), 10);
    strippedType = "bytes";
  } else {
    return { baseType: undefined, isArray: false, baseTypeSize: undefined, arraySizes };
  }
  return { baseType: strippedType, isArray, baseTypeSize, arraySizes };
};
var convertEthType = (type, parentSchema = {}) => {
  const typePropertyPresent = Object.keys(parentSchema).includes("type");
  if (typePropertyPresent) {
    throw new Web3ValidatorError([
      {
        keyword: "eth",
        message: 'Either "eth" or "type" can be presented in schema',
        params: { eth: type },
        instancePath: "",
        schemaPath: ""
      }
    ]);
  }
  const { baseType, baseTypeSize } = parseBaseType(type);
  if (!baseType && !extraTypes.includes(type)) {
    throw new Web3ValidatorError([
      {
        keyword: "eth",
        message: `Eth data type "${type}" is not valid`,
        params: { eth: type },
        instancePath: "",
        schemaPath: ""
      }
    ]);
  }
  if (baseType) {
    if (baseType === "tuple") {
      throw new Error('"tuple" type is not implemented directly.');
    }
    return { format: `${baseType}${baseTypeSize !== null && baseTypeSize !== undefined ? baseTypeSize : ""}`, required: true };
  }
  if (type) {
    return { format: type, required: true };
  }
  return {};
};
var abiSchemaToJsonSchema = (abis, level2 = "/0") => {
  const schema = {
    type: "array",
    items: [],
    maxItems: abis.length,
    minItems: abis.length
  };
  for (const [index, abi2] of abis.entries()) {
    let abiType;
    let abiName;
    let abiComponents = [];
    if (isAbiParameterSchema(abi2)) {
      abiType = abi2.type;
      abiName = abi2.name;
      abiComponents = abi2.components;
    } else if (typeof abi2 === "string") {
      abiType = abi2;
      abiName = `${level2}/${index}`;
    } else if (Array.isArray(abi2)) {
      if (abi2[0] && typeof abi2[0] === "string" && abi2[0].startsWith("tuple") && !Array.isArray(abi2[0]) && abi2[1] && Array.isArray(abi2[1])) {
        abiType = abi2[0];
        abiName = `${level2}/${index}`;
        abiComponents = abi2[1];
      } else {
        abiType = "tuple";
        abiName = `${level2}/${index}`;
        abiComponents = abi2;
      }
    }
    const { baseType, isArray, arraySizes } = parseBaseType(abiType);
    let childSchema;
    let lastSchema = schema;
    for (let i = arraySizes.length - 1;i > 0; i -= 1) {
      childSchema = {
        type: "array",
        items: [],
        maxItems: arraySizes[i],
        minItems: arraySizes[i]
      };
      if (arraySizes[i] < 0) {
        delete childSchema.maxItems;
        delete childSchema.minItems;
      }
      if (!Array.isArray(lastSchema.items)) {
        lastSchema.items = [lastSchema.items, childSchema];
      } else if (lastSchema.items.length === 0) {
        lastSchema.items = childSchema;
      } else {
        lastSchema.items.push(childSchema);
      }
      lastSchema = childSchema;
    }
    if (baseType === "tuple" && !isArray) {
      const nestedTuple = abiSchemaToJsonSchema(abiComponents, abiName);
      nestedTuple.$id = abiName;
      lastSchema.items.push(nestedTuple);
    } else if (baseType === "tuple" && isArray) {
      const arraySize = arraySizes[0];
      const item = {
        $id: abiName,
        type: "array",
        items: abiSchemaToJsonSchema(abiComponents, abiName),
        maxItems: arraySize,
        minItems: arraySize
      };
      if (arraySize < 0) {
        delete item.maxItems;
        delete item.minItems;
      }
      lastSchema.items.push(item);
    } else if (isArray) {
      const arraySize = arraySizes[0];
      const item = {
        type: "array",
        $id: abiName,
        items: convertEthType(String(baseType)),
        minItems: arraySize,
        maxItems: arraySize
      };
      if (arraySize < 0) {
        delete item.maxItems;
        delete item.minItems;
      }
      lastSchema.items.push(item);
    } else if (Array.isArray(lastSchema.items)) {
      lastSchema.items.push(Object.assign({ $id: abiName }, convertEthType(abiType)));
    } else {
      lastSchema.items.items.push(Object.assign({ $id: abiName }, convertEthType(abiType)));
    }
    lastSchema = schema;
  }
  return schema;
};
var ethAbiToJsonSchema = (abis) => abiSchemaToJsonSchema(abis);
var fetchArrayElement = (data, level2) => {
  if (level2 === 1) {
    return data;
  }
  return fetchArrayElement(data[0], level2 - 1);
};
var transformJsonDataToAbiFormat = (abis, data, transformedData) => {
  const newData = [];
  for (const [index, abi2] of abis.entries()) {
    let abiType;
    let abiName;
    let abiComponents = [];
    if (isAbiParameterSchema(abi2)) {
      abiType = abi2.type;
      abiName = abi2.name;
      abiComponents = abi2.components;
    } else if (typeof abi2 === "string") {
      abiType = abi2;
    } else if (Array.isArray(abi2)) {
      if (abi2[1] && Array.isArray(abi2[1])) {
        abiType = abi2[0];
        abiComponents = abi2[1];
      } else {
        abiType = "tuple";
        abiComponents = abi2;
      }
    }
    const { baseType, isArray, arraySizes } = parseBaseType(abiType);
    const dataItem = Array.isArray(data) ? data[index] : data[abiName];
    if (baseType === "tuple" && !isArray) {
      newData.push(transformJsonDataToAbiFormat(abiComponents, dataItem, transformedData));
    } else if (baseType === "tuple" && isArray) {
      const tupleData = [];
      for (const tupleItem of dataItem) {
        if (arraySizes.length > 1) {
          const nestedItems = fetchArrayElement(tupleItem, arraySizes.length - 1);
          const nestedData = [];
          for (const nestedItem of nestedItems) {
            nestedData.push(transformJsonDataToAbiFormat(abiComponents, nestedItem, transformedData));
          }
          tupleData.push(nestedData);
        } else {
          tupleData.push(transformJsonDataToAbiFormat(abiComponents, tupleItem, transformedData));
        }
      }
      newData.push(tupleData);
    } else {
      newData.push(dataItem);
    }
  }
  transformedData = transformedData !== null && transformedData !== undefined ? transformedData : [];
  transformedData.push(...newData);
  return transformedData;
};
var codePointToInt = (codePoint) => {
  if (codePoint >= 48 && codePoint <= 57) {
    return codePoint - 48;
  }
  if (codePoint >= 65 && codePoint <= 70) {
    return codePoint - 55;
  }
  if (codePoint >= 97 && codePoint <= 102) {
    return codePoint - 87;
  }
  throw new Error(`Invalid code point: ${codePoint}`);
};
var hexToNumber = (value) => {
  if (!isHexStrict(value)) {
    throw new Error("Invalid hex string");
  }
  const [negative, hexValue] = value.startsWith("-") ? [true, value.slice(1)] : [false, value];
  const num = BigInt(hexValue);
  if (num > Number.MAX_SAFE_INTEGER) {
    return negative ? -num : num;
  }
  if (num < Number.MIN_SAFE_INTEGER) {
    return num;
  }
  return negative ? -1 * Number(num) : Number(num);
};
var numberToHex = (value) => {
  if ((typeof value === "number" || typeof value === "bigint") && value < 0) {
    return `-0x${value.toString(16).slice(1)}`;
  }
  if ((typeof value === "number" || typeof value === "bigint") && value >= 0) {
    return `0x${value.toString(16)}`;
  }
  if (typeof value === "string" && isHexStrict(value)) {
    const [negative, hex] = value.startsWith("-") ? [true, value.slice(1)] : [false, value];
    const hexValue = hex.split(/^(-)?0(x|X)/).slice(-1)[0];
    return `${negative ? "-" : ""}0x${hexValue.replace(/^0+/, "").toLowerCase()}`;
  }
  if (typeof value === "string" && !isHexStrict(value)) {
    return numberToHex(BigInt(value));
  }
  throw new InvalidNumberError(value);
};
var padLeft = (value, characterAmount, sign = "0") => {
  if (typeof value === "string" && !isHexStrict(value)) {
    return value.padStart(characterAmount, sign);
  }
  const hex = typeof value === "string" && isHexStrict(value) ? value : numberToHex(value);
  const [prefix, hexValue] = hex.startsWith("-") ? ["-0x", hex.slice(3)] : ["0x", hex.slice(2)];
  return `${prefix}${hexValue.padStart(characterAmount, sign)}`;
};
var charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};

// node_modules/web3-validator/lib/esm/validation/bytes.js
var isUint8Array = (data) => {
  var _a;
  return data instanceof Uint8Array || ((_a = data === null || data === undefined ? undefined : data.constructor) === null || _a === undefined ? undefined : _a.name) === "Uint8Array";
};
var isBytes3 = (value, options = {
  abiType: "bytes"
}) => {
  if (typeof value !== "string" && !Array.isArray(value) && !isUint8Array(value)) {
    return false;
  }
  if (typeof value === "string" && isHexStrict(value) && value.startsWith("-")) {
    return false;
  }
  if (typeof value === "string" && !isHexStrict(value)) {
    return false;
  }
  let valueToCheck;
  if (typeof value === "string") {
    if (value.length % 2 !== 0) {
      return false;
    }
    valueToCheck = hexToUint8Array(value);
  } else if (Array.isArray(value)) {
    if (value.some((d) => d < 0 || d > 255 || !Number.isInteger(d))) {
      return false;
    }
    valueToCheck = new Uint8Array(value);
  } else {
    valueToCheck = value;
  }
  if (options === null || options === undefined ? undefined : options.abiType) {
    const { baseTypeSize } = parseBaseType(options.abiType);
    return baseTypeSize ? valueToCheck.length === baseTypeSize : true;
  }
  if (options === null || options === undefined ? undefined : options.size) {
    return valueToCheck.length === (options === null || options === undefined ? undefined : options.size);
  }
  return true;
};

// node_modules/web3-validator/lib/esm/validation/address.js
var checkAddressCheckSum = (data) => {
  if (!/^(0x)?[0-9a-f]{40}$/i.test(data))
    return false;
  const address = data.slice(2);
  const updatedData = utf8ToBytes(address.toLowerCase());
  const addressHash = uint8ArrayToHexString(keccak256(ensureIfUint8Array(updatedData))).slice(2);
  for (let i = 0;i < 40; i += 1) {
    if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {
      return false;
    }
  }
  return true;
};
var isAddress = (value, checkChecksum = true) => {
  if (typeof value !== "string" && !isUint8Array(value)) {
    return false;
  }
  let valueToCheck;
  if (isUint8Array(value)) {
    valueToCheck = uint8ArrayToHexString(value);
  } else if (typeof value === "string" && !isHexStrict(value)) {
    valueToCheck = value.toLowerCase().startsWith("0x") ? value : `0x${value}`;
  } else {
    valueToCheck = value;
  }
  if (!/^(0x)?[0-9a-f]{40}$/i.test(valueToCheck)) {
    return false;
  }
  if (/^(0x|0X)?[0-9a-f]{40}$/.test(valueToCheck) || /^(0x|0X)?[0-9A-F]{40}$/.test(valueToCheck)) {
    return true;
  }
  return checkChecksum ? checkAddressCheckSum(valueToCheck) : true;
};
// node_modules/web3-types/lib/esm/data_format_types.js
var FMT_NUMBER;
(function(FMT_NUMBER2) {
  FMT_NUMBER2["NUMBER"] = "NUMBER_NUMBER";
  FMT_NUMBER2["HEX"] = "NUMBER_HEX";
  FMT_NUMBER2["STR"] = "NUMBER_STR";
  FMT_NUMBER2["BIGINT"] = "NUMBER_BIGINT";
})(FMT_NUMBER || (FMT_NUMBER = {}));
var FMT_BYTES;
(function(FMT_BYTES2) {
  FMT_BYTES2["HEX"] = "BYTES_HEX";
  FMT_BYTES2["UINT8ARRAY"] = "BYTES_UINT8ARRAY";
})(FMT_BYTES || (FMT_BYTES = {}));
var DEFAULT_RETURN_FORMAT = { number: FMT_NUMBER.BIGINT, bytes: FMT_BYTES.HEX };
var ETH_DATA_FORMAT = { number: FMT_NUMBER.HEX, bytes: FMT_BYTES.HEX };
// node_modules/web3-types/lib/esm/eth_types.js
var BlockTags;
(function(BlockTags2) {
  BlockTags2["EARLIEST"] = "earliest";
  BlockTags2["LATEST"] = "latest";
  BlockTags2["PENDING"] = "pending";
  BlockTags2["SAFE"] = "safe";
  BlockTags2["FINALIZED"] = "finalized";
})(BlockTags || (BlockTags = {}));
var HardforksOrdered;
(function(HardforksOrdered2) {
  HardforksOrdered2["chainstart"] = "chainstart";
  HardforksOrdered2["frontier"] = "frontier";
  HardforksOrdered2["homestead"] = "homestead";
  HardforksOrdered2["dao"] = "dao";
  HardforksOrdered2["tangerineWhistle"] = "tangerineWhistle";
  HardforksOrdered2["spuriousDragon"] = "spuriousDragon";
  HardforksOrdered2["byzantium"] = "byzantium";
  HardforksOrdered2["constantinople"] = "constantinople";
  HardforksOrdered2["petersburg"] = "petersburg";
  HardforksOrdered2["istanbul"] = "istanbul";
  HardforksOrdered2["muirGlacier"] = "muirGlacier";
  HardforksOrdered2["berlin"] = "berlin";
  HardforksOrdered2["london"] = "london";
  HardforksOrdered2["altair"] = "altair";
  HardforksOrdered2["arrowGlacier"] = "arrowGlacier";
  HardforksOrdered2["grayGlacier"] = "grayGlacier";
  HardforksOrdered2["bellatrix"] = "bellatrix";
  HardforksOrdered2["merge"] = "merge";
  HardforksOrdered2["capella"] = "capella";
  HardforksOrdered2["shanghai"] = "shanghai";
})(HardforksOrdered || (HardforksOrdered = {}));
// node_modules/web3-types/lib/esm/primitives_types.js
var TypedArray = Object.getPrototypeOf(Uint8Array);
// node_modules/web3-types/lib/esm/web3_base_provider.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var symbol = Symbol.for("web3/base-provider");

class Web3BaseProvider {
  static isWeb3Provider(provider) {
    return provider instanceof Web3BaseProvider || Boolean(provider && provider[symbol]);
  }
  get [symbol]() {
    return true;
  }
  send(payload, callback) {
    this.request(payload).then((response) => {
      callback(null, response);
    }).catch((err) => {
      callback(err);
    });
  }
  sendAsync(payload) {
    return __awaiter(this, undefined, undefined, function* () {
      return this.request(payload);
    });
  }
  asEIP1193Provider() {
    const newObj = Object.create(this);
    const originalRequest = newObj.request;
    newObj.request = function request(args) {
      return __awaiter(this, undefined, undefined, function* () {
        const response = yield originalRequest(args);
        return response.result;
      });
    };
    newObj.asEIP1193Provider = undefined;
    return newObj;
  }
}
// node_modules/web3-types/lib/esm/web3_base_wallet.js
class Web3BaseWallet extends Array {
  constructor(accountProvider) {
    super();
    this._accountProvider = accountProvider;
  }
}
// node_modules/web3-validator/lib/esm/validation/numbers.js
var bigintPower = (base, expo) => {
  let res = base;
  for (let index = 1;index < expo; index += 1) {
    res *= base;
  }
  return res;
};
var isUInt = (value, options = {
  abiType: "uint"
}) => {
  if (!["number", "string", "bigint"].includes(typeof value) || typeof value === "string" && value.length === 0) {
    return false;
  }
  let size;
  if (options === null || options === undefined ? undefined : options.abiType) {
    const { baseTypeSize } = parseBaseType(options.abiType);
    if (baseTypeSize) {
      size = baseTypeSize;
    }
  } else if (options.bitSize) {
    size = options.bitSize;
  }
  const maxSize = bigintPower(BigInt(2), BigInt(size !== null && size !== undefined ? size : 256)) - BigInt(1);
  try {
    const valueToCheck = typeof value === "string" && isHexStrict(value) ? BigInt(hexToNumber(value)) : BigInt(value);
    return valueToCheck >= 0 && valueToCheck <= maxSize;
  } catch (error) {
    return false;
  }
};
var isInt = (value, options = {
  abiType: "int"
}) => {
  if (!["number", "string", "bigint"].includes(typeof value)) {
    return false;
  }
  if (typeof value === "number" && value > Number.MAX_SAFE_INTEGER) {
    return false;
  }
  let size;
  if (options === null || options === undefined ? undefined : options.abiType) {
    const { baseTypeSize, baseType } = parseBaseType(options.abiType);
    if (baseType !== "int") {
      return false;
    }
    if (baseTypeSize) {
      size = baseTypeSize;
    }
  } else if (options.bitSize) {
    size = options.bitSize;
  }
  const maxSize = bigintPower(BigInt(2), BigInt((size !== null && size !== undefined ? size : 256) - 1));
  const minSize = BigInt(-1) * bigintPower(BigInt(2), BigInt((size !== null && size !== undefined ? size : 256) - 1));
  try {
    const valueToCheck = typeof value === "string" && isHexStrict(value) ? BigInt(hexToNumber(value)) : BigInt(value);
    return valueToCheck >= minSize && valueToCheck <= maxSize;
  } catch (error) {
    return false;
  }
};
var isNumber = (value) => {
  if (isInt(value)) {
    return true;
  }
  if (typeof value === "string" && /[0-9.]/.test(value) && value.indexOf(".") === value.lastIndexOf(".")) {
    return true;
  }
  if (typeof value === "number") {
    return true;
  }
  return false;
};

// node_modules/web3-validator/lib/esm/validation/block.js
var isBlockNumber = (value) => isUInt(value);
var isBlockTag = (value) => Object.values(BlockTags).includes(value);
var isBlockNumberOrTag = (value) => isBlockTag(value) || isBlockNumber(value);

// node_modules/web3-validator/lib/esm/validation/bloom.js
var isBloom = (bloom) => {
  if (typeof bloom !== "string") {
    return false;
  }
  if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
    return false;
  }
  if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
    return true;
  }
  return false;
};
var isInBloom = (bloom, value) => {
  if (typeof value === "string" && !isHexStrict(value)) {
    return false;
  }
  if (!isBloom(bloom)) {
    return false;
  }
  const uint8Array = typeof value === "string" ? hexToUint8Array(value) : value;
  const hash2 = uint8ArrayToHexString(keccak256(uint8Array)).slice(2);
  for (let i = 0;i < 12; i += 4) {
    const bitpos = (parseInt(hash2.slice(i, i + 2), 16) << 8) + parseInt(hash2.slice(i + 2, i + 4), 16) & 2047;
    const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));
    const offset = 1 << bitpos % 4;
    if ((code & offset) !== offset) {
      return false;
    }
  }
  return true;
};
var isUserEthereumAddressInBloom = (bloom, ethereumAddress) => {
  if (!isBloom(bloom)) {
    return false;
  }
  if (!isAddress(ethereumAddress)) {
    return false;
  }
  const address2 = padLeft(ethereumAddress, 64);
  return isInBloom(bloom, address2);
};
var isContractAddressInBloom = (bloom, contractAddress) => {
  if (!isBloom(bloom)) {
    return false;
  }
  if (!isAddress(contractAddress)) {
    return false;
  }
  return isInBloom(bloom, contractAddress);
};

// node_modules/web3-validator/lib/esm/validation/boolean.js
var isBoolean = (value) => {
  if (!["number", "string", "boolean"].includes(typeof value)) {
    return false;
  }
  if (typeof value === "boolean") {
    return true;
  }
  if (typeof value === "string" && !isHexStrict(value)) {
    return value === "1" || value === "0";
  }
  if (typeof value === "string" && isHexStrict(value)) {
    return value === "0x1" || value === "0x0";
  }
  return value === 1 || value === 0;
};

// node_modules/web3-validator/lib/esm/validation/object.js
var isNullish = (item) => item === undefined || item === null;
var isObject = (item) => typeof item === "object" && !isNullish(item) && !Array.isArray(item) && !(item instanceof TypedArray);

// node_modules/web3-validator/lib/esm/validation/topic.js
var isTopic = (topic) => {
  if (typeof topic !== "string") {
    return false;
  }
  if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
    return false;
  }
  if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
    return true;
  }
  return false;
};
var isTopicInBloom = (bloom2, topic) => {
  if (!isBloom(bloom2)) {
    return false;
  }
  if (!isTopic(topic)) {
    return false;
  }
  return isInBloom(bloom2, topic);
};

// node_modules/web3-validator/lib/esm/validation/filter.js
var isFilterObject = (value) => {
  const expectedFilterProperties = [
    "fromBlock",
    "toBlock",
    "address",
    "topics",
    "blockHash"
  ];
  if (isNullish(value) || typeof value !== "object")
    return false;
  if (!Object.keys(value).every((property) => expectedFilterProperties.includes(property)))
    return false;
  if (!isNullish(value.fromBlock) && !isBlockNumberOrTag(value.fromBlock) || !isNullish(value.toBlock) && !isBlockNumberOrTag(value.toBlock))
    return false;
  if (!isNullish(value.address)) {
    if (Array.isArray(value.address)) {
      if (!value.address.every((address3) => isAddress(address3)))
        return false;
    } else if (!isAddress(value.address))
      return false;
  }
  if (!isNullish(value.topics)) {
    if (!value.topics.every((topic2) => {
      if (isNullish(topic2))
        return true;
      if (Array.isArray(topic2)) {
        return topic2.every((nestedTopic) => isTopic(nestedTopic));
      }
      if (isTopic(topic2))
        return true;
      return false;
    }))
      return false;
  }
  return true;
};

// node_modules/web3-validator/lib/esm/formats.js
var formats = {
  address: (data) => isAddress(data),
  bloom: (data) => isBloom(data),
  blockNumber: (data) => isBlockNumber(data),
  blockTag: (data) => isBlockTag(data),
  blockNumberOrTag: (data) => isBlockNumberOrTag(data),
  bool: (data) => isBoolean(data),
  bytes: (data) => isBytes3(data),
  filter: (data) => isFilterObject(data),
  hex: (data) => isHexStrict(data),
  uint: (data) => isUInt(data),
  int: (data) => isInt(data),
  number: (data) => isNumber(data),
  string: (data) => isString(data)
};
for (let bitSize = 8;bitSize <= 256; bitSize += 8) {
  formats[`int${bitSize}`] = (data) => isInt(data, { bitSize });
  formats[`uint${bitSize}`] = (data) => isUInt(data, { bitSize });
}
for (let size = 1;size <= 32; size += 1) {
  formats[`bytes${size}`] = (data) => isBytes3(data, { size });
}
formats.bytes256 = formats.bytes;
var formats_default = formats;

// node_modules/web3-validator/lib/esm/validator.js
var convertToZod = (schema) => {
  if ((!(schema === null || schema === undefined ? undefined : schema.type) || (schema === null || schema === undefined ? undefined : schema.type) === "object") && (schema === null || schema === undefined ? undefined : schema.properties)) {
    const obj = {};
    for (const name of Object.keys(schema.properties)) {
      const zItem = convertToZod(schema.properties[name]);
      if (zItem) {
        obj[name] = zItem;
      }
    }
    if (Array.isArray(schema.required)) {
      return z.object(obj).partial().required(schema.required.reduce((acc, v) => Object.assign(Object.assign({}, acc), { [v]: true }), {}));
    }
    return z.object(obj).partial();
  }
  if ((schema === null || schema === undefined ? undefined : schema.type) === "array" && (schema === null || schema === undefined ? undefined : schema.items)) {
    if (Array.isArray(schema.items) && schema.items.length > 0) {
      const arr = [];
      for (const item of schema.items) {
        const zItem = convertToZod(item);
        if (zItem) {
          arr.push(zItem);
        }
      }
      return z.tuple(arr);
    }
    return z.array(convertToZod(schema.items));
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    return z.union(schema.oneOf.map((oneOfSchema) => convertToZod(oneOfSchema)));
  }
  if (schema === null || schema === undefined ? undefined : schema.format) {
    if (!formats_default[schema.format]) {
      throw new SchemaFormatError(schema.format);
    }
    return z.any().refine(formats_default[schema.format], (value) => ({
      params: { value, format: schema.format }
    }));
  }
  if ((schema === null || schema === undefined ? undefined : schema.type) && (schema === null || schema === undefined ? undefined : schema.type) !== "object" && typeof z[String(schema.type)] === "function") {
    return z[String(schema.type)]();
  }
  return z.object({ data: z.any() }).partial();
};

class Validator {
  static factory() {
    if (!Validator.validatorInstance) {
      Validator.validatorInstance = new Validator;
    }
    return Validator.validatorInstance;
  }
  validate(schema, data, options) {
    var _a, _b;
    const zod = convertToZod(schema);
    const result = zod.safeParse(data);
    if (!result.success) {
      const errors3 = this.convertErrors((_b = (_a = result.error) === null || _a === undefined ? undefined : _a.issues) !== null && _b !== undefined ? _b : []);
      if (errors3) {
        if (options === null || options === undefined ? undefined : options.silent) {
          return errors3;
        }
        throw new Web3ValidatorError(errors3);
      }
    }
    return;
  }
  convertErrors(errors3) {
    if (errors3 && Array.isArray(errors3) && errors3.length > 0) {
      return errors3.map((error) => {
        var _a;
        let message;
        let keyword;
        let params;
        let schemaPath;
        schemaPath = error.path.join("/");
        const field = String(error.path[error.path.length - 1]);
        const instancePath = error.path.join("/");
        if (error.code === ZodIssueCode.too_big) {
          keyword = "maxItems";
          schemaPath = `${instancePath}/maxItems`;
          params = { limit: error.maximum };
          message = `must NOT have more than ${error.maximum} items`;
        } else if (error.code === ZodIssueCode.too_small) {
          keyword = "minItems";
          schemaPath = `${instancePath}/minItems`;
          params = { limit: error.minimum };
          message = `must NOT have fewer than ${error.minimum} items`;
        } else if (error.code === ZodIssueCode.custom) {
          const { value, format } = (_a = error.params) !== null && _a !== undefined ? _a : {};
          if (typeof value === "undefined") {
            message = `value at "/${schemaPath}" is required`;
          } else {
            message = `value "${typeof value === "object" ? JSON.stringify(value) : value}" at "/${schemaPath}" must pass "${format}" validation`;
          }
          params = { value };
        }
        return {
          keyword: keyword !== null && keyword !== undefined ? keyword : field,
          instancePath: instancePath ? `/${instancePath}` : "",
          schemaPath: schemaPath ? `#${schemaPath}` : "#",
          params: params !== null && params !== undefined ? params : { value: error.message },
          message: message !== null && message !== undefined ? message : error.message
        };
      });
    }
    return;
  }
}

// node_modules/web3-validator/lib/esm/web3_validator.js
class Web3Validator {
  constructor() {
    this._validator = Validator.factory();
  }
  validateJSONSchema(schema, data, options) {
    return this._validator.validate(schema, data, options);
  }
  validate(schema, data, options = { silent: false }) {
    var _a, _b;
    const jsonSchema = ethAbiToJsonSchema(schema);
    if (Array.isArray(jsonSchema.items) && ((_a = jsonSchema.items) === null || _a === undefined ? undefined : _a.length) === 0 && data.length === 0) {
      return;
    }
    if (Array.isArray(jsonSchema.items) && ((_b = jsonSchema.items) === null || _b === undefined ? undefined : _b.length) === 0 && data.length !== 0) {
      throw new Web3ValidatorError([
        {
          instancePath: "/0",
          schemaPath: "/",
          keyword: "required",
          message: "empty schema against data can not be validated",
          params: data
        }
      ]);
    }
    return this._validator.validate(jsonSchema, data, options);
  }
}
// node_modules/web3-validator/lib/esm/default_validator.js
var validator2 = new Web3Validator;
// node_modules/web3-utils/lib/esm/uint8array.js
function isUint8Array2(data) {
  var _a;
  return data instanceof Uint8Array || ((_a = data === null || data === undefined ? undefined : data.constructor) === null || _a === undefined ? undefined : _a.name) === "Uint8Array";
}
function uint8ArrayConcat(...parts) {
  const length = parts.reduce((prev, part) => {
    const agg = prev + part.length;
    return agg;
  }, 0);
  const result = new Uint8Array(length);
  let offset = 0;
  for (const part of parts) {
    result.set(part, offset);
    offset += part.length;
  }
  return result;
}
function uint8ArrayEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0;i < a.byteLength; i += 1) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/web3-utils/lib/esm/converters.js
var ethUnitMap = {
  noether: BigInt(0),
  wei: BigInt(1),
  kwei: BigInt(1000),
  Kwei: BigInt(1000),
  babbage: BigInt(1000),
  femtoether: BigInt(1000),
  mwei: BigInt(1e6),
  Mwei: BigInt(1e6),
  lovelace: BigInt(1e6),
  picoether: BigInt(1e6),
  gwei: BigInt(1e9),
  Gwei: BigInt(1e9),
  shannon: BigInt(1e9),
  nanoether: BigInt(1e9),
  nano: BigInt(1e9),
  szabo: BigInt(1000000000000),
  microether: BigInt(1000000000000),
  micro: BigInt(1000000000000),
  finney: BigInt(1000000000000000),
  milliether: BigInt(1000000000000000),
  milli: BigInt(1000000000000000),
  ether: BigInt("1000000000000000000"),
  kether: BigInt("1000000000000000000000"),
  grand: BigInt("1000000000000000000000"),
  mether: BigInt("1000000000000000000000000"),
  gether: BigInt("1000000000000000000000000000"),
  tether: BigInt("1000000000000000000000000000000")
};
var bytesToUint8Array = (data) => {
  validator2.validate(["bytes"], [data]);
  if (isUint8Array2(data)) {
    return data;
  }
  if (Array.isArray(data)) {
    return new Uint8Array(data);
  }
  if (typeof data === "string") {
    return exports_utils.hexToUint8Array(data);
  }
  throw new InvalidBytesError(data);
};
var { uint8ArrayToHexString: uint8ArrayToHexString2 } = exports_utils;
var bytesToHex2 = (bytes5) => uint8ArrayToHexString2(bytesToUint8Array(bytes5));
var hexToBytes = (bytes5) => {
  if (typeof bytes5 === "string" && bytes5.slice(0, 2).toLowerCase() !== "0x") {
    return bytesToUint8Array(`0x${bytes5}`);
  }
  return bytesToUint8Array(bytes5);
};
var hexToNumber2 = (value) => {
  validator2.validate(["hex"], [value]);
  return exports_utils.hexToNumber(value);
};
var toDecimal = hexToNumber2;
var numberToHex2 = (value, hexstrict) => {
  if (typeof value !== "bigint")
    validator2.validate(["int"], [value]);
  let updatedValue = exports_utils.numberToHex(value);
  if (hexstrict) {
    if (!updatedValue.startsWith("-") && updatedValue.length % 2 === 1) {
      updatedValue = "0x0".concat(updatedValue.slice(2));
    } else if (updatedValue.length % 2 === 0 && updatedValue.startsWith("-"))
      updatedValue = "-0x0".concat(updatedValue.slice(3));
  }
  return updatedValue;
};
var fromDecimal = numberToHex2;
var hexToNumberString = (data) => hexToNumber2(data).toString();
var utf8ToHex = (str) => {
  validator2.validate(["string"], [str]);
  let strWithoutNullCharacter = str.replace(/^(?:\u0000)/, "");
  strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\u0000)$/, "");
  return bytesToHex2(new TextEncoder().encode(strWithoutNullCharacter));
};
var fromUtf8 = utf8ToHex;
var stringToHex = utf8ToHex;
var hexToUtf8 = (str) => bytesToUtf8(hexToBytes(str));
var toUtf8 = (input) => {
  if (typeof input === "string") {
    return hexToUtf8(input);
  }
  validator2.validate(["bytes"], [input]);
  return bytesToUtf8(input);
};
var utf8ToBytes2 = utf8ToBytes;
var hexToString = hexToUtf8;
var asciiToHex = (str) => {
  validator2.validate(["string"], [str]);
  let hexString = "";
  for (let i = 0;i < str.length; i += 1) {
    const hexCharCode = str.charCodeAt(i).toString(16);
    hexString += hexCharCode.length % 2 !== 0 ? `0${hexCharCode}` : hexCharCode;
  }
  return `0x${hexString}`;
};
var fromAscii = asciiToHex;
var hexToAscii = (str) => {
  const decoder = new TextDecoder("ascii");
  return decoder.decode(hexToBytes(str));
};
var toAscii = hexToAscii;
var toHex = (value, returnType) => {
  if (typeof value === "string" && isAddress(value)) {
    return returnType ? "address" : `0x${value.toLowerCase().replace(/^0x/i, "")}`;
  }
  if (typeof value === "boolean") {
    return returnType ? "bool" : value ? "0x01" : "0x00";
  }
  if (typeof value === "number") {
    return returnType ? value < 0 ? "int256" : "uint256" : numberToHex2(value);
  }
  if (typeof value === "bigint") {
    return returnType ? "bigint" : numberToHex2(value);
  }
  if (typeof value === "object" && !!value) {
    return returnType ? "string" : utf8ToHex(JSON.stringify(value));
  }
  if (typeof value === "string") {
    if (value.startsWith("-0x") || value.startsWith("-0X")) {
      return returnType ? "int256" : numberToHex2(value);
    }
    if (isHexStrict(value)) {
      return returnType ? "bytes" : value;
    }
    if (isHex(value) && !isInt(value) && !isUInt(value)) {
      return returnType ? "bytes" : `0x${value}`;
    }
    if (isHex(value) && !isInt(value) && isUInt(value)) {
      return returnType ? "uint" : numberToHex2(value);
    }
    if (!Number.isFinite(value)) {
      return returnType ? "string" : utf8ToHex(value);
    }
  }
  throw new HexProcessingError(value);
};
var toNumber = (value) => {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "bigint") {
    return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value;
  }
  if (typeof value === "string" && isHexStrict(value)) {
    return hexToNumber2(value);
  }
  try {
    return toNumber(BigInt(value));
  } catch (_a) {
    throw new InvalidNumberError(value);
  }
};
var toBigInt = (value) => {
  if (typeof value === "number") {
    return BigInt(value);
  }
  if (typeof value === "bigint") {
    return value;
  }
  if (typeof value === "string" && isHex(value)) {
    if (value.startsWith("-")) {
      return -BigInt(value.substring(1));
    }
    return BigInt(value);
  }
  throw new InvalidNumberError(value);
};
var fromWei = (number2, unit) => {
  const denomination = ethUnitMap[unit];
  if (!denomination) {
    throw new InvalidUnitError(unit);
  }
  const value = String(toNumber(number2));
  const numberOfZerosInDenomination = denomination.toString().length - 1;
  if (numberOfZerosInDenomination <= 0) {
    return value.toString();
  }
  const zeroPaddedValue = value.padStart(numberOfZerosInDenomination, "0");
  const integer = zeroPaddedValue.slice(0, -numberOfZerosInDenomination);
  const fraction = zeroPaddedValue.slice(-numberOfZerosInDenomination).replace(/\.?0+$/, "");
  if (integer === "") {
    return `0.${fraction}`;
  }
  if (fraction === "") {
    return integer;
  }
  return `${integer}.${fraction}`;
};
var toWei = (number2, unit) => {
  validator2.validate(["number"], [number2]);
  const denomination = ethUnitMap[unit];
  if (!denomination) {
    throw new InvalidUnitError(unit);
  }
  const [integer, fraction] = String(typeof number2 === "string" && !isHexStrict(number2) ? number2 : toNumber(number2)).split(".").concat("");
  const value = BigInt(`${integer}${fraction}`);
  const updatedValue = value * denomination;
  const numberOfZerosInDenomination = denomination.toString().length - 1;
  const decimals = Math.min(fraction.length, numberOfZerosInDenomination);
  if (decimals === 0) {
    return updatedValue.toString();
  }
  return updatedValue.toString().padStart(decimals, "0").slice(0, -decimals);
};
var toChecksumAddress = (address5) => {
  if (!isAddress(address5, false)) {
    throw new InvalidAddressError(address5);
  }
  const lowerCaseAddress = address5.toLowerCase().replace(/^0x/i, "");
  const hash2 = exports_utils.uint8ArrayToHexString(keccak256(exports_utils.ensureIfUint8Array(utf8ToBytes2(lowerCaseAddress))));
  if (isNullish(hash2) || hash2 === "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470")
    return "";
  let checksumAddress = "0x";
  const addressHash = hash2.replace(/^0x/i, "");
  for (let i = 0;i < lowerCaseAddress.length; i += 1) {
    if (parseInt(addressHash[i], 16) > 7) {
      checksumAddress += lowerCaseAddress[i].toUpperCase();
    } else {
      checksumAddress += lowerCaseAddress[i];
    }
  }
  return checksumAddress;
};
var toBool = (value) => {
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "number" && (value === 0 || value === 1)) {
    return Boolean(value);
  }
  if (typeof value === "bigint" && (value === BigInt(0) || value === BigInt(1))) {
    return Boolean(value);
  }
  if (typeof value === "string" && !isHexStrict(value) && (value === "1" || value === "0" || value === "false" || value === "true")) {
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    return Boolean(Number(value));
  }
  if (typeof value === "string" && isHexStrict(value) && (value === "0x1" || value === "0x0")) {
    return Boolean(toNumber(value));
  }
  throw new InvalidBooleanError(value);
};
// node_modules/web3-utils/node_modules/eventemitter3/index.mjs
var import_ = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_.default;

// node_modules/web3-utils/lib/esm/event_emitter.js
class EventEmitter2 extends eventemitter3_default {
  constructor() {
    super(...arguments);
    this.maxListeners = Number.MAX_SAFE_INTEGER;
  }
  setMaxListeners(maxListeners) {
    this.maxListeners = maxListeners;
    return this;
  }
  getMaxListeners() {
    return this.maxListeners;
  }
}
// node_modules/web3-utils/lib/esm/validation.js
var isHexStrict2 = isHexStrict;
var isHex2 = isHex;
var checkAddressCheckSum2 = checkAddressCheckSum;
var isAddress2 = isAddress;
var isBloom2 = isBloom;
var isInBloom2 = isInBloom;
var isUserEthereumAddressInBloom2 = isUserEthereumAddressInBloom;
var isContractAddressInBloom2 = isContractAddressInBloom;
var isTopic2 = isTopic;
var isTopicInBloom2 = isTopicInBloom;
var compareBlockNumbers = (blockA, blockB) => {
  const isABlockTag = typeof blockA === "string" && isBlockTag(blockA);
  const isBBlockTag = typeof blockB === "string" && isBlockTag(blockB);
  if (blockA === blockB || (blockA === "earliest" || blockA === 0) && (blockB === "earliest" || blockB === 0)) {
    return 0;
  }
  if (blockA === "earliest" && blockB > 0) {
    return -1;
  }
  if (blockB === "earliest" && blockA > 0) {
    return 1;
  }
  if (isABlockTag && isBBlockTag) {
    const tagsOrder = {
      [BlockTags.EARLIEST]: 1,
      [BlockTags.FINALIZED]: 2,
      [BlockTags.SAFE]: 3,
      [BlockTags.LATEST]: 4,
      [BlockTags.PENDING]: 5
    };
    if (tagsOrder[blockA] < tagsOrder[blockB]) {
      return -1;
    }
    return 1;
  }
  if (isABlockTag && !isBBlockTag || !isABlockTag && isBBlockTag) {
    throw new InvalidBlockError("Cannot compare blocktag with provided non-blocktag input.");
  }
  const bigIntA = BigInt(blockA);
  const bigIntB = BigInt(blockB);
  if (bigIntA < bigIntB) {
    return -1;
  }
  if (bigIntA === bigIntB) {
    return 0;
  }
  return 1;
};
var isContractInitOptions = (options) => typeof options === "object" && !isNullish(options) && Object.keys(options).length !== 0 && [
  "input",
  "data",
  "from",
  "gas",
  "gasPrice",
  "gasLimit",
  "address",
  "jsonInterface",
  "syncWithContext",
  "dataInputFill"
].some((key) => (key in options));
var isNullish2 = isNullish;
// node_modules/web3-utils/lib/esm/objects.js
var isIterable = (item) => typeof item === "object" && !isNullish(item) && !Array.isArray(item) && !(item instanceof TypedArray);
var mergeDeep = (destination, ...sources) => {
  if (!isIterable(destination)) {
    return destination;
  }
  const result = Object.assign({}, destination);
  for (const src of sources) {
    for (const key in src) {
      if (isIterable(src[key])) {
        if (!result[key]) {
          result[key] = {};
        }
        result[key] = mergeDeep(result[key], src[key]);
      } else if (!isNullish(src[key]) && Object.hasOwnProperty.call(src, key)) {
        if (Array.isArray(src[key]) || src[key] instanceof TypedArray) {
          result[key] = src[key].slice(0);
        } else {
          result[key] = src[key];
        }
      }
    }
  }
  return result;
};

// node_modules/web3-utils/lib/esm/string_manipulation.js
var padLeft2 = (value, characterAmount, sign = "0") => {
  if (typeof value === "string") {
    if (!isHexStrict(value)) {
      return value.padStart(characterAmount, sign);
    }
    return exports_utils.padLeft(value, characterAmount, sign);
  }
  validator2.validate(["int"], [value]);
  return exports_utils.padLeft(value, characterAmount, sign);
};
var padRight = (value, characterAmount, sign = "0") => {
  if (typeof value === "string" && !isHexStrict(value)) {
    return value.padEnd(characterAmount, sign);
  }
  validator2.validate(["int"], [value]);
  const hexString = typeof value === "string" && isHexStrict(value) ? value : numberToHex2(value);
  const prefixLength = hexString.startsWith("-") ? 3 : 2;
  return hexString.padEnd(characterAmount + prefixLength, sign);
};
var rightPad = padRight;
var leftPad = padLeft2;
var toTwosComplement = (value, nibbleWidth = 64) => {
  validator2.validate(["int"], [value]);
  const val = toNumber(value);
  if (val >= 0)
    return padLeft2(toHex(val), nibbleWidth);
  const largestBit = bigintPower(BigInt(2), BigInt(nibbleWidth * 4));
  if (-val >= largestBit) {
    throw new NibbleWidthError(`value: ${value}, nibbleWidth: ${nibbleWidth}`);
  }
  const updatedVal = BigInt(val);
  const complement = updatedVal + largestBit;
  return padLeft2(numberToHex2(complement), nibbleWidth);
};
var fromTwosComplement = (value, nibbleWidth = 64) => {
  validator2.validate(["int"], [value]);
  const val = toNumber(value);
  if (val < 0)
    return val;
  const largestBit = Math.ceil(Math.log(Number(val)) / Math.log(2));
  if (largestBit > nibbleWidth * 4)
    throw new NibbleWidthError(`value: "${value}", nibbleWidth: "${nibbleWidth}"`);
  if (nibbleWidth * 4 !== largestBit)
    return val;
  const complement = bigintPower(BigInt(2), BigInt(nibbleWidth) * BigInt(4));
  return toNumber(BigInt(val) - complement);
};

// node_modules/web3-utils/lib/esm/formatter.js
var { parseBaseType: parseBaseType2 } = exports_utils;
var isDataFormat = (dataFormat) => typeof dataFormat === "object" && !isNullish(dataFormat) && ("number" in dataFormat) && ("bytes" in dataFormat);
var findSchemaByDataPath = (schema, dataPath, oneOfPath = []) => {
  let result = Object.assign({}, schema);
  let previousDataPath;
  for (const dataPart of dataPath) {
    if (result.oneOf && previousDataPath) {
      const path = oneOfPath.find(function(element) {
        return this === element[0];
      }, previousDataPath !== null && previousDataPath !== undefined ? previousDataPath : "");
      if (path && path[0] === previousDataPath) {
        result = result.oneOf[path[1]];
      }
    }
    if (!result.properties && !result.items) {
      return;
    }
    if (result.properties) {
      result = result.properties[dataPart];
    } else if (result.items && result.items.properties) {
      const node = result.items.properties;
      if (!node) {
        return;
      }
      result = node[dataPart];
    } else if (result.items && isObject(result.items)) {
      result = result.items;
    } else if (result.items && Array.isArray(result.items)) {
      result = result.items[parseInt(dataPart, 10)];
    }
    if (result && dataPart)
      previousDataPath = dataPart;
  }
  return result;
};
var convertScalarValue = (value, ethType, format) => {
  try {
    const { baseType, baseTypeSize } = parseBaseType2(ethType);
    if (baseType === "int" || baseType === "uint") {
      switch (format.number) {
        case FMT_NUMBER.NUMBER:
          return Number(toBigInt(value));
        case FMT_NUMBER.HEX:
          return numberToHex2(toBigInt(value));
        case FMT_NUMBER.STR:
          return toBigInt(value).toString();
        case FMT_NUMBER.BIGINT:
          return toBigInt(value);
        default:
          throw new FormatterError(`Invalid format: ${String(format.number)}`);
      }
    }
    if (baseType === "bytes") {
      let paddedValue;
      if (baseTypeSize) {
        if (typeof value === "string")
          paddedValue = padLeft2(value, baseTypeSize * 2);
        else if (isUint8Array2(value)) {
          paddedValue = uint8ArrayConcat(new Uint8Array(baseTypeSize - value.length), value);
        }
      } else {
        paddedValue = value;
      }
      switch (format.bytes) {
        case FMT_BYTES.HEX:
          return bytesToHex2(bytesToUint8Array(paddedValue));
        case FMT_BYTES.UINT8ARRAY:
          return bytesToUint8Array(paddedValue);
        default:
          throw new FormatterError(`Invalid format: ${String(format.bytes)}`);
      }
    }
  } catch (error) {
    return value;
  }
  return value;
};
var convert = (data, schema, dataPath, format, oneOfPath = []) => {
  var _a, _b;
  if (!isObject(data) && !Array.isArray(data)) {
    return convertScalarValue(data, schema === null || schema === undefined ? undefined : schema.format, format);
  }
  const object3 = data;
  for (const [key, value] of Object.entries(object3)) {
    dataPath.push(key);
    const schemaProp = findSchemaByDataPath(schema, dataPath, oneOfPath);
    if (isNullish(schemaProp)) {
      delete object3[key];
      dataPath.pop();
      continue;
    }
    if (isObject(value)) {
      convert(value, schema, dataPath, format);
      dataPath.pop();
      continue;
    }
    if (Array.isArray(value)) {
      let _schemaProp = schemaProp;
      if ((schemaProp === null || schemaProp === undefined ? undefined : schemaProp.oneOf) !== undefined) {
        schemaProp.oneOf.forEach((oneOfSchemaProp, index) => {
          var _a2, _b2;
          if (!Array.isArray(schemaProp === null || schemaProp === undefined ? undefined : schemaProp.items) && (typeof value[0] === "object" && ((_a2 = oneOfSchemaProp === null || oneOfSchemaProp === undefined ? undefined : oneOfSchemaProp.items) === null || _a2 === undefined ? undefined : _a2.type) === "object" || typeof value[0] === "string" && ((_b2 = oneOfSchemaProp === null || oneOfSchemaProp === undefined ? undefined : oneOfSchemaProp.items) === null || _b2 === undefined ? undefined : _b2.type) !== "object")) {
            _schemaProp = oneOfSchemaProp;
            oneOfPath.push([key, index]);
          }
        });
      }
      if (isNullish(_schemaProp === null || _schemaProp === undefined ? undefined : _schemaProp.items)) {
        delete object3[key];
        dataPath.pop();
        continue;
      }
      if (isObject(_schemaProp.items) && !isNullish(_schemaProp.items.format)) {
        for (let i = 0;i < value.length; i += 1) {
          object3[key][i] = convertScalarValue(value[i], (_a = _schemaProp === null || _schemaProp === undefined ? undefined : _schemaProp.items) === null || _a === undefined ? undefined : _a.format, format);
        }
        dataPath.pop();
        continue;
      }
      if (!Array.isArray(_schemaProp === null || _schemaProp === undefined ? undefined : _schemaProp.items) && ((_b = _schemaProp === null || _schemaProp === undefined ? undefined : _schemaProp.items) === null || _b === undefined ? undefined : _b.type) === "object") {
        for (const arrObject of value) {
          convert(arrObject, schema, dataPath, format, oneOfPath);
        }
        dataPath.pop();
        continue;
      }
      if (Array.isArray(_schemaProp === null || _schemaProp === undefined ? undefined : _schemaProp.items)) {
        for (let i = 0;i < value.length; i += 1) {
          object3[key][i] = convertScalarValue(value[i], _schemaProp.items[i].format, format);
        }
        dataPath.pop();
        continue;
      }
    }
    object3[key] = convertScalarValue(value, schemaProp.format, format);
    dataPath.pop();
  }
  return object3;
};
var format = (schema, data, returnFormat) => {
  let dataToParse;
  if (isObject(data)) {
    dataToParse = mergeDeep({}, data);
  } else if (Array.isArray(data)) {
    dataToParse = [...data];
  } else {
    dataToParse = data;
  }
  const jsonSchema = isObject(schema) ? schema : exports_utils.ethAbiToJsonSchema(schema);
  if (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {
    throw new FormatterError("Invalid json schema for formatting");
  }
  return convert(dataToParse, jsonSchema, [], returnFormat);
};
// node_modules/web3-utils/lib/esm/hash.js
var SHA3_EMPTY_BYTES = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
var sha32 = (data) => {
  let updatedData;
  if (typeof data === "string") {
    if (data.startsWith("0x") && isHexStrict(data)) {
      updatedData = hexToBytes(data);
    } else {
      updatedData = utf8ToBytes(data);
    }
  } else {
    updatedData = data;
  }
  const hash2 = bytesToHex2(keccak256(exports_utils.ensureIfUint8Array(updatedData)));
  return hash2 === SHA3_EMPTY_BYTES ? undefined : hash2;
};
var sha3Raw = (data) => {
  const hash2 = sha32(data);
  if (isNullish(hash2)) {
    return SHA3_EMPTY_BYTES;
  }
  return hash2;
};
var keccak256Wrapper = (data) => {
  let processedData;
  if (typeof data === "bigint" || typeof data === "number") {
    processedData = utf8ToBytes(data.toString());
  } else if (Array.isArray(data)) {
    processedData = new Uint8Array(data);
  } else if (typeof data === "string" && !isHexStrict(data)) {
    processedData = utf8ToBytes(data);
  } else {
    processedData = bytesToUint8Array(data);
  }
  return bytesToHex2(keccak256(exports_utils.ensureIfUint8Array(processedData)));
};
var getType = (arg) => {
  if (Array.isArray(arg)) {
    throw new Error("Autodetection of array types is not supported.");
  }
  let type;
  let value;
  if (typeof arg === "object" && (("t" in arg) || ("type" in arg)) && (("v" in arg) || ("value" in arg))) {
    type = "t" in arg ? arg.t : arg.type;
    value = "v" in arg ? arg.v : arg.value;
    type = type.toLowerCase() === "bigint" ? "int" : type;
  } else if (typeof arg === "bigint") {
    return ["int", arg];
  } else {
    type = toHex(arg, true);
    value = toHex(arg);
    if (!type.startsWith("int") && !type.startsWith("uint")) {
      type = "bytes";
    }
  }
  if ((type.startsWith("int") || type.startsWith("uint")) && typeof value === "string" && !/^(-)?0x/i.test(value)) {
    value = toBigInt(value);
  }
  return [type, value];
};
var elementaryName = (name) => {
  if (name.startsWith("int[")) {
    return `int256${name.slice(3)}`;
  }
  if (name === "int") {
    return "int256";
  }
  if (name.startsWith("uint[")) {
    return `uint256'${name.slice(4)}`;
  }
  if (name === "uint") {
    return "uint256";
  }
  return name;
};
var parseTypeN = (value, typeLength) => {
  const typesize = /^(\d+).*$/.exec(value.slice(typeLength));
  return typesize ? parseInt(typesize[1], 10) : 0;
};
var bitLength = (value) => {
  const updatedVal = value.toString(2);
  return updatedVal.length;
};
var solidityPack = (type, val) => {
  const value = val.toString();
  if (type === "string") {
    if (typeof val === "string")
      return utf8ToHex(val);
    throw new InvalidStringError(val);
  }
  if (type === "bool" || type === "boolean") {
    if (typeof val === "boolean")
      return val ? "01" : "00";
    throw new InvalidBooleanError(val);
  }
  if (type === "address") {
    if (!isAddress(value)) {
      throw new InvalidAddressError(value);
    }
    return value;
  }
  const name = elementaryName(type);
  if (type.startsWith("uint")) {
    const size = parseTypeN(name, "uint".length);
    if (size % 8 || size < 8 || size > 256) {
      throw new InvalidSizeError(value);
    }
    const num = toNumber(value);
    if (bitLength(num) > size) {
      throw new InvalidLargeValueError(value);
    }
    if (num < BigInt(0)) {
      throw new InvalidUnsignedIntegerError(value);
    }
    return size ? leftPad(num.toString(16), size / 8 * 2) : num.toString(16);
  }
  if (type.startsWith("int")) {
    const size = parseTypeN(name, "int".length);
    if (size % 8 || size < 8 || size > 256) {
      throw new InvalidSizeError(type);
    }
    const num = toNumber(value);
    if (bitLength(num) > size) {
      throw new InvalidLargeValueError(value);
    }
    if (num < BigInt(0)) {
      return toTwosComplement(num.toString(), size / 8 * 2);
    }
    return size ? leftPad(num.toString(16), size / 4) : num.toString(16);
  }
  if (name === "bytes") {
    if (value.replace(/^0x/i, "").length % 2 !== 0) {
      throw new InvalidBytesError(value);
    }
    return value;
  }
  if (type.startsWith("bytes")) {
    if (value.replace(/^0x/i, "").length % 2 !== 0) {
      throw new InvalidBytesError(value);
    }
    const size = parseTypeN(type, "bytes".length);
    if (!size || size < 1 || size > 64 || size < value.replace(/^0x/i, "").length / 2) {
      throw new InvalidBytesError(value);
    }
    return rightPad(value, size * 2);
  }
  return "";
};
var processSolidityEncodePackedArgs = (arg) => {
  const [type, val] = getType(arg);
  if (Array.isArray(val)) {
    const hexArg2 = val.map((v) => solidityPack(type, v).replace("0x", ""));
    return hexArg2.join("");
  }
  const hexArg = solidityPack(type, val);
  return hexArg.replace("0x", "");
};
var encodePacked = (...values) => {
  const hexArgs = values.map(processSolidityEncodePackedArgs);
  return `0x${hexArgs.join("").toLowerCase()}`;
};
var soliditySha3 = (...values) => sha32(encodePacked(...values));
var soliditySha3Raw = (...values) => sha3Raw(encodePacked(...values));
var getStorageSlotNumForLongString = (mainSlotNumber) => sha32(`0x${(typeof mainSlotNumber === "number" ? mainSlotNumber.toString() : mainSlotNumber).padStart(64, "0")}`);
// node_modules/ethereum-cryptography/esm/random.js
function getRandomBytesSync(bytes5) {
  return randomBytes(bytes5);
}

// node_modules/web3-utils/lib/esm/random.js
var randomBytes2 = (size) => getRandomBytesSync(size);
var randomHex = (byteSize) => bytesToHex2(randomBytes2(byteSize));
// node_modules/web3-utils/lib/esm/promise_helpers.js
function isPromise(object3) {
  return (typeof object3 === "object" || typeof object3 === "function") && typeof object3.then === "function";
}
function waitWithTimeout(awaitable, timeout, error) {
  return __awaiter2(this, undefined, undefined, function* () {
    let timeoutId;
    const result = yield Promise.race([
      awaitable instanceof Promise ? awaitable : awaitable(),
      new Promise((resolve, reject) => {
        timeoutId = setTimeout(() => error ? reject(error) : resolve(undefined), timeout);
      })
    ]);
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    if (result instanceof Error) {
      throw result;
    }
    return result;
  });
}
function pollTillDefinedAndReturnIntervalId(func, interval) {
  let intervalId;
  const polledRes = new Promise((resolve, reject) => {
    intervalId = setInterval(function intervalCallbackFunc() {
      (() => __awaiter2(this, undefined, undefined, function* () {
        try {
          const res = yield waitWithTimeout(func, interval);
          if (!isNullish(res)) {
            clearInterval(intervalId);
            resolve(res);
          }
        } catch (error) {
          clearInterval(intervalId);
          reject(error);
        }
      }))();
      return intervalCallbackFunc;
    }(), interval);
  });
  return [polledRes, intervalId];
}
function pollTillDefined(func, interval) {
  return __awaiter2(this, undefined, undefined, function* () {
    return pollTillDefinedAndReturnIntervalId(func, interval)[0];
  });
}
function rejectIfTimeout(timeout, error) {
  let timeoutId;
  const rejectOnTimeout = new Promise((_, reject) => {
    timeoutId = setTimeout(() => {
      reject(error);
    }, timeout);
  });
  return [timeoutId, rejectOnTimeout];
}
function rejectIfConditionAtInterval(cond, interval) {
  let intervalId;
  const rejectIfCondition = new Promise((_, reject) => {
    intervalId = setInterval(() => {
      (() => __awaiter2(this, undefined, undefined, function* () {
        const error = yield cond();
        if (error) {
          clearInterval(intervalId);
          reject(error);
        }
      }))();
    }, interval);
  });
  return [intervalId, rejectIfCondition];
}
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
// node_modules/web3-utils/lib/esm/json_rpc.js
var exports_json_rpc = {};
__export(exports_json_rpc, {
  validateResponse: () => {
    {
      return validateResponse;
    }
  },
  toPayload: () => {
    {
      return toPayload;
    }
  },
  toBatchPayload: () => {
    {
      return toBatchPayload;
    }
  },
  setRequestIdStart: () => {
    {
      return setRequestIdStart;
    }
  },
  isValidResponse: () => {
    {
      return isValidResponse;
    }
  },
  isSubscriptionResult: () => {
    {
      return isSubscriptionResult;
    }
  },
  isResponseWithResult: () => {
    {
      return isResponseWithResult;
    }
  },
  isResponseWithNotification: () => {
    {
      return isResponseWithNotification;
    }
  },
  isResponseWithError: () => {
    {
      return isResponseWithError2;
    }
  },
  isResponseRpcError: () => {
    {
      return isResponseRpcError;
    }
  },
  isBatchResponse: () => {
    {
      return isBatchResponse;
    }
  },
  isBatchRequest: () => {
    {
      return isBatchRequest;
    }
  }
});

// node_modules/web3-utils/lib/esm/uuid.js
var uuidV4 = () => {
  const bytes5 = randomBytes2(16);
  bytes5[6] = bytes5[6] & 15 | 64;
  bytes5[8] = bytes5[8] & 63 | 128;
  const hexString = bytesToHex2(bytes5);
  return [
    hexString.substring(2, 10),
    hexString.substring(10, 14),
    hexString.substring(14, 18),
    hexString.substring(18, 22),
    hexString.substring(22, 34)
  ].join("-");
};

// node_modules/web3-utils/lib/esm/json_rpc.js
var isResponseRpcError = (rpcError) => {
  const errorCode = rpcError.error.code;
  return rpcErrorsMap.has(errorCode) || errorCode >= -32099 && errorCode <= -32000;
};
var isResponseWithResult = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && ("result" in response) && isNullish(response.error) && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithError2 = (response) => !Array.isArray(response) && response.jsonrpc === "2.0" && !!response && isNullish(response.result) && ("error" in response) && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithNotification = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && !isNullish(response.params) && !isNullish(response.method);
var isSubscriptionResult = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && ("id" in response) && ("result" in response);
var validateResponse = (response) => isResponseWithResult(response) || isResponseWithError2(response);
var isValidResponse = (response) => Array.isArray(response) ? response.every(validateResponse) : validateResponse(response);
var isBatchResponse = (response) => Array.isArray(response) && response.length > 0 && isValidResponse(response);
var requestIdSeed;
var setRequestIdStart = (start) => {
  requestIdSeed = start;
};
var toPayload = (request) => {
  var _a, _b, _c, _d;
  if (typeof requestIdSeed !== "undefined") {
    requestIdSeed += 1;
  }
  return {
    jsonrpc: (_a = request.jsonrpc) !== null && _a !== undefined ? _a : "2.0",
    id: (_c = (_b = request.id) !== null && _b !== undefined ? _b : requestIdSeed) !== null && _c !== undefined ? _c : uuidV4(),
    method: request.method,
    params: (_d = request.params) !== null && _d !== undefined ? _d : undefined
  };
};
var toBatchPayload = (requests) => requests.map((request) => toPayload(request));
var isBatchRequest = (request) => Array.isArray(request) && request.length > 0;
// node_modules/web3-utils/lib/esm/web3_deferred_promise.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a;

class Web3DeferredPromise {
  constructor({ timeout, eagerStart, timeoutMessage } = {
    timeout: 0,
    eagerStart: false,
    timeoutMessage: "DeferredPromise timed out"
  }) {
    this[_a] = "Promise";
    this._state = "pending";
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this._timeoutMessage = timeoutMessage;
    this._timeoutInterval = timeout;
    if (eagerStart) {
      this.startTimer();
    }
  }
  get state() {
    return this._state;
  }
  then(onfulfilled, onrejected) {
    return __awaiter3(this, undefined, undefined, function* () {
      return this._promise.then(onfulfilled, onrejected);
    });
  }
  catch(onrejected) {
    return __awaiter3(this, undefined, undefined, function* () {
      return this._promise.catch(onrejected);
    });
  }
  finally(onfinally) {
    return __awaiter3(this, undefined, undefined, function* () {
      return this._promise.finally(onfinally);
    });
  }
  resolve(value) {
    this._resolve(value);
    this._state = "fulfilled";
    this._clearTimeout();
  }
  reject(reason) {
    this._reject(reason);
    this._state = "rejected";
    this._clearTimeout();
  }
  startTimer() {
    if (this._timeoutInterval && this._timeoutInterval > 0) {
      this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval);
    }
  }
  _checkTimeout() {
    if (this._state === "pending" && this._timeoutId) {
      this.reject(new OperationTimeoutError(this._timeoutMessage));
    }
  }
  _clearTimeout() {
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
    }
  }
}
_a = Symbol.toStringTag;
// node_modules/web3-utils/lib/esm/chunk_response_parser.js
class ChunkResponseParser {
  constructor(eventEmitter, autoReconnect) {
    this.eventEmitter = eventEmitter;
    this.autoReconnect = autoReconnect;
    this.chunkTimout = 1000 * 15;
  }
  clearQueues() {
    if (typeof this._clearQueues === "function") {
      this._clearQueues();
    }
  }
  onError(clearQueues) {
    this._clearQueues = clearQueues;
  }
  parseResponse(data) {
    const returnValues = [];
    const dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
    dechunkedData.forEach((_chunkData) => {
      let chunkData = _chunkData;
      if (this.lastChunk) {
        chunkData = this.lastChunk + chunkData;
      }
      let result;
      try {
        result = JSON.parse(chunkData);
      } catch (e) {
        this.lastChunk = chunkData;
        if (this.lastChunkTimeout) {
          clearTimeout(this.lastChunkTimeout);
        }
        this.lastChunkTimeout = setTimeout(() => {
          if (this.autoReconnect)
            return;
          this.clearQueues();
          this.eventEmitter.emit("error", new InvalidResponseError({
            id: 1,
            jsonrpc: "2.0",
            error: { code: 2, message: "Chunk timeout" }
          }));
        }, this.chunkTimout);
        return;
      }
      clearTimeout(this.lastChunkTimeout);
      this.lastChunk = undefined;
      if (result)
        returnValues.push(result);
    });
    return returnValues;
  }
}
// node_modules/web3-utils/lib/esm/web3_eip1193_provider.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Eip1193Provider extends Web3BaseProvider {
  constructor() {
    super(...arguments);
    this._eventEmitter = new import_.default;
    this._chainId = "";
    this._accounts = [];
  }
  _getChainId() {
    var _a2;
    return __awaiter4(this, undefined, undefined, function* () {
      const data = yield this.request(toPayload({
        method: "eth_chainId",
        params: []
      }));
      return (_a2 = data === null || data === undefined ? undefined : data.result) !== null && _a2 !== undefined ? _a2 : "";
    });
  }
  _getAccounts() {
    var _a2;
    return __awaiter4(this, undefined, undefined, function* () {
      const data = yield this.request(toPayload({
        method: "eth_accounts",
        params: []
      }));
      return (_a2 = data === null || data === undefined ? undefined : data.result) !== null && _a2 !== undefined ? _a2 : [];
    });
  }
  _onConnect() {
    Promise.all([
      this._getChainId().then((chainId) => {
        if (chainId !== this._chainId) {
          this._chainId = chainId;
          this._eventEmitter.emit("chainChanged", this._chainId);
        }
      }).catch((err) => {
        console.error(err);
      }),
      this._getAccounts().then((accounts) => {
        if (!(this._accounts.length === accounts.length && accounts.every((v) => accounts.includes(v)))) {
          this._accounts = accounts;
          this._onAccountsChanged();
        }
      }).catch((err) => {
        console.error(err);
      })
    ]).then(() => this._eventEmitter.emit("connect", {
      chainId: this._chainId
    })).catch((err) => {
      console.error(err);
    });
  }
  _onDisconnect(code, data) {
    this._eventEmitter.emit("disconnect", new EIP1193ProviderRpcError(code, data));
  }
  _onAccountsChanged() {
    this._eventEmitter.emit("accountsChanged", this._accounts);
  }
}
// node_modules/web3-utils/lib/esm/socket_provider.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_RECONNECTION_OPTIONS = {
  autoReconnect: true,
  delay: 5000,
  maxAttempts: 5
};
var NORMAL_CLOSE_CODE = 1000;

class SocketProvider extends Eip1193Provider {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super();
    this._connectionStatus = "connecting";
    this._onMessageHandler = this._onMessage.bind(this);
    this._onOpenHandler = this._onConnect.bind(this);
    this._onCloseHandler = this._onCloseEvent.bind(this);
    this._onErrorHandler = this._onError.bind(this);
    if (!this._validateProviderPath(socketPath))
      throw new InvalidClientError(socketPath);
    this._socketPath = socketPath;
    this._socketOptions = socketOptions;
    this._reconnectOptions = Object.assign(Object.assign({}, DEFAULT_RECONNECTION_OPTIONS), reconnectOptions !== null && reconnectOptions !== undefined ? reconnectOptions : {});
    this._pendingRequestsQueue = new Map;
    this._sentRequestsQueue = new Map;
    this._init();
    this.connect();
    this.chunkResponseParser = new ChunkResponseParser(this._eventEmitter, this._reconnectOptions.autoReconnect);
    this.chunkResponseParser.onError(() => {
      this._clearQueues();
    });
    this.isReconnecting = false;
  }
  get SocketConnection() {
    return this._socketConnection;
  }
  _init() {
    this._reconnectAttempts = 0;
  }
  connect() {
    try {
      this._openSocketConnection();
      this._connectionStatus = "connecting";
      this._addSocketListeners();
    } catch (e) {
      if (!this.isReconnecting) {
        this._connectionStatus = "disconnected";
        if (e && e.message) {
          throw new ConnectionError(`Error while connecting to ${this._socketPath}. Reason: ${e.message}`);
        } else {
          throw new InvalidClientError(this._socketPath);
        }
      } else {
        setImmediate(() => {
          this._reconnect();
        });
      }
    }
  }
  _validateProviderPath(path) {
    return !!path;
  }
  getPendingRequestQueueSize() {
    return this._pendingRequestsQueue.size;
  }
  getSentRequestsQueueSize() {
    return this._sentRequestsQueue.size;
  }
  supportsSubscriptions() {
    return true;
  }
  on(type, listener) {
    this._eventEmitter.on(type, listener);
  }
  once(type, listener) {
    this._eventEmitter.once(type, listener);
  }
  removeListener(type, listener) {
    this._eventEmitter.removeListener(type, listener);
  }
  _onDisconnect(code, data) {
    this._connectionStatus = "disconnected";
    super._onDisconnect(code, data);
  }
  disconnect(code, data) {
    const disconnectCode = code !== null && code !== undefined ? code : NORMAL_CLOSE_CODE;
    this._removeSocketListeners();
    if (this.getStatus() !== "disconnected") {
      this._closeSocketConnection(disconnectCode, data);
    }
    this._onDisconnect(disconnectCode, data);
  }
  safeDisconnect(code, data, forceDisconnect = false, ms = 1000) {
    return __awaiter5(this, undefined, undefined, function* () {
      let retryAttempt = 0;
      const checkQueue = () => __awaiter5(this, undefined, undefined, function* () {
        return new Promise((resolve) => {
          const interval = setInterval(() => {
            if (forceDisconnect && retryAttempt === 5) {
              this.clearQueues();
            }
            if (this.getPendingRequestQueueSize() === 0 && this.getSentRequestsQueueSize() === 0) {
              clearInterval(interval);
              resolve(true);
            }
            retryAttempt += 1;
          }, ms);
        });
      });
      yield checkQueue();
      this.disconnect(code, data);
    });
  }
  removeAllListeners(type) {
    this._eventEmitter.removeAllListeners(type);
  }
  _onError(event) {
    if (this.isReconnecting) {
      this._reconnect();
    } else {
      this._eventEmitter.emit("error", event);
    }
  }
  reset() {
    this._sentRequestsQueue.clear();
    this._pendingRequestsQueue.clear();
    this._init();
    this._removeSocketListeners();
    this._addSocketListeners();
  }
  _reconnect() {
    if (this.isReconnecting) {
      return;
    }
    this.isReconnecting = true;
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new PendingRequestsOnReconnectingError);
        this._sentRequestsQueue.delete(key);
      });
    }
    if (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {
      this._reconnectAttempts += 1;
      setTimeout(() => {
        this._removeSocketListeners();
        this.connect();
        this.isReconnecting = false;
      }, this._reconnectOptions.delay);
    } else {
      this.isReconnecting = false;
      this._clearQueues();
      this._removeSocketListeners();
      this._eventEmitter.emit("error", new MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts));
    }
  }
  request(request) {
    return __awaiter5(this, undefined, undefined, function* () {
      if (isNullish2(this._socketConnection)) {
        throw new Error("Connection is undefined");
      }
      if (this.getStatus() === "disconnected") {
        this.connect();
      }
      const requestId = isBatchRequest(request) ? request[0].id : request.id;
      if (!requestId) {
        throw new Web3WSProviderError("Request Id not defined");
      }
      if (this._sentRequestsQueue.has(requestId)) {
        throw new RequestAlreadySentError(requestId);
      }
      const deferredPromise = new Web3DeferredPromise;
      deferredPromise.catch((error) => {
        this._eventEmitter.emit("error", error);
      });
      const reqItem = {
        payload: request,
        deferredPromise
      };
      if (this.getStatus() === "connecting") {
        this._pendingRequestsQueue.set(requestId, reqItem);
        return reqItem.deferredPromise;
      }
      this._sentRequestsQueue.set(requestId, reqItem);
      try {
        this._sendToSocket(reqItem.payload);
      } catch (error) {
        this._sentRequestsQueue.delete(requestId);
        this._eventEmitter.emit("error", error);
      }
      return deferredPromise;
    });
  }
  _onConnect() {
    this._connectionStatus = "connected";
    this._reconnectAttempts = 0;
    super._onConnect();
    this._sendPendingRequests();
  }
  _sendPendingRequests() {
    for (const [id, value] of this._pendingRequestsQueue.entries()) {
      this._sendToSocket(value.payload);
      this._pendingRequestsQueue.delete(id);
      this._sentRequestsQueue.set(id, value);
    }
  }
  _onMessage(event) {
    const responses = this._parseResponses(event);
    if (isNullish2(responses) || responses.length === 0) {
      return;
    }
    for (const response of responses) {
      if (isResponseWithNotification(response) && response.method.endsWith("_subscription")) {
        this._eventEmitter.emit("message", response);
        return;
      }
      const requestId = isBatchResponse(response) ? response[0].id : response.id;
      const requestItem = this._sentRequestsQueue.get(requestId);
      if (!requestItem) {
        return;
      }
      if (isBatchResponse(response) || isResponseWithResult(response) || isResponseWithError2(response)) {
        this._eventEmitter.emit("message", response);
        requestItem.deferredPromise.resolve(response);
      }
      this._sentRequestsQueue.delete(requestId);
    }
  }
  clearQueues(event) {
    this._clearQueues(event);
  }
  _clearQueues(event) {
    if (this._pendingRequestsQueue.size > 0) {
      this._pendingRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._pendingRequestsQueue.delete(key);
      });
    }
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._sentRequestsQueue.delete(key);
      });
    }
    this._removeSocketListeners();
  }
}
// node_modules/web3-core/lib/esm/web3_event_emitter.js
class Web3EventEmitter {
  constructor() {
    this._emitter = new EventEmitter2;
  }
  on(eventName, fn) {
    this._emitter.on(eventName, fn);
  }
  once(eventName, fn) {
    this._emitter.once(eventName, fn);
  }
  off(eventName, fn) {
    this._emitter.off(eventName, fn);
  }
  emit(eventName, params) {
    this._emitter.emit(eventName, params);
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
  listeners(eventName) {
    return this._emitter.listeners(eventName);
  }
  eventNames() {
    return this._emitter.eventNames();
  }
  removeAllListeners() {
    return this._emitter.removeAllListeners();
  }
  setMaxListenerWarningThreshold(maxListenersWarningThreshold) {
    this._emitter.setMaxListeners(maxListenersWarningThreshold);
  }
  getMaxListeners() {
    return this._emitter.getMaxListeners();
  }
}

// node_modules/web3-core/lib/esm/web3_config.js
var Web3ConfigEvent;
(function(Web3ConfigEvent2) {
  Web3ConfigEvent2["CONFIG_CHANGE"] = "CONFIG_CHANGE";
})(Web3ConfigEvent || (Web3ConfigEvent = {}));

class Web3Config extends Web3EventEmitter {
  constructor(options) {
    super();
    this.config = {
      handleRevert: false,
      defaultAccount: undefined,
      defaultBlock: "latest",
      transactionBlockTimeout: 50,
      transactionConfirmationBlocks: 24,
      transactionPollingInterval: 1000,
      transactionPollingTimeout: 750 * 1000,
      transactionReceiptPollingInterval: undefined,
      transactionSendTimeout: 750 * 1000,
      transactionConfirmationPollingInterval: undefined,
      blockHeaderTimeout: 10,
      maxListenersWarningThreshold: 100,
      contractDataInputFill: "data",
      defaultNetworkId: undefined,
      defaultChain: "mainnet",
      defaultHardfork: "london",
      defaultCommon: undefined,
      defaultTransactionType: "0x2",
      defaultMaxPriorityFeePerGas: toHex(2500000000),
      enableExperimentalFeatures: {
        useSubscriptionWhenCheckingBlockTimeout: false,
        useRpcCallSpecification: false
      },
      transactionBuilder: undefined,
      transactionTypeParser: undefined
    };
    this.setConfig(options !== null && options !== undefined ? options : {});
  }
  setConfig(options) {
    const keys = Object.keys(options);
    for (const key of keys) {
      this._triggerConfigChange(key, options[key]);
    }
    Object.assign(this.config, options);
  }
  get handleRevert() {
    return this.config.handleRevert;
  }
  set handleRevert(val) {
    this._triggerConfigChange("handleRevert", val);
    this.config.handleRevert = val;
  }
  get contractDataInputFill() {
    return this.config.contractDataInputFill;
  }
  set contractDataInputFill(val) {
    this._triggerConfigChange("contractDataInputFill", val);
    this.config.contractDataInputFill = val;
  }
  get defaultAccount() {
    return this.config.defaultAccount;
  }
  set defaultAccount(val) {
    this._triggerConfigChange("defaultAccount", val);
    this.config.defaultAccount = val;
  }
  get defaultBlock() {
    return this.config.defaultBlock;
  }
  set defaultBlock(val) {
    this._triggerConfigChange("defaultBlock", val);
    this.config.defaultBlock = val;
  }
  get transactionSendTimeout() {
    return this.config.transactionSendTimeout;
  }
  set transactionSendTimeout(val) {
    this._triggerConfigChange("transactionSendTimeout", val);
    this.config.transactionSendTimeout = val;
  }
  get transactionBlockTimeout() {
    return this.config.transactionBlockTimeout;
  }
  set transactionBlockTimeout(val) {
    this._triggerConfigChange("transactionBlockTimeout", val);
    this.config.transactionBlockTimeout = val;
  }
  get transactionConfirmationBlocks() {
    return this.config.transactionConfirmationBlocks;
  }
  set transactionConfirmationBlocks(val) {
    this._triggerConfigChange("transactionConfirmationBlocks", val);
    this.config.transactionConfirmationBlocks = val;
  }
  get transactionPollingInterval() {
    return this.config.transactionPollingInterval;
  }
  set transactionPollingInterval(val) {
    this._triggerConfigChange("transactionPollingInterval", val);
    this.config.transactionPollingInterval = val;
    this.transactionReceiptPollingInterval = val;
    this.transactionConfirmationPollingInterval = val;
  }
  get transactionPollingTimeout() {
    return this.config.transactionPollingTimeout;
  }
  set transactionPollingTimeout(val) {
    this._triggerConfigChange("transactionPollingTimeout", val);
    this.config.transactionPollingTimeout = val;
  }
  get transactionReceiptPollingInterval() {
    return this.config.transactionReceiptPollingInterval;
  }
  set transactionReceiptPollingInterval(val) {
    this._triggerConfigChange("transactionReceiptPollingInterval", val);
    this.config.transactionReceiptPollingInterval = val;
  }
  get transactionConfirmationPollingInterval() {
    return this.config.transactionConfirmationPollingInterval;
  }
  set transactionConfirmationPollingInterval(val) {
    this._triggerConfigChange("transactionConfirmationPollingInterval", val);
    this.config.transactionConfirmationPollingInterval = val;
  }
  get blockHeaderTimeout() {
    return this.config.blockHeaderTimeout;
  }
  set blockHeaderTimeout(val) {
    this._triggerConfigChange("blockHeaderTimeout", val);
    this.config.blockHeaderTimeout = val;
  }
  get enableExperimentalFeatures() {
    return this.config.enableExperimentalFeatures;
  }
  set enableExperimentalFeatures(val) {
    this._triggerConfigChange("enableExperimentalFeatures", val);
    this.config.enableExperimentalFeatures = val;
  }
  get maxListenersWarningThreshold() {
    return this.config.maxListenersWarningThreshold;
  }
  set maxListenersWarningThreshold(val) {
    this._triggerConfigChange("maxListenersWarningThreshold", val);
    this.setMaxListenerWarningThreshold(val);
    this.config.maxListenersWarningThreshold = val;
  }
  get defaultNetworkId() {
    return this.config.defaultNetworkId;
  }
  set defaultNetworkId(val) {
    this._triggerConfigChange("defaultNetworkId", val);
    this.config.defaultNetworkId = val;
  }
  get defaultChain() {
    return this.config.defaultChain;
  }
  set defaultChain(val) {
    if (!isNullish2(this.config.defaultCommon) && !isNullish2(this.config.defaultCommon.baseChain) && val !== this.config.defaultCommon.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val);
    this._triggerConfigChange("defaultChain", val);
    this.config.defaultChain = val;
  }
  get defaultHardfork() {
    return this.config.defaultHardfork;
  }
  set defaultHardfork(val) {
    if (!isNullish2(this.config.defaultCommon) && !isNullish2(this.config.defaultCommon.hardfork) && val !== this.config.defaultCommon.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultCommon.hardfork, val);
    this._triggerConfigChange("defaultHardfork", val);
    this.config.defaultHardfork = val;
  }
  get defaultCommon() {
    return this.config.defaultCommon;
  }
  set defaultCommon(val) {
    if (!isNullish2(this.config.defaultHardfork) && !isNullish2(val) && !isNullish2(val.hardfork) && this.config.defaultHardfork !== val.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultHardfork, val.hardfork);
    if (!isNullish2(this.config.defaultChain) && !isNullish2(val) && !isNullish2(val.baseChain) && this.config.defaultChain !== val.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val.baseChain);
    this._triggerConfigChange("defaultCommon", val);
    this.config.defaultCommon = val;
  }
  get defaultTransactionType() {
    return this.config.defaultTransactionType;
  }
  set defaultTransactionType(val) {
    this._triggerConfigChange("defaultTransactionType", val);
    this.config.defaultTransactionType = val;
  }
  get defaultMaxPriorityFeePerGas() {
    return this.config.defaultMaxPriorityFeePerGas;
  }
  set defaultMaxPriorityFeePerGas(val) {
    this._triggerConfigChange("defaultMaxPriorityFeePerGas", val);
    this.config.defaultMaxPriorityFeePerGas = val;
  }
  get transactionBuilder() {
    return this.config.transactionBuilder;
  }
  set transactionBuilder(val) {
    this._triggerConfigChange("transactionBuilder", val);
    this.config.transactionBuilder = val;
  }
  get transactionTypeParser() {
    return this.config.transactionTypeParser;
  }
  set transactionTypeParser(val) {
    this._triggerConfigChange("transactionTypeParser", val);
    this.config.transactionTypeParser = val;
  }
  _triggerConfigChange(config2, newValue) {
    this.emit(Web3ConfigEvent.CONFIG_CHANGE, {
      name: config2,
      oldValue: this.config[config2],
      newValue
    });
  }
}
// node_modules/web3-providers-http/lib/esm/index.js
var import_cross_fetch = __toESM(require_node_ponyfill(), 1);
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class HttpProvider extends Web3BaseProvider {
  constructor(clientUrl, httpProviderOptions) {
    super();
    if (!HttpProvider.validateClientUrl(clientUrl))
      throw new InvalidClientError(clientUrl);
    this.clientUrl = clientUrl;
    this.httpProviderOptions = httpProviderOptions;
  }
  static validateClientUrl(clientUrl) {
    return typeof clientUrl === "string" ? /^http(s)?:\/\//i.test(clientUrl) : false;
  }
  getStatus() {
    throw new MethodNotImplementedError;
  }
  supportsSubscriptions() {
    return false;
  }
  request(payload, requestOptions) {
    var _a2;
    return __awaiter6(this, undefined, undefined, function* () {
      const providerOptionsCombined = Object.assign(Object.assign({}, (_a2 = this.httpProviderOptions) === null || _a2 === undefined ? undefined : _a2.providerOptions), requestOptions);
      const response = yield import_cross_fetch.default(this.clientUrl, Object.assign(Object.assign({}, providerOptionsCombined), { method: "POST", headers: Object.assign(Object.assign({}, providerOptionsCombined.headers), { "Content-Type": "application/json" }), body: JSON.stringify(payload) }));
      if (!response.ok)
        throw new ResponseError(yield response.json());
      return yield response.json();
    });
  }
  on() {
    throw new MethodNotImplementedError;
  }
  removeListener() {
    throw new MethodNotImplementedError;
  }
  once() {
    throw new MethodNotImplementedError;
  }
  removeAllListeners() {
    throw new MethodNotImplementedError;
  }
  connect() {
    throw new MethodNotImplementedError;
  }
  disconnect() {
    throw new MethodNotImplementedError;
  }
  reset() {
    throw new MethodNotImplementedError;
  }
  reconnect() {
    throw new MethodNotImplementedError;
  }
}

// node_modules/web3-providers-ws/lib/esm/index.js
import WebSocket from "ws";
class WebSocketProvider extends SocketProvider {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super(socketPath, socketOptions, reconnectOptions);
  }
  _validateProviderPath(providerUrl) {
    return typeof providerUrl === "string" ? /^ws(s)?:\/\//i.test(providerUrl) : false;
  }
  getStatus() {
    if (this._socketConnection && !isNullish2(this._socketConnection)) {
      switch (this._socketConnection.readyState) {
        case this._socketConnection.CONNECTING: {
          return "connecting";
        }
        case this._socketConnection.OPEN: {
          return "connected";
        }
        default: {
          return "disconnected";
        }
      }
    }
    return "disconnected";
  }
  _openSocketConnection() {
    this._socketConnection = new WebSocket(this._socketPath, undefined, this._socketOptions && Object.keys(this._socketOptions).length === 0 ? undefined : this._socketOptions);
  }
  _closeSocketConnection(code, data) {
    var _a2;
    (_a2 = this._socketConnection) === null || _a2 === undefined || _a2.close(code, data);
  }
  _sendToSocket(payload) {
    var _a2;
    if (this.getStatus() === "disconnected") {
      throw new ConnectionNotOpenError;
    }
    (_a2 = this._socketConnection) === null || _a2 === undefined || _a2.send(JSON.stringify(payload));
  }
  _parseResponses(event) {
    return this.chunkResponseParser.parseResponse(event.data);
  }
  _addSocketListeners() {
    var _a2, _b, _c, _d;
    (_a2 = this._socketConnection) === null || _a2 === undefined || _a2.addEventListener("open", this._onOpenHandler);
    (_b = this._socketConnection) === null || _b === undefined || _b.addEventListener("message", this._onMessageHandler);
    (_c = this._socketConnection) === null || _c === undefined || _c.addEventListener("close", (e) => this._onCloseHandler(e));
    (_d = this._socketConnection) === null || _d === undefined || _d.addEventListener("error", this._onErrorHandler);
  }
  _removeSocketListeners() {
    var _a2, _b, _c;
    (_a2 = this._socketConnection) === null || _a2 === undefined || _a2.removeEventListener("message", this._onMessageHandler);
    (_b = this._socketConnection) === null || _b === undefined || _b.removeEventListener("open", this._onOpenHandler);
    (_c = this._socketConnection) === null || _c === undefined || _c.removeEventListener("close", this._onCloseHandler);
  }
  _onCloseEvent(event) {
    var _a2;
    if (this._reconnectOptions.autoReconnect && (![1000, 1001].includes(event.code) || !event.wasClean)) {
      this._reconnect();
      return;
    }
    this._clearQueues(event);
    this._removeSocketListeners();
    this._onDisconnect(event.code, event.reason);
    (_a2 = this._socketConnection) === null || _a2 === undefined || _a2.removeEventListener("error", this._onErrorHandler);
  }
}

// node_modules/web3-core/lib/esm/utils.js
var isWeb3Provider = (provider) => Web3BaseProvider.isWeb3Provider(provider);
var isLegacyRequestProvider = (provider) => typeof provider !== "string" && ("request" in provider) && provider.request.constructor.name === "Function";
var isEIP1193Provider = (provider) => typeof provider !== "string" && ("request" in provider) && provider.request.constructor.name === "AsyncFunction";
var isLegacySendProvider = (provider) => typeof provider !== "string" && ("send" in provider);
var isLegacySendAsyncProvider = (provider) => typeof provider !== "string" && ("sendAsync" in provider);
var isSupportedProvider = (provider) => provider && (isWeb3Provider(provider) || isEIP1193Provider(provider) || isLegacyRequestProvider(provider) || isLegacySendAsyncProvider(provider) || isLegacySendProvider(provider));
var isSupportSubscriptions = (provider) => {
  if (provider && "supportsSubscriptions" in provider) {
    return provider.supportsSubscriptions();
  }
  if (provider && typeof provider !== "string" && "on" in provider) {
    return true;
  }
  return false;
};

// node_modules/web3-core/lib/esm/web3_request_manager.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3RequestManagerEvent;
(function(Web3RequestManagerEvent2) {
  Web3RequestManagerEvent2["PROVIDER_CHANGED"] = "PROVIDER_CHANGED";
  Web3RequestManagerEvent2["BEFORE_PROVIDER_CHANGE"] = "BEFORE_PROVIDER_CHANGE";
})(Web3RequestManagerEvent || (Web3RequestManagerEvent = {}));
var availableProviders = {
  HttpProvider,
  WebsocketProvider: WebSocketProvider
};

class Web3RequestManager extends Web3EventEmitter {
  constructor(provider, useRpcCallSpecification) {
    super();
    if (!isNullish2(provider)) {
      this.setProvider(provider);
    }
    this.useRpcCallSpecification = useRpcCallSpecification;
  }
  static get providers() {
    return availableProviders;
  }
  get provider() {
    return this._provider;
  }
  get providers() {
    return availableProviders;
  }
  setProvider(provider) {
    let newProvider;
    if (provider && typeof provider === "string" && this.providers) {
      if (/^http(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.HttpProvider(provider);
      } else if (/^ws(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.WebsocketProvider(provider);
      } else {
        throw new ProviderError(`Can't autodetect provider for "${provider}"`);
      }
    } else if (isNullish2(provider)) {
      newProvider = undefined;
    } else {
      newProvider = provider;
    }
    this.emit(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, this._provider);
    this._provider = newProvider;
    this.emit(Web3RequestManagerEvent.PROVIDER_CHANGED, this._provider);
    return true;
  }
  send(request) {
    return __awaiter7(this, undefined, undefined, function* () {
      const response = yield this._sendRequest(request);
      if (exports_json_rpc.isResponseWithResult(response)) {
        return response.result;
      }
      throw new ResponseError(response);
    });
  }
  sendBatch(request) {
    return __awaiter7(this, undefined, undefined, function* () {
      const response = yield this._sendRequest(request);
      return response;
    });
  }
  _sendRequest(request) {
    return __awaiter7(this, undefined, undefined, function* () {
      const { provider } = this;
      if (isNullish2(provider)) {
        throw new ProviderError("Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.");
      }
      const payload = exports_json_rpc.isBatchRequest(request) ? exports_json_rpc.toBatchPayload(request) : exports_json_rpc.toPayload(request);
      if (isWeb3Provider(provider)) {
        let response;
        try {
          response = yield provider.request(payload);
        } catch (error) {
          response = error;
        }
        return this._processJsonRpcResponse(payload, response, { legacy: false, error: false });
      }
      if (isEIP1193Provider(provider)) {
        return provider.request(payload).then((res) => this._processJsonRpcResponse(payload, res, {
          legacy: true,
          error: false
        })).catch((error) => this._processJsonRpcResponse(payload, error, { legacy: true, error: true }));
      }
      if (isLegacyRequestProvider(provider)) {
        return new Promise((resolve, reject) => {
          const rejectWithError = (err) => reject(this._processJsonRpcResponse(payload, err, {
            legacy: true,
            error: true
          }));
          const resolveWithResponse = (response) => resolve(this._processJsonRpcResponse(payload, response, {
            legacy: true,
            error: false
          }));
          const result = provider.request(payload, (err, response) => {
            if (err) {
              return rejectWithError(err);
            }
            return resolveWithResponse(response);
          });
          if (isPromise(result)) {
            const responsePromise = result;
            responsePromise.then(resolveWithResponse).catch(rejectWithError);
          }
        });
      }
      if (isLegacySendProvider(provider)) {
        return new Promise((resolve, reject) => {
          provider.send(payload, (err, response) => {
            if (err) {
              return reject(this._processJsonRpcResponse(payload, err, {
                legacy: true,
                error: true
              }));
            }
            if (isNullish2(response)) {
              throw new ResponseError("", 'Got a "nullish" response from provider.');
            }
            return resolve(this._processJsonRpcResponse(payload, response, {
              legacy: true,
              error: false
            }));
          });
        });
      }
      if (isLegacySendAsyncProvider(provider)) {
        return provider.sendAsync(payload).then((response) => this._processJsonRpcResponse(payload, response, { legacy: true, error: false })).catch((error) => this._processJsonRpcResponse(payload, error, {
          legacy: true,
          error: true
        }));
      }
      throw new ProviderError("Provider does not have a request or send method to use.");
    });
  }
  _processJsonRpcResponse(payload, response, { legacy, error }) {
    if (isNullish2(response)) {
      return this._buildResponse(payload, null, error);
    }
    if (exports_json_rpc.isResponseWithError(response)) {
      if (this.useRpcCallSpecification && isResponseRpcError(response)) {
        const rpcErrorResponse = response;
        if (rpcErrorsMap.get(rpcErrorResponse.error.code)) {
          const Err = rpcErrorsMap.get(rpcErrorResponse.error.code).error;
          throw new Err(rpcErrorResponse);
        } else {
          throw new RpcError(rpcErrorResponse);
        }
      } else if (!Web3RequestManager._isReverted(response)) {
        throw new InvalidResponseError(response, payload);
      }
    }
    if (exports_json_rpc.isResponseWithResult(response)) {
      return response;
    }
    if (response instanceof Error) {
      Web3RequestManager._isReverted(response);
      throw response;
    }
    if (!legacy && exports_json_rpc.isBatchRequest(payload) && exports_json_rpc.isBatchResponse(response)) {
      return response;
    }
    if (legacy && !error && exports_json_rpc.isBatchRequest(payload)) {
      return response;
    }
    if (legacy && error && exports_json_rpc.isBatchRequest(payload)) {
      throw response;
    }
    if (legacy && !exports_json_rpc.isResponseWithError(response) && !exports_json_rpc.isResponseWithResult(response)) {
      return this._buildResponse(payload, response, error);
    }
    if (exports_json_rpc.isBatchRequest(payload) && !Array.isArray(response)) {
      throw new ResponseError(response, "Got normal response for a batch request.");
    }
    if (!exports_json_rpc.isBatchRequest(payload) && Array.isArray(response)) {
      throw new ResponseError(response, "Got batch response for a normal request.");
    }
    if ((exports_json_rpc.isResponseWithError(response) || exports_json_rpc.isResponseWithResult(response)) && !exports_json_rpc.isBatchRequest(payload)) {
      if (response.id && payload.id !== response.id) {
        throw new InvalidResponseError(response);
      }
    }
    throw new ResponseError(response, "Invalid response");
  }
  static _isReverted(response) {
    let error;
    if (exports_json_rpc.isResponseWithError(response)) {
      error = response.error;
    } else if (response instanceof Error) {
      error = response;
    }
    if (error === null || error === undefined ? undefined : error.message.includes("revert"))
      throw new ContractExecutionError(error);
    return false;
  }
  _buildResponse(payload, response, error) {
    const res = {
      jsonrpc: "2.0",
      id: exports_json_rpc.isBatchRequest(payload) ? payload[0].id : ("id" in payload) ? payload.id : null
    };
    if (error) {
      return Object.assign(Object.assign({}, res), { error: response });
    }
    return Object.assign(Object.assign({}, res), { result: response });
  }
}
// node_modules/web3-core/lib/esm/web3_subscription_manager.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Web3SubscriptionManager {
  constructor(requestManager, registeredSubscriptions, tolerateUnlinkedSubscription = false) {
    this.requestManager = requestManager;
    this.registeredSubscriptions = registeredSubscriptions;
    this.tolerateUnlinkedSubscription = tolerateUnlinkedSubscription;
    this._subscriptions = new Map;
    this.requestManager.on(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, () => __awaiter8(this, undefined, undefined, function* () {
      yield this.unsubscribe();
    }));
    this.requestManager.on(Web3RequestManagerEvent.PROVIDER_CHANGED, () => {
      this.clear();
      this.listenToProviderEvents();
    });
    this.listenToProviderEvents();
  }
  listenToProviderEvents() {
    const providerAsWebProvider = this.requestManager.provider;
    if (!this.requestManager.provider || typeof (providerAsWebProvider === null || providerAsWebProvider === undefined ? undefined : providerAsWebProvider.supportsSubscriptions) === "function" && !(providerAsWebProvider === null || providerAsWebProvider === undefined ? undefined : providerAsWebProvider.supportsSubscriptions())) {
      return;
    }
    if (typeof this.requestManager.provider.on === "function") {
      if (typeof this.requestManager.provider.request === "function") {
        this.requestManager.provider.on("message", (message) => this.messageListener(message));
      } else {
        providerAsWebProvider.on("data", (data) => this.messageListener(data));
      }
    }
  }
  messageListener(data) {
    var _a2, _b, _c;
    if (!data) {
      throw new SubscriptionError("Should not call messageListener with no data. Type was");
    }
    const subscriptionId = ((_a2 = data.params) === null || _a2 === undefined ? undefined : _a2.subscription) || ((_b = data.data) === null || _b === undefined ? undefined : _b.subscription) || ((_c = data.id) === null || _c === undefined ? undefined : _c.toString(16));
    if (subscriptionId) {
      const sub = this._subscriptions.get(subscriptionId);
      sub === null || sub === undefined || sub.processSubscriptionData(data);
    }
  }
  subscribe(name, args, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter8(this, undefined, undefined, function* () {
      const Klass = this.registeredSubscriptions[name];
      if (!Klass) {
        throw new SubscriptionError("Invalid subscription type");
      }
      const subscription = new Klass(args !== null && args !== undefined ? args : undefined, {
        subscriptionManager: this,
        returnFormat
      });
      yield this.addSubscription(subscription);
      return subscription;
    });
  }
  get subscriptions() {
    return this._subscriptions;
  }
  addSubscription(sub) {
    return __awaiter8(this, undefined, undefined, function* () {
      if (!this.requestManager.provider) {
        throw new ProviderError("Provider not available");
      }
      if (!this.supportsSubscriptions()) {
        throw new SubscriptionError("The current provider does not support subscriptions");
      }
      if (sub.id && this._subscriptions.has(sub.id)) {
        throw new SubscriptionError(`Subscription with id "${sub.id}" already exists`);
      }
      yield sub.sendSubscriptionRequest();
      if (isNullish2(sub.id)) {
        throw new SubscriptionError("Subscription is not subscribed yet.");
      }
      this._subscriptions.set(sub.id, sub);
      return sub.id;
    });
  }
  removeSubscription(sub) {
    return __awaiter8(this, undefined, undefined, function* () {
      const { id } = sub;
      if (isNullish2(id)) {
        throw new SubscriptionError("Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.");
      }
      if (!this._subscriptions.has(id) && !this.tolerateUnlinkedSubscription) {
        throw new SubscriptionError(`Subscription with id "${id.toString()}" does not exists`);
      }
      yield sub.sendUnsubscribeRequest();
      this._subscriptions.delete(id);
      return id;
    });
  }
  unsubscribe(condition) {
    return __awaiter8(this, undefined, undefined, function* () {
      const result = [];
      for (const [id, sub] of this.subscriptions.entries()) {
        if (!condition || typeof condition === "function" && condition({ id, sub })) {
          result.push(this.removeSubscription(sub));
        }
      }
      return Promise.all(result);
    });
  }
  clear() {
    this._subscriptions.clear();
  }
  supportsSubscriptions() {
    return isNullish2(this.requestManager.provider) ? false : isSupportSubscriptions(this.requestManager.provider);
  }
}
// node_modules/web3-core/lib/esm/web3_subscriptions.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Web3Subscription extends Web3EventEmitter {
  constructor(args, options) {
    var _a2;
    super();
    this.args = args;
    const { requestManager } = options;
    const { subscriptionManager } = options;
    if (requestManager && subscriptionManager) {
      throw new SubscriptionError("Only requestManager or subscriptionManager should be provided at Subscription constructor");
    }
    if (!requestManager && !subscriptionManager) {
      throw new SubscriptionError("Either requestManager or subscriptionManager should be provided at Subscription constructor");
    }
    if (requestManager) {
      this._subscriptionManager = new Web3SubscriptionManager(requestManager, {}, true);
    } else {
      this._subscriptionManager = subscriptionManager;
    }
    this._returnFormat = (_a2 = options === null || options === undefined ? undefined : options.returnFormat) !== null && _a2 !== undefined ? _a2 : DEFAULT_RETURN_FORMAT;
  }
  get id() {
    return this._id;
  }
  get lastBlock() {
    return this._lastBlock;
  }
  subscribe() {
    return __awaiter9(this, undefined, undefined, function* () {
      return this._subscriptionManager.addSubscription(this);
    });
  }
  processSubscriptionData(data) {
    var _a2, _b;
    if (data === null || data === undefined ? undefined : data.data) {
      this._processSubscriptionResult((_b = (_a2 = data === null || data === undefined ? undefined : data.data) === null || _a2 === undefined ? undefined : _a2.result) !== null && _b !== undefined ? _b : data === null || data === undefined ? undefined : data.data);
    } else if (data && exports_json_rpc.isResponseWithNotification(data)) {
      this._processSubscriptionResult(data === null || data === undefined ? undefined : data.params.result);
    }
  }
  sendSubscriptionRequest() {
    return __awaiter9(this, undefined, undefined, function* () {
      this._id = yield this._subscriptionManager.requestManager.send({
        method: "eth_subscribe",
        params: this._buildSubscriptionParams()
      });
      this.emit("connected", this._id);
      return this._id;
    });
  }
  get returnFormat() {
    return this._returnFormat;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  resubscribe() {
    return __awaiter9(this, undefined, undefined, function* () {
      yield this.unsubscribe();
      yield this.subscribe();
    });
  }
  unsubscribe() {
    return __awaiter9(this, undefined, undefined, function* () {
      if (!this.id) {
        return;
      }
      yield this._subscriptionManager.removeSubscription(this);
    });
  }
  sendUnsubscribeRequest() {
    return __awaiter9(this, undefined, undefined, function* () {
      yield this._subscriptionManager.requestManager.send({
        method: "eth_unsubscribe",
        params: [this.id]
      });
      this._id = undefined;
    });
  }
  formatSubscriptionResult(data) {
    return data;
  }
  _processSubscriptionResult(data) {
    this.emit("data", this.formatSubscriptionResult(data));
  }
  _processSubscriptionError(error) {
    this.emit("error", error);
  }
  _buildSubscriptionParams() {
    throw new Error("Implement in the child class");
  }
}
// node_modules/web3-eth-accounts/lib/esm/wallet.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Wallet extends Web3BaseWallet {
  constructor() {
    super(...arguments);
    this._addressMap = new Map;
    this._defaultKeyName = "web3js_wallet";
  }
  static getStorage() {
    let storage;
    try {
      storage = window.localStorage;
      const x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return storage;
    } catch (e) {
      return e && (e.code === 22 || e.code === 1014 || e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") && !isNullish(storage) && storage.length !== 0 ? storage : undefined;
    }
  }
  create(numberOfAccounts) {
    for (let i = 0;i < numberOfAccounts; i += 1) {
      this.add(this._accountProvider.create());
    }
    return this;
  }
  add(account) {
    var _a2;
    if (typeof account === "string") {
      return this.add(this._accountProvider.privateKeyToAccount(account));
    }
    let index = this.length;
    const existAccount = this.get(account.address);
    if (existAccount) {
      console.warn(`Account ${account.address.toLowerCase()} already exists.`);
      index = (_a2 = this._addressMap.get(account.address.toLowerCase())) !== null && _a2 !== undefined ? _a2 : index;
    }
    this._addressMap.set(account.address.toLowerCase(), index);
    this[index] = account;
    return this;
  }
  get(addressOrIndex) {
    if (typeof addressOrIndex === "string") {
      const index = this._addressMap.get(addressOrIndex.toLowerCase());
      if (!isNullish(index)) {
        return this[index];
      }
      return;
    }
    return this[addressOrIndex];
  }
  remove(addressOrIndex) {
    if (typeof addressOrIndex === "string") {
      const index = this._addressMap.get(addressOrIndex.toLowerCase());
      if (isNullish(index)) {
        return false;
      }
      this._addressMap.delete(addressOrIndex.toLowerCase());
      this.splice(index, 1);
      return true;
    }
    if (this[addressOrIndex]) {
      this.splice(addressOrIndex, 1);
      return true;
    }
    return false;
  }
  clear() {
    this._addressMap.clear();
    this.length = 0;
    return this;
  }
  encrypt(password, options) {
    return __awaiter10(this, undefined, undefined, function* () {
      return Promise.all(this.map((account) => __awaiter10(this, undefined, undefined, function* () {
        return account.encrypt(password, options);
      })));
    });
  }
  decrypt(encryptedWallets, password, options) {
    return __awaiter10(this, undefined, undefined, function* () {
      const results = yield Promise.all(encryptedWallets.map((wallet) => __awaiter10(this, undefined, undefined, function* () {
        return this._accountProvider.decrypt(wallet, password, options);
      })));
      for (const res of results) {
        this.add(res);
      }
      return this;
    });
  }
  save(password, keyName) {
    return __awaiter10(this, undefined, undefined, function* () {
      const storage = Wallet.getStorage();
      if (!storage) {
        throw new Error("Local storage not available.");
      }
      storage.setItem(keyName !== null && keyName !== undefined ? keyName : this._defaultKeyName, JSON.stringify(yield this.encrypt(password)));
      return true;
    });
  }
  load(password, keyName) {
    return __awaiter10(this, undefined, undefined, function* () {
      const storage = Wallet.getStorage();
      if (!storage) {
        throw new Error("Local storage not available.");
      }
      const keystore = storage.getItem(keyName !== null && keyName !== undefined ? keyName : this._defaultKeyName);
      if (keystore) {
        yield this.decrypt(JSON.parse(keystore) || [], password);
      }
      return this;
    });
  }
}
// node_modules/ethereum-cryptography/esm/aes.js
var validateOpt = function(key, iv, mode) {
  if (!mode.startsWith("aes-")) {
    throw new Error(`AES submodule doesn't support mode ${mode}`);
  }
  if (iv.length !== 16) {
    throw new Error("AES: wrong IV length");
  }
  if (mode.startsWith("aes-128") && key.length !== 16 || mode.startsWith("aes-256") && key.length !== 32) {
    throw new Error("AES: wrong key length");
  }
};
async function getBrowserKey(mode, key, iv) {
  if (!crypto6.web) {
    throw new Error("Browser crypto not available.");
  }
  let keyMode;
  if (["aes-128-cbc", "aes-256-cbc"].includes(mode)) {
    keyMode = "cbc";
  }
  if (["aes-128-ctr", "aes-256-ctr"].includes(mode)) {
    keyMode = "ctr";
  }
  if (!keyMode) {
    throw new Error("AES: unsupported mode");
  }
  const wKey = await crypto6.web.subtle.importKey("raw", key, { name: `AES-${keyMode.toUpperCase()}`, length: key.length * 8 }, true, ["encrypt", "decrypt"]);
  return [wKey, { name: `aes-${keyMode}`, iv, counter: iv, length: 128 }];
}
async function encrypt(msg, key, iv, mode = "aes-128-ctr", pkcs7PaddingEnabled = true) {
  validateOpt(key, iv, mode);
  if (crypto6.web) {
    const [wKey, wOpt] = await getBrowserKey(mode, key, iv);
    const cipher = await crypto6.web.subtle.encrypt(wOpt, wKey, msg);
    let res = new Uint8Array(cipher);
    if (!pkcs7PaddingEnabled && wOpt.name === "aes-cbc" && !(msg.length % 16)) {
      res = res.slice(0, -16);
    }
    return res;
  } else if (crypto6.node) {
    const cipher = crypto6.node.createCipheriv(mode, key, iv);
    cipher.setAutoPadding(pkcs7PaddingEnabled);
    return concatBytes(cipher.update(msg), cipher.final());
  } else {
    throw new Error("The environment doesn't have AES module");
  }
}
async function getPadding(cypherText, key, iv, mode) {
  const lastBlock = cypherText.slice(-16);
  for (let i = 0;i < 16; i++) {
    lastBlock[i] ^= iv[i] ^ 16;
  }
  const res = await encrypt(lastBlock, key, iv, mode);
  return res.slice(0, 16);
}
async function decrypt(cypherText, key, iv, mode = "aes-128-ctr", pkcs7PaddingEnabled = true) {
  validateOpt(key, iv, mode);
  if (crypto6.web) {
    const [wKey, wOpt] = await getBrowserKey(mode, key, iv);
    if (!pkcs7PaddingEnabled && wOpt.name === "aes-cbc") {
      const padding = await getPadding(cypherText, key, iv, mode);
      cypherText = concatBytes(cypherText, padding);
    }
    const msg = await crypto6.web.subtle.decrypt(wOpt, wKey, cypherText);
    const msgBytes = new Uint8Array(msg);
    if (wOpt.name === "aes-cbc") {
      const encrypted = await encrypt(msgBytes, key, iv, mode);
      if (!equalsBytes(encrypted, cypherText)) {
        throw new Error("AES: wrong padding");
      }
    }
    return msgBytes;
  } else if (crypto6.node) {
    const decipher = crypto6.node.createDecipheriv(mode, key, iv);
    decipher.setAutoPadding(pkcs7PaddingEnabled);
    return concatBytes(decipher.update(cypherText), decipher.final());
  } else {
    throw new Error("The environment doesn't have AES module");
  }
}
var crypto6 = { web: crypto2 };

// node_modules/@noble/hashes/esm/hmac.js
class HMAC extends Hash {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash3);
    const key = toBytes(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash3.create();
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
hmac.create = (hash3, key) => new HMAC(hash3, key);

// node_modules/@noble/hashes/esm/pbkdf2.js
var pbkdf2Init = function(hash3, _password, _salt, _opts) {
  hash(hash3);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  number(c);
  number(dkLen);
  number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash3, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
};
var pbkdf2Output = function(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
};
function pbkdf2(hash3, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0;pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1;ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0;i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// node_modules/@noble/hashes/esm/_sha2.js
var setBigUint64 = function(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
};

class SHA2 extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (;blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos;i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0;i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor);
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
}

// node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);

class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16;i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0;i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
var sha256 = wrapConstructor(() => new SHA256);

// node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => _u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);

class SHA512 extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16;i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = _u64_default.rotrSH(W15h, W15l, 1) ^ _u64_default.rotrSH(W15h, W15l, 8) ^ _u64_default.shrSH(W15h, W15l, 7);
      const s0l = _u64_default.rotrSL(W15h, W15l, 1) ^ _u64_default.rotrSL(W15h, W15l, 8) ^ _u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = _u64_default.rotrSH(W2h, W2l, 19) ^ _u64_default.rotrBH(W2h, W2l, 61) ^ _u64_default.shrSH(W2h, W2l, 6);
      const s1l = _u64_default.rotrSL(W2h, W2l, 19) ^ _u64_default.rotrBL(W2h, W2l, 61) ^ _u64_default.shrSL(W2h, W2l, 6);
      const SUMl = _u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = _u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0;i < 80; i++) {
      const sigma1h = _u64_default.rotrSH(Eh, El, 14) ^ _u64_default.rotrSH(Eh, El, 18) ^ _u64_default.rotrBH(Eh, El, 41);
      const sigma1l = _u64_default.rotrSL(Eh, El, 14) ^ _u64_default.rotrSL(Eh, El, 18) ^ _u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = _u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = _u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = _u64_default.rotrSH(Ah, Al, 28) ^ _u64_default.rotrBH(Ah, Al, 34) ^ _u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = _u64_default.rotrSL(Ah, Al, 28) ^ _u64_default.rotrBL(Ah, Al, 34) ^ _u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = _u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = _u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = _u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = _u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = _u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = _u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = _u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = _u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = _u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = _u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = _u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
var sha512 = wrapConstructor(() => new SHA512);

// node_modules/ethereum-cryptography/esm/pbkdf2.js
function pbkdf2Sync(password, salt, iterations, keylen, digest) {
  if (!["sha256", "sha512"].includes(digest)) {
    throw new Error("Only sha256 and sha512 are supported");
  }
  assertBytes(password);
  assertBytes(salt);
  return pbkdf2(digest === "sha256" ? sha256 : sha512, password, salt, {
    c: iterations,
    dkLen: keylen
  });
}

// node_modules/@noble/hashes/esm/scrypt.js
var XorAndSalsa = function(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0;i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
};
var BlockMix = function(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0;i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0;i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
};
var scryptInit = function(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  number(N);
  number(r);
  number(p);
  number(dkLen);
  number(asyncTick);
  number(maxmem);
  if (onProgress !== undefined && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
};
var scryptOutput = function(password, dkLen, B, V, tmp) {
  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
};
function scrypt(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0;pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0;i < blockSize32; i++)
      V[i] = B32[Pi + i];
    for (let i = 0, pos = 0;i < N - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
    blockMixCb();
    for (let i = 0;i < N; i++) {
      const j = B32[Pi + blockSize32 - 16] % N;
      for (let k = 0;k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
var rotl = (a, b) => a << b | a >>> 32 - b;

// node_modules/ethereum-cryptography/esm/scrypt.js
function scryptSync(password, salt, n, p, r, dkLen, onProgress) {
  assertBytes(password);
  assertBytes(salt);
  return scrypt(password, salt, { N: n, r, p, dkLen, onProgress });
}

// node_modules/ethereum-cryptography/esm/secp256k1.js
var exports_secp256k1 = {};
__export(exports_secp256k1, {
  secp256k1: () => {
    {
      return secp256k1;
    }
  }
});

// node_modules/@noble/curves/esm/abstract/utils.js
var exports_utils2 = {};
__export(exports_utils2, {
  validateObject: () => {
    {
      return validateObject;
    }
  },
  utf8ToBytes: () => {
    {
      return utf8ToBytes3;
    }
  },
  numberToVarBytesBE: () => {
    {
      return numberToVarBytesBE;
    }
  },
  numberToHexUnpadded: () => {
    {
      return numberToHexUnpadded;
    }
  },
  numberToBytesLE: () => {
    {
      return numberToBytesLE;
    }
  },
  numberToBytesBE: () => {
    {
      return numberToBytesBE;
    }
  },
  isBytes: () => {
    {
      return isBytes4;
    }
  },
  hexToNumber: () => {
    {
      return hexToNumber3;
    }
  },
  hexToBytes: () => {
    {
      return hexToBytes2;
    }
  },
  equalBytes: () => {
    {
      return equalBytes;
    }
  },
  ensureBytes: () => {
    {
      return ensureBytes;
    }
  },
  createHmacDrbg: () => {
    {
      return createHmacDrbg;
    }
  },
  concatBytes: () => {
    {
      return concatBytes2;
    }
  },
  bytesToNumberLE: () => {
    {
      return bytesToNumberLE;
    }
  },
  bytesToNumberBE: () => {
    {
      return bytesToNumberBE;
    }
  },
  bytesToHex: () => {
    {
      return bytesToHex3;
    }
  },
  bitSet: () => {
    {
      return bitSet;
    }
  },
  bitMask: () => {
    {
      return bitMask;
    }
  },
  bitLen: () => {
    {
      return bitLen;
    }
  },
  bitGet: () => {
    {
      return bitGet;
    }
  }
});
function isBytes4(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytesToHex3(bytes5) {
  if (!isBytes4(bytes5))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0;i < bytes5.length; i++) {
    hex += hexes[bytes5[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber3(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
var asciiToBase16 = function(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
};
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes5) {
  return hexToNumber3(bytesToHex3(bytes5));
}
function bytesToNumberLE(bytes5) {
  if (!isBytes4(bytes5))
    throw new Error("Uint8Array expected");
  return hexToNumber3(bytesToHex3(Uint8Array.from(bytes5).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes2(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes2(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes2(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (isBytes4(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i = 0;i < arrays.length; i++) {
    const a = arrays[i];
    if (!isBytes4(a))
      throw new Error("Uint8Array expected");
    sum += a.length;
  }
  let res = new Uint8Array(sum);
  let pad = 0;
  for (let i = 0;i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0;i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0;n > _0n2; n >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n2;
}
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1000)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = undefined;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object3, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object3[fieldName];
    if (isOptional && val === undefined)
      return;
    if (!checkVal(val, object3)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object3;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
var bitSet = (n, pos, value) => {
  return n | (value ? _1n2 : _0n2) << BigInt(pos);
};
var bitMask = (n) => (_2n2 << BigInt(n - 1)) - _1n2;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes4(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object3) => object3.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};

// node_modules/@noble/curves/esm/abstract/modular.js
function mod(a, b) {
  const result = a % b;
  return result >= _0n3 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b = modulo;
  let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
  while (a !== _0n3) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n3;
  let Q, S, Z;
  for (Q = P - _1n3, S = 0;Q % _2n3 === _0n3; Q /= _2n3, S++)
    ;
  for (Z = _2n3;Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n3) / _4n;
    return function tonelliFast(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n3;
  return function tonelliSlow(Fp, n) {
    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
    let x = Fp.pow(n, Q1div2);
    let b = Fp.pow(n, Q);
    while (!Fp.eql(b, Fp.ONE)) {
      if (Fp.eql(b, Fp.ZERO))
        return Fp.ZERO;
      let m = 1;
      for (let t2 = Fp.sqr(b);m < r; m++) {
        if (Fp.eql(t2, Fp.ONE))
          break;
        t2 = Fp.sqr(t2);
      }
      const ge = Fp.pow(g, _1n3 << BigInt(r - m - 1));
      g = Fp.sqr(ge);
      x = Fp.mul(x, ge);
      b = Fp.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n3) / _4n;
    return function sqrt3mod4(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp, n) {
      const n2 = Fp.mul(n, _2n3);
      const v = Fp.pow(n2, c1);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n3), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f.ONE;
  if (power === _1n3)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n3) {
    if (power & _1n3)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes5) => {
      if (bytes5.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes5.length}`);
      return isLE2 ? bytesToNumberLE(bytes5) : bytesToNumberBE(bytes5);
    }
  });
  return Object.freeze(f);
}
function FpSqrtEven(Fp, elm) {
  if (!Fp.isOdd)
    throw new Error(`Field doesn't have isOdd`);
  const root = Fp.sqrt(elm);
  return Fp.isOdd(root) ? Fp.neg(root) : root;
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength2 = fieldOrder.toString(2).length;
  return Math.ceil(bitLength2 / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n3) === _1n3;
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];

// node_modules/@noble/curves/esm/abstract/curve.js
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n4) {
        if (n & _1n4)
          p = p.add(d);
        d = d.double();
        n >>= _1n4;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0;window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1;i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0;window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);

// node_modules/@noble/curves/esm/abstract/weierstrass.js
var validatePointOpts = function(curve2) {
  const opts = validateBasic(curve2);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp, a } = opts;
  if (endo) {
    if (!Fp.eql(a, Fp.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
};
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes5) => {
    const tail = bytes5.subarray(1);
    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
    const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
  }
  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes4(key))
        key = bytesToHex3(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = new Map;
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }

  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp.isValid(pz))
        throw new Error("z required");
    }
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp.eql(i, Fp.ZERO);
      if (is0(x) && is0(y))
        return Point.ZERO;
      return new Point(x, y, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      const toInv = Fp.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    static fromHex(hex) {
      const P = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp.isOdd)
        return !Fp.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    negate() {
      return new Point(this.px, Fp.neg(this.py), this.pz);
    }
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      });
    }
    multiplyUnsafe(n) {
      const I = Point.ZERO;
      if (n === _0n5)
        return I;
      assertGE(n);
      if (n === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d);
        if (k2 & _1n5)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n);
        point = p;
        fake = f;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point.BASE;
      const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? undefined : sum;
    }
    toAffine(iz) {
      const { px: x, py: y, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp.ONE : Fp.inv(z2);
      const ax = Fp.mul(x, iz);
      const ay = Fp.mul(y, iz);
      const zz = Fp.mul(z2, iz);
      if (is0)
        return { x: Fp.ZERO, y: Fp.ZERO };
      if (!Fp.eql(zz, Fp.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex3(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
var validateOpts = function(curve2) {
  const opts = validateBasic(curve2);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
};
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp.BYTES + 1;
  const uncompressedLen = 2 * Fp.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp.ORDER;
  }
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
      }
    },
    fromBytes(bytes5) {
      const len = bytes5.length;
      const head = bytes5[0];
      const tail = bytes5.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp.sqrt(y2);
        const isYOdd = (y & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex3(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n5;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));

  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils27 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes4(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes5) {
    const num = bytesToNumberBE(bytes5);
    const delta = bytes5.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes5) {
    return modN(bits2int(bytes5));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => (k in opts)))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3, randomBytes: randomBytes3 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes3(Fp.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n5)
        return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n5)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = undefined;
    let P;
    try {
      if (typeof sg === "string" || isBytes4(sg)) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN(h * is);
    const u2 = modN(r * is);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature,
    utils: utils27
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var { bytesToNumberBE: b2n, hexToBytes: h2b } = exports_utils2;
var DER = {
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!isBytes4(data))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);

// node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash3) {
  return {
    hash: hash3,
    hmac: (key, ...msgs) => hmac(hash3, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
  return Object.freeze({ ...create(defHash), create });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */

// node_modules/@noble/curves/esm/secp256k1.js
var sqrtMod = function(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n5, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n5, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n5) / b;
var Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n6 = BigInt(0);
var Point = secp256k1.ProjectivePoint;
// node_modules/web3-eth-accounts/lib/esm/tx/constants.js
var _a2;
var secp256k12 = (_a2 = secp256k1) !== null && _a2 !== undefined ? _a2 : exports_secp256k1;
var MAX_UINT64 = BigInt("0xffffffffffffffff");
var MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var SECP256K1_ORDER = secp256k12.CURVE.n;
var SECP256K1_ORDER_DIV_2 = SECP256K1_ORDER / BigInt(2);

// node_modules/web3-eth-accounts/lib/esm/schemas.js
var keyStoreSchema = {
  type: "object",
  required: ["crypto", "id", "version", "address"],
  properties: {
    crypto: {
      type: "object",
      required: ["cipher", "ciphertext", "cipherparams", "kdf", "kdfparams", "mac"],
      properties: {
        cipher: { type: "string" },
        ciphertext: { type: "string" },
        cipherparams: { type: "object" },
        kdf: { type: "string" },
        kdfparams: { type: "object" },
        salt: { type: "string" },
        mac: { type: "string" }
      }
    },
    id: { type: "string" },
    version: { type: "number" },
    address: { type: "string" }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/enums.js
var Chain;
(function(Chain2) {
  Chain2[Chain2["Mainnet"] = 1] = "Mainnet";
  Chain2[Chain2["Goerli"] = 5] = "Goerli";
  Chain2[Chain2["Sepolia"] = 11155111] = "Sepolia";
})(Chain || (Chain = {}));
var Hardfork;
(function(Hardfork2) {
  Hardfork2["Chainstart"] = "chainstart";
  Hardfork2["Homestead"] = "homestead";
  Hardfork2["Dao"] = "dao";
  Hardfork2["TangerineWhistle"] = "tangerineWhistle";
  Hardfork2["SpuriousDragon"] = "spuriousDragon";
  Hardfork2["Byzantium"] = "byzantium";
  Hardfork2["Constantinople"] = "constantinople";
  Hardfork2["Petersburg"] = "petersburg";
  Hardfork2["Istanbul"] = "istanbul";
  Hardfork2["MuirGlacier"] = "muirGlacier";
  Hardfork2["Berlin"] = "berlin";
  Hardfork2["London"] = "london";
  Hardfork2["ArrowGlacier"] = "arrowGlacier";
  Hardfork2["GrayGlacier"] = "grayGlacier";
  Hardfork2["MergeForkIdTransition"] = "mergeForkIdTransition";
  Hardfork2["Merge"] = "merge";
  Hardfork2["Shanghai"] = "shanghai";
  Hardfork2["ShardingForkDev"] = "shardingFork";
})(Hardfork || (Hardfork = {}));
var ConsensusType;
(function(ConsensusType2) {
  ConsensusType2["ProofOfStake"] = "pos";
  ConsensusType2["ProofOfWork"] = "pow";
  ConsensusType2["ProofOfAuthority"] = "poa";
})(ConsensusType || (ConsensusType = {}));
var ConsensusAlgorithm;
(function(ConsensusAlgorithm2) {
  ConsensusAlgorithm2["Ethash"] = "ethash";
  ConsensusAlgorithm2["Clique"] = "clique";
  ConsensusAlgorithm2["Casper"] = "casper";
})(ConsensusAlgorithm || (ConsensusAlgorithm = {}));
var CustomChain;
(function(CustomChain2) {
  CustomChain2["PolygonMainnet"] = "polygon-mainnet";
  CustomChain2["PolygonMumbai"] = "polygon-mumbai";
  CustomChain2["ArbitrumRinkebyTestnet"] = "arbitrum-rinkeby-testnet";
  CustomChain2["ArbitrumOne"] = "arbitrum-one";
  CustomChain2["xDaiChain"] = "x-dai-chain";
  CustomChain2["OptimisticKovan"] = "optimistic-kovan";
  CustomChain2["OptimisticEthereum"] = "optimistic-ethereum";
})(CustomChain || (CustomChain = {}));

// node_modules/web3-eth-accounts/lib/esm/common/types.js
var TypeOutput;
(function(TypeOutput2) {
  TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
  TypeOutput2[TypeOutput2["BigInt"] = 1] = "BigInt";
  TypeOutput2[TypeOutput2["Uint8Array"] = 2] = "Uint8Array";
  TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
})(TypeOutput || (TypeOutput = {}));

// node_modules/web3-eth-accounts/lib/esm/common/utils.js
var formatNonce = function(nonce) {
  if (!nonce || nonce === "0x0") {
    return "0x0000000000000000";
  }
  if (isHexPrefixed(nonce)) {
    return `0x${stripHexPrefix(nonce).padStart(16, "0")}`;
  }
  return `0x${nonce.padStart(16, "0")}`;
};
var parseGethParams = function(json, mergeForkIdPostMerge = true) {
  var _a3, _b;
  const { name, config: config2, difficulty, mixHash, gasLimit, coinbase, baseFeePerGas } = json;
  let { extraData, timestamp, nonce } = json;
  const genesisTimestamp = Number(timestamp);
  const { chainId } = config2;
  if (extraData === "") {
    extraData = "0x";
  }
  if (!isHexPrefixed(timestamp)) {
    timestamp = intToHex(parseInt(timestamp));
  }
  if (nonce.length !== 18) {
    nonce = formatNonce(nonce);
  }
  if (config2.eip155Block !== config2.eip158Block) {
    throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");
  }
  const params = {
    name,
    chainId,
    networkId: chainId,
    genesis: {
      timestamp,
      gasLimit: parseInt(gasLimit),
      difficulty: parseInt(difficulty),
      nonce,
      extraData,
      mixHash,
      coinbase,
      baseFeePerGas
    },
    hardfork: undefined,
    hardforks: [],
    bootstrapNodes: [],
    consensus: config2.clique !== undefined ? {
      type: "poa",
      algorithm: "clique",
      clique: {
        period: (_a3 = config2.clique.period) !== null && _a3 !== undefined ? _a3 : config2.clique.blockperiodseconds,
        epoch: (_b = config2.clique.epoch) !== null && _b !== undefined ? _b : config2.clique.epochlength
      }
    } : {
      type: "pow",
      algorithm: "ethash",
      ethash: {}
    }
  };
  const forkMap = {
    [Hardfork.Homestead]: { name: "homesteadBlock" },
    [Hardfork.Dao]: { name: "daoForkBlock" },
    [Hardfork.TangerineWhistle]: { name: "eip150Block" },
    [Hardfork.SpuriousDragon]: { name: "eip155Block" },
    [Hardfork.Byzantium]: { name: "byzantiumBlock" },
    [Hardfork.Constantinople]: { name: "constantinopleBlock" },
    [Hardfork.Petersburg]: { name: "petersburgBlock" },
    [Hardfork.Istanbul]: { name: "istanbulBlock" },
    [Hardfork.MuirGlacier]: { name: "muirGlacierBlock" },
    [Hardfork.Berlin]: { name: "berlinBlock" },
    [Hardfork.London]: { name: "londonBlock" },
    [Hardfork.MergeForkIdTransition]: {
      name: "mergeForkBlock",
      postMerge: mergeForkIdPostMerge
    },
    [Hardfork.Shanghai]: { name: "shanghaiTime", postMerge: true, isTimestamp: true },
    [Hardfork.ShardingForkDev]: {
      name: "shardingForkTime",
      postMerge: true,
      isTimestamp: true
    }
  };
  const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {
    acc[forkMap[elem].name] = elem;
    return acc;
  }, {});
  const configHardforkNames = Object.keys(config2).filter((key) => forkMapRev[key] !== undefined && config2[key] !== undefined && config2[key] !== null);
  params.hardforks = configHardforkNames.map((nameBlock) => ({
    name: forkMapRev[nameBlock],
    block: forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config2[nameBlock] !== "number" ? null : config2[nameBlock],
    timestamp: forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config2[nameBlock] === "number" ? config2[nameBlock] : undefined
  })).filter((fork) => fork.block !== null || fork.timestamp !== undefined);
  params.hardforks.sort((a, b) => {
    var _a4, _b2;
    return ((_a4 = a.block) !== null && _a4 !== undefined ? _a4 : Infinity) - ((_b2 = b.block) !== null && _b2 !== undefined ? _b2 : Infinity);
  });
  params.hardforks.sort((a, b) => {
    var _a4, _b2;
    return ((_a4 = a.timestamp) !== null && _a4 !== undefined ? _a4 : genesisTimestamp) - ((_b2 = b.timestamp) !== null && _b2 !== undefined ? _b2 : genesisTimestamp);
  });
  if (config2.terminalTotalDifficulty !== undefined) {
    const mergeConfig = {
      name: Hardfork.Merge,
      ttd: config2.terminalTotalDifficulty,
      block: null
    };
    const postMergeIndex = params.hardforks.findIndex((hf) => {
      var _a4;
      return ((_a4 = forkMap[hf.name]) === null || _a4 === undefined ? undefined : _a4.postMerge) === true;
    });
    if (postMergeIndex !== -1) {
      params.hardforks.splice(postMergeIndex, 0, mergeConfig);
    } else {
      params.hardforks.push(mergeConfig);
    }
  }
  const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : undefined;
  params.hardfork = latestHardfork === null || latestHardfork === undefined ? undefined : latestHardfork.name;
  params.hardforks.unshift({ name: Hardfork.Chainstart, block: 0 });
  return params;
};
function parseGethGenesis(json, name, mergeForkIdPostMerge) {
  try {
    if (["config", "difficulty", "gasLimit", "alloc"].some((field) => !(field in json))) {
      throw new Error("Invalid format, expected geth genesis fields missing");
    }
    if (name !== undefined) {
      json.name = name;
    }
    return parseGethParams(json, mergeForkIdPostMerge);
  } catch (e) {
    throw new Error(`Error parsing parameters file: ${e.message}`);
  }
}
function padToEven(value) {
  let a = value;
  if (typeof a !== "string") {
    throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
  }
  if (a.length % 2)
    a = `0${a}`;
  return a;
}
function uint8ArrayToBigInt(buf) {
  const hex = bytesToHex2(buf);
  if (hex === "0x") {
    return BigInt(0);
  }
  return BigInt(hex);
}
function bigIntToUint8Array(num) {
  return toUint8Array(`0x${num.toString(16)}`);
}
function assertIsUint8Array(input) {
  if (!isUint8Array2(input)) {
    const msg = `This method only supports Uint8Array but input was: ${input}`;
    throw new Error(msg);
  }
}
function stripZeros(a) {
  let first = a[0];
  while (a.length > 0 && first.toString() === "0") {
    a = a.slice(1);
    first = a[0];
  }
  return a;
}
function bigIntToUnpaddedUint8Array(value) {
  return unpadUint8Array(bigIntToUint8Array(value));
}
var calculateSigRecovery = function(v, chainId) {
  if (v === BigInt(0) || v === BigInt(1))
    return v;
  if (chainId === undefined) {
    return v - BigInt(27);
  }
  return v - (chainId * BigInt(2) + BigInt(35));
};
var isValidSigRecovery = function(recovery) {
  return recovery === BigInt(0) || recovery === BigInt(1);
};
function toType(input, outputType) {
  if (input === null) {
    return null;
  }
  if (input === undefined) {
    return;
  }
  if (typeof input === "string" && !isHexString(input)) {
    throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
  } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
    throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
  }
  const output2 = toUint8Array(input);
  switch (outputType) {
    case TypeOutput.Uint8Array:
      return output2;
    case TypeOutput.BigInt:
      return uint8ArrayToBigInt(output2);
    case TypeOutput.Number: {
      const bigInt = uint8ArrayToBigInt(output2);
      if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
      }
      return Number(bigInt);
    }
    case TypeOutput.PrefixedHexString:
      return bytesToHex2(output2);
    default:
      throw new Error("unknown outputType");
  }
}
var stripHexPrefix = (str) => {
  if (typeof str !== "string")
    throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
  return isHexPrefixed(str) ? str.slice(2) : str;
};
var intToHex = function(i) {
  if (!Number.isSafeInteger(i) || i < 0) {
    throw new Error(`Received an invalid integer type: ${i}`);
  }
  return `0x${i.toString(16)}`;
};
var intToUint8Array = function(i) {
  const hex = intToHex(i);
  return hexToBytes(`0x${padToEven(hex.slice(2))}`);
};
var toUint8Array = function(v) {
  var _a3;
  if (v === null || v === undefined) {
    return new Uint8Array;
  }
  if (v instanceof Uint8Array) {
    return v;
  }
  if (((_a3 = v === null || v === undefined ? undefined : v.constructor) === null || _a3 === undefined ? undefined : _a3.name) === "Uint8Array") {
    return Uint8Array.from(v);
  }
  if (Array.isArray(v)) {
    return Uint8Array.from(v);
  }
  if (typeof v === "string") {
    if (!isHexString(v)) {
      throw new Error(`Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: ${v}`);
    }
    return hexToBytes(padToEven(stripHexPrefix(v)));
  }
  if (typeof v === "number") {
    return toUint8Array(numberToHex2(v));
  }
  if (typeof v === "bigint") {
    if (v < BigInt(0)) {
      throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${v}`);
    }
    let n = v.toString(16);
    if (n.length % 2)
      n = `0${n}`;
    return toUint8Array(`0x${n}`);
  }
  if (v.toArray) {
    return Uint8Array.from(v.toArray());
  }
  throw new Error("invalid type");
};
var zeros = function(bytes5) {
  return new Uint8Array(bytes5).fill(0);
};
var setLength = function(msg, length, right) {
  const buf = zeros(length);
  if (right) {
    if (msg.length < length) {
      buf.set(msg);
      return buf;
    }
    return msg.subarray(0, length);
  }
  if (msg.length < length) {
    buf.set(msg, length - msg.length);
    return buf;
  }
  return msg.subarray(-length);
};
var setLengthLeft = function(msg, length) {
  assertIsUint8Array(msg);
  return setLength(msg, length, false);
};
var unpadUint8Array = function(a) {
  assertIsUint8Array(a);
  return stripZeros(a);
};
var bigIntToHex = (num) => `0x${num.toString(16)}`;
var ecrecover = function(msgHash, v, r, s, chainId) {
  const recovery = calculateSigRecovery(v, chainId);
  if (!isValidSigRecovery(recovery)) {
    throw new Error("Invalid signature v value");
  }
  const senderPubKey = new secp256k12.Signature(uint8ArrayToBigInt(r), uint8ArrayToBigInt(s)).addRecoveryBit(Number(recovery)).recoverPublicKey(msgHash).toRawBytes(false);
  return senderPubKey.slice(1);
};

// node_modules/web3-eth-accounts/lib/esm/tx/eip1559Transaction.js
var rlp = __toESM(require_dist(), 1);

// node_modules/web3-eth-accounts/lib/esm/common/common.js
var import_crc_32 = __toESM(require_crc32(), 1);

// node_modules/web3-eth-accounts/lib/esm/common/chains/goerli.js
var goerli_default = {
  name: "goerli",
  chainId: 5,
  networkId: 5,
  defaultHardfork: "merge",
  consensus: {
    type: "poa",
    algorithm: "clique",
    clique: {
      period: 15,
      epoch: 30000
    }
  },
  comment: "Cross-client PoA test network",
  url: "https://github.com/goerli/testnet",
  genesis: {
    timestamp: "0x5c51a607",
    gasLimit: 10485760,
    difficulty: 1,
    nonce: "0x0000000000000000",
    extraData: "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
  },
  hardforks: [
    {
      name: "chainstart",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "homestead",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "tangerineWhistle",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "spuriousDragon",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "byzantium",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "constantinople",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "petersburg",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "istanbul",
      block: 1561651,
      forkHash: "0xc25efa5c"
    },
    {
      name: "berlin",
      block: 4460644,
      forkHash: "0x757a1c47"
    },
    {
      name: "london",
      block: 5062605,
      forkHash: "0xb8c6299d"
    },
    {
      "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",
      name: "merge",
      ttd: "10790000",
      block: 7382819,
      forkHash: "0xb8c6299d"
    },
    {
      name: "mergeForkIdTransition",
      block: null,
      forkHash: null
    },
    {
      name: "shanghai",
      block: null,
      forkHash: null
    }
  ],
  bootstrapNodes: [],
  dnsNetworks: [
    "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"
  ]
};

// node_modules/web3-eth-accounts/lib/esm/common/chains/mainnet.js
var mainnet_default = {
  name: "mainnet",
  chainId: 1,
  networkId: 1,
  defaultHardfork: "merge",
  consensus: {
    type: "pow",
    algorithm: "ethash",
    ethash: {}
  },
  comment: "The Ethereum main chain",
  url: "https://ethstats.net/",
  genesis: {
    gasLimit: 5000,
    difficulty: 17179869184,
    nonce: "0x0000000000000042",
    extraData: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"
  },
  hardforks: [
    {
      name: "chainstart",
      block: 0,
      forkHash: "0xfc64ec04"
    },
    {
      name: "homestead",
      block: 1150000,
      forkHash: "0x97c2c34c"
    },
    {
      name: "dao",
      block: 1920000,
      forkHash: "0x91d1f948"
    },
    {
      name: "tangerineWhistle",
      block: 2463000,
      forkHash: "0x7a64da13"
    },
    {
      name: "spuriousDragon",
      block: 2675000,
      forkHash: "0x3edd5b10"
    },
    {
      name: "byzantium",
      block: 4370000,
      forkHash: "0xa00bc324"
    },
    {
      name: "constantinople",
      block: 7280000,
      forkHash: "0x668db0af"
    },
    {
      name: "petersburg",
      block: 7280000,
      forkHash: "0x668db0af"
    },
    {
      name: "istanbul",
      block: 9069000,
      forkHash: "0x879d6e30"
    },
    {
      name: "muirGlacier",
      block: 9200000,
      forkHash: "0xe029e991"
    },
    {
      name: "berlin",
      block: 12244000,
      forkHash: "0x0eb440f6"
    },
    {
      name: "london",
      block: 12965000,
      forkHash: "0xb715077d"
    },
    {
      name: "arrowGlacier",
      block: 13773000,
      forkHash: "0x20c327fc"
    },
    {
      name: "grayGlacier",
      block: 15050000,
      forkHash: "0xf0afd0e3"
    },
    {
      "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",
      name: "merge",
      ttd: "58750000000000000000000",
      block: 15537394,
      forkHash: "0xf0afd0e3"
    },
    {
      name: "mergeForkIdTransition",
      block: null,
      forkHash: null
    },
    {
      name: "shanghai",
      block: null,
      forkHash: null
    }
  ],
  bootstrapNodes: [],
  dnsNetworks: [
    "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"
  ]
};

// node_modules/web3-eth-accounts/lib/esm/common/chains/sepolia.js
var sepolia_default = {
  name: "sepolia",
  chainId: 11155111,
  networkId: 11155111,
  defaultHardfork: "merge",
  consensus: {
    type: "pow",
    algorithm: "ethash",
    ethash: {}
  },
  comment: "PoW test network to replace Ropsten",
  url: "https://github.com/ethereum/go-ethereum/pull/23730",
  genesis: {
    timestamp: "0x6159af19",
    gasLimit: 30000000,
    difficulty: 131072,
    nonce: "0x0000000000000000",
    extraData: "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"
  },
  hardforks: [
    {
      name: "chainstart",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "homestead",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "tangerineWhistle",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "spuriousDragon",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "byzantium",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "constantinople",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "petersburg",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "istanbul",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "muirGlacier",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "berlin",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "london",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",
      name: "merge",
      ttd: "17000000000000000",
      block: 1450409,
      forkHash: "0xfe3366e7"
    },
    {
      name: "mergeForkIdTransition",
      block: 1735371,
      forkHash: "0xb96cbd13"
    },
    {
      name: "shanghai",
      block: null,
      timestamp: "1677557088",
      forkHash: "0xf7f9bc08"
    }
  ],
  bootstrapNodes: [],
  dnsNetworks: [
    "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"
  ]
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/1153.js
var _1153_default = {
  name: "EIP-1153",
  number: 1153,
  comment: "Transient Storage",
  url: "https://eips.ethereum.org/EIPS/eip-1153",
  status: "Review",
  minimumHardfork: "chainstart",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {
    tstore: {
      v: 100,
      d: "Base fee of the TSTORE opcode"
    },
    tload: {
      v: 100,
      d: "Base fee of the TLOAD opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/1559.js
var _1559_default = {
  name: "EIP-1559",
  number: 1559,
  comment: "Fee market change for ETH 1.0 chain",
  url: "https://eips.ethereum.org/EIPS/eip-1559",
  status: "Final",
  minimumHardfork: "berlin",
  requiredEIPs: [2930],
  gasConfig: {
    baseFeeMaxChangeDenominator: {
      v: 8,
      d: "Maximum base fee change denominator"
    },
    elasticityMultiplier: {
      v: 2,
      d: "Maximum block gas target elasticity"
    },
    initialBaseFee: {
      v: 1e9,
      d: "Initial base fee on first EIP1559 block"
    }
  },
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2315.js
var _2315_default = {
  name: "EIP-2315",
  number: 2315,
  comment: "Simple subroutines for the EVM",
  url: "https://eips.ethereum.org/EIPS/eip-2315",
  status: "Draft",
  minimumHardfork: "istanbul",
  gasConfig: {},
  gasPrices: {
    beginsub: {
      v: 2,
      d: "Base fee of the BEGINSUB opcode"
    },
    returnsub: {
      v: 5,
      d: "Base fee of the RETURNSUB opcode"
    },
    jumpsub: {
      v: 10,
      d: "Base fee of the JUMPSUB opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2537.js
var _2537_default = {
  name: "EIP-2537",
  number: 2537,
  comment: "BLS12-381 precompiles",
  url: "https://eips.ethereum.org/EIPS/eip-2537",
  status: "Draft",
  minimumHardfork: "chainstart",
  gasConfig: {},
  gasPrices: {
    Bls12381G1AddGas: {
      v: 600,
      d: "Gas cost of a single BLS12-381 G1 addition precompile-call"
    },
    Bls12381G1MulGas: {
      v: 12000,
      d: "Gas cost of a single BLS12-381 G1 multiplication precompile-call"
    },
    Bls12381G2AddGas: {
      v: 4500,
      d: "Gas cost of a single BLS12-381 G2 addition precompile-call"
    },
    Bls12381G2MulGas: {
      v: 55000,
      d: "Gas cost of a single BLS12-381 G2 multiplication precompile-call"
    },
    Bls12381PairingBaseGas: {
      v: 115000,
      d: "Base gas cost of BLS12-381 pairing check"
    },
    Bls12381PairingPerPairGas: {
      v: 23000,
      d: "Per-pair gas cost of BLS12-381 pairing check"
    },
    Bls12381MapG1Gas: {
      v: 5500,
      d: "Gas cost of BLS12-381 map field element to G1"
    },
    Bls12381MapG2Gas: {
      v: 110000,
      d: "Gas cost of BLS12-381 map field element to G2"
    },
    Bls12381MultiExpGasDiscount: {
      v: [
        [1, 1200],
        [2, 888],
        [3, 764],
        [4, 641],
        [5, 594],
        [6, 547],
        [7, 500],
        [8, 453],
        [9, 438],
        [10, 423],
        [11, 408],
        [12, 394],
        [13, 379],
        [14, 364],
        [15, 349],
        [16, 334],
        [17, 330],
        [18, 326],
        [19, 322],
        [20, 318],
        [21, 314],
        [22, 310],
        [23, 306],
        [24, 302],
        [25, 298],
        [26, 294],
        [27, 289],
        [28, 285],
        [29, 281],
        [30, 277],
        [31, 273],
        [32, 269],
        [33, 268],
        [34, 266],
        [35, 265],
        [36, 263],
        [37, 262],
        [38, 260],
        [39, 259],
        [40, 257],
        [41, 256],
        [42, 254],
        [43, 253],
        [44, 251],
        [45, 250],
        [46, 248],
        [47, 247],
        [48, 245],
        [49, 244],
        [50, 242],
        [51, 241],
        [52, 239],
        [53, 238],
        [54, 236],
        [55, 235],
        [56, 233],
        [57, 232],
        [58, 231],
        [59, 229],
        [60, 228],
        [61, 226],
        [62, 225],
        [63, 223],
        [64, 222],
        [65, 221],
        [66, 220],
        [67, 219],
        [68, 219],
        [69, 218],
        [70, 217],
        [71, 216],
        [72, 216],
        [73, 215],
        [74, 214],
        [75, 213],
        [76, 213],
        [77, 212],
        [78, 211],
        [79, 211],
        [80, 210],
        [81, 209],
        [82, 208],
        [83, 208],
        [84, 207],
        [85, 206],
        [86, 205],
        [87, 205],
        [88, 204],
        [89, 203],
        [90, 202],
        [91, 202],
        [92, 201],
        [93, 200],
        [94, 199],
        [95, 199],
        [96, 198],
        [97, 197],
        [98, 196],
        [99, 196],
        [100, 195],
        [101, 194],
        [102, 193],
        [103, 193],
        [104, 192],
        [105, 191],
        [106, 191],
        [107, 190],
        [108, 189],
        [109, 188],
        [110, 188],
        [111, 187],
        [112, 186],
        [113, 185],
        [114, 185],
        [115, 184],
        [116, 183],
        [117, 182],
        [118, 182],
        [119, 181],
        [120, 180],
        [121, 179],
        [122, 179],
        [123, 178],
        [124, 177],
        [125, 176],
        [126, 176],
        [127, 175],
        [128, 174]
      ],
      d: "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2565.js
var _2565_default = {
  name: "EIP-2565",
  number: 2565,
  comment: "ModExp gas cost",
  url: "https://eips.ethereum.org/EIPS/eip-2565",
  status: "Final",
  minimumHardfork: "byzantium",
  gasConfig: {},
  gasPrices: {
    modexpGquaddivisor: {
      v: 3,
      d: "Gquaddivisor from modexp precompile for gas calculation"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2718.js
var _2718_default = {
  name: "EIP-2718",
  comment: "Typed Transaction Envelope",
  url: "https://eips.ethereum.org/EIPS/eip-2718",
  status: "Final",
  minimumHardfork: "chainstart",
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2929.js
var _2929_default = {
  name: "EIP-2929",
  comment: "Gas cost increases for state access opcodes",
  url: "https://eips.ethereum.org/EIPS/eip-2929",
  status: "Final",
  minimumHardfork: "chainstart",
  gasConfig: {},
  gasPrices: {
    coldsload: {
      v: 2100,
      d: "Gas cost of the first read of storage from a given location (per transaction)"
    },
    coldaccountaccess: {
      v: 2600,
      d: "Gas cost of the first read of a given address (per transaction)"
    },
    warmstorageread: {
      v: 100,
      d: "Gas cost of reading storage locations which have already loaded 'cold'"
    },
    sstoreCleanGasEIP2200: {
      v: 2900,
      d: "Once per SSTORE operation from clean non-zero to something else"
    },
    sstoreNoopGasEIP2200: {
      v: 100,
      d: "Once per SSTORE operation if the value doesn't change"
    },
    sstoreDirtyGasEIP2200: {
      v: 100,
      d: "Once per SSTORE operation if a dirty value is changed"
    },
    sstoreInitRefundEIP2200: {
      v: 19900,
      d: "Once per SSTORE operation for resetting to the original zero value"
    },
    sstoreCleanRefundEIP2200: {
      v: 4900,
      d: "Once per SSTORE operation for resetting to the original non-zero value"
    },
    call: {
      v: 0,
      d: "Base fee of the CALL opcode"
    },
    callcode: {
      v: 0,
      d: "Base fee of the CALLCODE opcode"
    },
    delegatecall: {
      v: 0,
      d: "Base fee of the DELEGATECALL opcode"
    },
    staticcall: {
      v: 0,
      d: "Base fee of the STATICCALL opcode"
    },
    balance: {
      v: 0,
      d: "Base fee of the BALANCE opcode"
    },
    extcodesize: {
      v: 0,
      d: "Base fee of the EXTCODESIZE opcode"
    },
    extcodecopy: {
      v: 0,
      d: "Base fee of the EXTCODECOPY opcode"
    },
    extcodehash: {
      v: 0,
      d: "Base fee of the EXTCODEHASH opcode"
    },
    sload: {
      v: 0,
      d: "Base fee of the SLOAD opcode"
    },
    sstore: {
      v: 0,
      d: "Base fee of the SSTORE opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2930.js
var _2930_default = {
  name: "EIP-2930",
  comment: "Optional access lists",
  url: "https://eips.ethereum.org/EIPS/eip-2930",
  status: "Final",
  minimumHardfork: "istanbul",
  requiredEIPs: [2718, 2929],
  gasConfig: {},
  gasPrices: {
    accessListStorageKeyCost: {
      v: 1900,
      d: "Gas cost per storage key in an Access List transaction"
    },
    accessListAddressCost: {
      v: 2400,
      d: "Gas cost per storage key in an Access List transaction"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3198.js
var _3198_default = {
  name: "EIP-3198",
  number: 3198,
  comment: "BASEFEE opcode",
  url: "https://eips.ethereum.org/EIPS/eip-3198",
  status: "Final",
  minimumHardfork: "london",
  gasConfig: {},
  gasPrices: {
    basefee: {
      v: 2,
      d: "Gas cost of the BASEFEE opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3529.js
var _3529_default = {
  name: "EIP-3529",
  comment: "Reduction in refunds",
  url: "https://eips.ethereum.org/EIPS/eip-3529",
  status: "Final",
  minimumHardfork: "berlin",
  requiredEIPs: [2929],
  gasConfig: {
    maxRefundQuotient: {
      v: 5,
      d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
    }
  },
  gasPrices: {
    selfdestructRefund: {
      v: 0,
      d: "Refunded following a selfdestruct operation"
    },
    sstoreClearRefundEIP2200: {
      v: 4800,
      d: "Once per SSTORE operation for clearing an originally existing storage slot"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3540.js
var _3540_default = {
  name: "EIP-3540",
  number: 3540,
  comment: "EVM Object Format (EOF) v1",
  url: "https://eips.ethereum.org/EIPS/eip-3540",
  status: "Review",
  minimumHardfork: "london",
  requiredEIPs: [3541],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3541.js
var _3541_default = {
  name: "EIP-3541",
  comment: "Reject new contracts starting with the 0xEF byte",
  url: "https://eips.ethereum.org/EIPS/eip-3541",
  status: "Final",
  minimumHardfork: "berlin",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3554.js
var _3554_default = {
  name: "EIP-3554",
  comment: "Reduction in refunds",
  url: "Difficulty Bomb Delay to December 1st 2021",
  status: "Final",
  minimumHardfork: "muirGlacier",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {
    difficultyBombDelay: {
      v: 9500000,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3607.js
var _3607_default = {
  name: "EIP-3607",
  number: 3607,
  comment: "Reject transactions from senders with deployed code",
  url: "https://eips.ethereum.org/EIPS/eip-3607",
  status: "Final",
  minimumHardfork: "chainstart",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3651.js
var _3651_default = {
  name: "EIP-3651",
  number: 3198,
  comment: "Warm COINBASE",
  url: "https://eips.ethereum.org/EIPS/eip-3651",
  status: "Review",
  minimumHardfork: "london",
  requiredEIPs: [2929],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3670.js
var _3670_default = {
  name: "EIP-3670",
  number: 3670,
  comment: "EOF - Code Validation",
  url: "https://eips.ethereum.org/EIPS/eip-3670",
  status: "Review",
  minimumHardfork: "london",
  requiredEIPs: [3540],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3675.js
var _3675_default = {
  name: "EIP-3675",
  number: 3675,
  comment: "Upgrade consensus to Proof-of-Stake",
  url: "https://eips.ethereum.org/EIPS/eip-3675",
  status: "Final",
  minimumHardfork: "london",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3855.js
var _3855_default = {
  name: "EIP-3855",
  number: 3855,
  comment: "PUSH0 instruction",
  url: "https://eips.ethereum.org/EIPS/eip-3855",
  status: "Review",
  minimumHardfork: "chainstart",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {
    push0: {
      v: 2,
      d: "Base fee of the PUSH0 opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3860.js
var _3860_default = {
  name: "EIP-3860",
  number: 3860,
  comment: "Limit and meter initcode",
  url: "https://eips.ethereum.org/EIPS/eip-3860",
  status: "Review",
  minimumHardfork: "spuriousDragon",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {
    initCodeWordCost: {
      v: 2,
      d: "Gas to pay for each word (32 bytes) of initcode when creating a contract"
    }
  },
  vm: {
    maxInitCodeSize: {
      v: 49152,
      d: "Maximum length of initialization code when creating a contract"
    }
  },
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/4345.js
var _4345_default = {
  name: "EIP-4345",
  number: 4345,
  comment: "Difficulty Bomb Delay to June 2022",
  url: "https://eips.ethereum.org/EIPS/eip-4345",
  status: "Final",
  minimumHardfork: "london",
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {
    difficultyBombDelay: {
      v: 10700000,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/4399.js
var _4399_default = {
  name: "EIP-4399",
  number: 4399,
  comment: "Supplant DIFFICULTY opcode with PREVRANDAO",
  url: "https://eips.ethereum.org/EIPS/eip-4399",
  status: "Review",
  minimumHardfork: "london",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/5133.js
var _5133_default = {
  name: "EIP-5133",
  number: 5133,
  comment: "Delaying Difficulty Bomb to mid-September 2022",
  url: "https://eips.ethereum.org/EIPS/eip-5133",
  status: "Draft",
  minimumHardfork: "grayGlacier",
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {
    difficultyBombDelay: {
      v: 11400000,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/index.js
var EIPs = {
  1153: _1153_default,
  1559: _1559_default,
  2315: _2315_default,
  2537: _2537_default,
  2565: _2565_default,
  2718: _2718_default,
  2929: _2929_default,
  2930: _2930_default,
  3198: _3198_default,
  3529: _3529_default,
  3540: _3540_default,
  3541: _3541_default,
  3554: _3554_default,
  3607: _3607_default,
  3651: _3651_default,
  3670: _3670_default,
  3675: _3675_default,
  3855: _3855_default,
  3860: _3860_default,
  4345: _4345_default,
  4399: _4399_default,
  5133: _5133_default
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/chainstart.js
var chainstart_default = {
  name: "chainstart",
  comment: "Start of the Ethereum main chain",
  url: "",
  status: "",
  gasConfig: {
    minGasLimit: {
      v: 5000,
      d: "Minimum the gas limit may ever be"
    },
    gasLimitBoundDivisor: {
      v: 1024,
      d: "The bound divisor of the gas limit, used in update calculations"
    },
    maxRefundQuotient: {
      v: 2,
      d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
    }
  },
  gasPrices: {
    base: {
      v: 2,
      d: "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
    },
    tierStep: {
      v: [0, 2, 3, 5, 8, 10, 20],
      d: "Once per operation, for a selection of them"
    },
    exp: {
      v: 10,
      d: "Base fee of the EXP opcode"
    },
    expByte: {
      v: 10,
      d: "Times ceil(log256(exponent)) for the EXP instruction"
    },
    sha3: {
      v: 30,
      d: "Base fee of the SHA3 opcode"
    },
    sha3Word: {
      v: 6,
      d: "Once per word of the SHA3 operation's data"
    },
    sload: {
      v: 50,
      d: "Base fee of the SLOAD opcode"
    },
    sstoreSet: {
      v: 20000,
      d: "Once per SSTORE operation if the zeroness changes from zero"
    },
    sstoreReset: {
      v: 5000,
      d: "Once per SSTORE operation if the zeroness does not change from zero"
    },
    sstoreRefund: {
      v: 15000,
      d: "Once per SSTORE operation if the zeroness changes to zero"
    },
    jumpdest: {
      v: 1,
      d: "Base fee of the JUMPDEST opcode"
    },
    log: {
      v: 375,
      d: "Base fee of the LOG opcode"
    },
    logData: {
      v: 8,
      d: "Per byte in a LOG* operation's data"
    },
    logTopic: {
      v: 375,
      d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
    },
    create: {
      v: 32000,
      d: "Base fee of the CREATE opcode"
    },
    call: {
      v: 40,
      d: "Base fee of the CALL opcode"
    },
    callStipend: {
      v: 2300,
      d: "Free gas given at beginning of call"
    },
    callValueTransfer: {
      v: 9000,
      d: "Paid for CALL when the value transfor is non-zero"
    },
    callNewAccount: {
      v: 25000,
      d: "Paid for CALL when the destination address didn't exist prior"
    },
    selfdestructRefund: {
      v: 24000,
      d: "Refunded following a selfdestruct operation"
    },
    memory: {
      v: 3,
      d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
    },
    quadCoeffDiv: {
      v: 512,
      d: "Divisor for the quadratic particle of the memory cost equation"
    },
    createData: {
      v: 200,
      d: ""
    },
    tx: {
      v: 21000,
      d: "Per transaction. NOTE: Not payable on data of calls between transactions"
    },
    txCreation: {
      v: 32000,
      d: "The cost of creating a contract via tx"
    },
    txDataZero: {
      v: 4,
      d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
    },
    txDataNonZero: {
      v: 68,
      d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
    },
    copy: {
      v: 3,
      d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
    },
    ecRecover: {
      v: 3000,
      d: ""
    },
    sha256: {
      v: 60,
      d: ""
    },
    sha256Word: {
      v: 12,
      d: ""
    },
    ripemd160: {
      v: 600,
      d: ""
    },
    ripemd160Word: {
      v: 120,
      d: ""
    },
    identity: {
      v: 15,
      d: ""
    },
    identityWord: {
      v: 3,
      d: ""
    },
    stop: {
      v: 0,
      d: "Base fee of the STOP opcode"
    },
    add: {
      v: 3,
      d: "Base fee of the ADD opcode"
    },
    mul: {
      v: 5,
      d: "Base fee of the MUL opcode"
    },
    sub: {
      v: 3,
      d: "Base fee of the SUB opcode"
    },
    div: {
      v: 5,
      d: "Base fee of the DIV opcode"
    },
    sdiv: {
      v: 5,
      d: "Base fee of the SDIV opcode"
    },
    mod: {
      v: 5,
      d: "Base fee of the MOD opcode"
    },
    smod: {
      v: 5,
      d: "Base fee of the SMOD opcode"
    },
    addmod: {
      v: 8,
      d: "Base fee of the ADDMOD opcode"
    },
    mulmod: {
      v: 8,
      d: "Base fee of the MULMOD opcode"
    },
    signextend: {
      v: 5,
      d: "Base fee of the SIGNEXTEND opcode"
    },
    lt: {
      v: 3,
      d: "Base fee of the LT opcode"
    },
    gt: {
      v: 3,
      d: "Base fee of the GT opcode"
    },
    slt: {
      v: 3,
      d: "Base fee of the SLT opcode"
    },
    sgt: {
      v: 3,
      d: "Base fee of the SGT opcode"
    },
    eq: {
      v: 3,
      d: "Base fee of the EQ opcode"
    },
    iszero: {
      v: 3,
      d: "Base fee of the ISZERO opcode"
    },
    and: {
      v: 3,
      d: "Base fee of the AND opcode"
    },
    or: {
      v: 3,
      d: "Base fee of the OR opcode"
    },
    xor: {
      v: 3,
      d: "Base fee of the XOR opcode"
    },
    not: {
      v: 3,
      d: "Base fee of the NOT opcode"
    },
    byte: {
      v: 3,
      d: "Base fee of the BYTE opcode"
    },
    address: {
      v: 2,
      d: "Base fee of the ADDRESS opcode"
    },
    balance: {
      v: 20,
      d: "Base fee of the BALANCE opcode"
    },
    origin: {
      v: 2,
      d: "Base fee of the ORIGIN opcode"
    },
    caller: {
      v: 2,
      d: "Base fee of the CALLER opcode"
    },
    callvalue: {
      v: 2,
      d: "Base fee of the CALLVALUE opcode"
    },
    calldataload: {
      v: 3,
      d: "Base fee of the CALLDATALOAD opcode"
    },
    calldatasize: {
      v: 2,
      d: "Base fee of the CALLDATASIZE opcode"
    },
    calldatacopy: {
      v: 3,
      d: "Base fee of the CALLDATACOPY opcode"
    },
    codesize: {
      v: 2,
      d: "Base fee of the CODESIZE opcode"
    },
    codecopy: {
      v: 3,
      d: "Base fee of the CODECOPY opcode"
    },
    gasprice: {
      v: 2,
      d: "Base fee of the GASPRICE opcode"
    },
    extcodesize: {
      v: 20,
      d: "Base fee of the EXTCODESIZE opcode"
    },
    extcodecopy: {
      v: 20,
      d: "Base fee of the EXTCODECOPY opcode"
    },
    blockhash: {
      v: 20,
      d: "Base fee of the BLOCKHASH opcode"
    },
    coinbase: {
      v: 2,
      d: "Base fee of the COINBASE opcode"
    },
    timestamp: {
      v: 2,
      d: "Base fee of the TIMESTAMP opcode"
    },
    number: {
      v: 2,
      d: "Base fee of the NUMBER opcode"
    },
    difficulty: {
      v: 2,
      d: "Base fee of the DIFFICULTY opcode"
    },
    gaslimit: {
      v: 2,
      d: "Base fee of the GASLIMIT opcode"
    },
    pop: {
      v: 2,
      d: "Base fee of the POP opcode"
    },
    mload: {
      v: 3,
      d: "Base fee of the MLOAD opcode"
    },
    mstore: {
      v: 3,
      d: "Base fee of the MSTORE opcode"
    },
    mstore8: {
      v: 3,
      d: "Base fee of the MSTORE8 opcode"
    },
    sstore: {
      v: 0,
      d: "Base fee of the SSTORE opcode"
    },
    jump: {
      v: 8,
      d: "Base fee of the JUMP opcode"
    },
    jumpi: {
      v: 10,
      d: "Base fee of the JUMPI opcode"
    },
    pc: {
      v: 2,
      d: "Base fee of the PC opcode"
    },
    msize: {
      v: 2,
      d: "Base fee of the MSIZE opcode"
    },
    gas: {
      v: 2,
      d: "Base fee of the GAS opcode"
    },
    push: {
      v: 3,
      d: "Base fee of the PUSH opcode"
    },
    dup: {
      v: 3,
      d: "Base fee of the DUP opcode"
    },
    swap: {
      v: 3,
      d: "Base fee of the SWAP opcode"
    },
    callcode: {
      v: 40,
      d: "Base fee of the CALLCODE opcode"
    },
    return: {
      v: 0,
      d: "Base fee of the RETURN opcode"
    },
    invalid: {
      v: 0,
      d: "Base fee of the INVALID opcode"
    },
    selfdestruct: {
      v: 0,
      d: "Base fee of the SELFDESTRUCT opcode"
    }
  },
  vm: {
    stackLimit: {
      v: 1024,
      d: "Maximum size of VM stack allowed"
    },
    callCreateDepth: {
      v: 1024,
      d: "Maximum depth of call/create stack"
    },
    maxExtraDataSize: {
      v: 32,
      d: "Maximum size extra data may be after Genesis"
    }
  },
  pow: {
    minimumDifficulty: {
      v: 131072,
      d: "The minimum that the difficulty may ever be"
    },
    difficultyBoundDivisor: {
      v: 2048,
      d: "The bound divisor of the difficulty, used in the update calculations"
    },
    durationLimit: {
      v: 13,
      d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
    },
    epochDuration: {
      v: 30000,
      d: "Duration between proof-of-work epochs"
    },
    timebombPeriod: {
      v: 1e5,
      d: "Exponential difficulty timebomb period"
    },
    minerReward: {
      v: "5000000000000000000",
      d: "the amount a miner get rewarded for mining a block"
    },
    difficultyBombDelay: {
      v: 0,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/dao.js
var dao_default = {
  name: "dao",
  comment: "DAO rescue hardfork",
  url: "https://eips.ethereum.org/EIPS/eip-779",
  status: "Final",
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/homestead.js
var homestead_default = {
  name: "homestead",
  comment: "Homestead hardfork with protocol and network changes",
  url: "https://eips.ethereum.org/EIPS/eip-606",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    delegatecall: {
      v: 40,
      d: "Base fee of the DELEGATECALL opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/tangerineWhistle.js
var tangerineWhistle_default = {
  name: "tangerineWhistle",
  comment: "Hardfork with gas cost changes for IO-heavy operations",
  url: "https://eips.ethereum.org/EIPS/eip-608",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    sload: {
      v: 200,
      d: "Once per SLOAD operation"
    },
    call: {
      v: 700,
      d: "Once per CALL operation & message call transaction"
    },
    extcodesize: {
      v: 700,
      d: "Base fee of the EXTCODESIZE opcode"
    },
    extcodecopy: {
      v: 700,
      d: "Base fee of the EXTCODECOPY opcode"
    },
    balance: {
      v: 400,
      d: "Base fee of the BALANCE opcode"
    },
    delegatecall: {
      v: 700,
      d: "Base fee of the DELEGATECALL opcode"
    },
    callcode: {
      v: 700,
      d: "Base fee of the CALLCODE opcode"
    },
    selfdestruct: {
      v: 5000,
      d: "Base fee of the SELFDESTRUCT opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/spuriousDragon.js
var spuriousDragon_default = {
  name: "spuriousDragon",
  comment: "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
  url: "https://eips.ethereum.org/EIPS/eip-607",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    expByte: {
      v: 50,
      d: "Times ceil(log256(exponent)) for the EXP instruction"
    }
  },
  vm: {
    maxCodeSize: {
      v: 24576,
      d: "Maximum length of contract code"
    }
  },
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/byzantium.js
var byzantium_default = {
  name: "byzantium",
  comment: "Hardfork with new precompiles, instructions and other protocol changes",
  url: "https://eips.ethereum.org/EIPS/eip-609",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    modexpGquaddivisor: {
      v: 20,
      d: "Gquaddivisor from modexp precompile for gas calculation"
    },
    ecAdd: {
      v: 500,
      d: "Gas costs for curve addition precompile"
    },
    ecMul: {
      v: 40000,
      d: "Gas costs for curve multiplication precompile"
    },
    ecPairing: {
      v: 1e5,
      d: "Base gas costs for curve pairing precompile"
    },
    ecPairingWord: {
      v: 80000,
      d: "Gas costs regarding curve pairing precompile input length"
    },
    revert: {
      v: 0,
      d: "Base fee of the REVERT opcode"
    },
    staticcall: {
      v: 700,
      d: "Base fee of the STATICCALL opcode"
    },
    returndatasize: {
      v: 2,
      d: "Base fee of the RETURNDATASIZE opcode"
    },
    returndatacopy: {
      v: 3,
      d: "Base fee of the RETURNDATACOPY opcode"
    }
  },
  vm: {},
  pow: {
    minerReward: {
      v: "3000000000000000000",
      d: "the amount a miner get rewarded for mining a block"
    },
    difficultyBombDelay: {
      v: 3000000,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/constantinople.js
var constantinople_default = {
  name: "constantinople",
  comment: "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
  url: "https://eips.ethereum.org/EIPS/eip-1013",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    netSstoreNoopGas: {
      v: 200,
      d: "Once per SSTORE operation if the value doesn't change"
    },
    netSstoreInitGas: {
      v: 20000,
      d: "Once per SSTORE operation from clean zero"
    },
    netSstoreCleanGas: {
      v: 5000,
      d: "Once per SSTORE operation from clean non-zero"
    },
    netSstoreDirtyGas: {
      v: 200,
      d: "Once per SSTORE operation from dirty"
    },
    netSstoreClearRefund: {
      v: 15000,
      d: "Once per SSTORE operation for clearing an originally existing storage slot"
    },
    netSstoreResetRefund: {
      v: 4800,
      d: "Once per SSTORE operation for resetting to the original non-zero value"
    },
    netSstoreResetClearRefund: {
      v: 19800,
      d: "Once per SSTORE operation for resetting to the original zero value"
    },
    shl: {
      v: 3,
      d: "Base fee of the SHL opcode"
    },
    shr: {
      v: 3,
      d: "Base fee of the SHR opcode"
    },
    sar: {
      v: 3,
      d: "Base fee of the SAR opcode"
    },
    extcodehash: {
      v: 400,
      d: "Base fee of the EXTCODEHASH opcode"
    },
    create2: {
      v: 32000,
      d: "Base fee of the CREATE2 opcode"
    }
  },
  vm: {},
  pow: {
    minerReward: {
      v: "2000000000000000000",
      d: "The amount a miner gets rewarded for mining a block"
    },
    difficultyBombDelay: {
      v: 5000000,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/petersburg.js
var petersburg_default = {
  name: "petersburg",
  comment: "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
  url: "https://eips.ethereum.org/EIPS/eip-1716",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    netSstoreNoopGas: {
      v: null,
      d: "Removed along EIP-1283"
    },
    netSstoreInitGas: {
      v: null,
      d: "Removed along EIP-1283"
    },
    netSstoreCleanGas: {
      v: null,
      d: "Removed along EIP-1283"
    },
    netSstoreDirtyGas: {
      v: null,
      d: "Removed along EIP-1283"
    },
    netSstoreClearRefund: {
      v: null,
      d: "Removed along EIP-1283"
    },
    netSstoreResetRefund: {
      v: null,
      d: "Removed along EIP-1283"
    },
    netSstoreResetClearRefund: {
      v: null,
      d: "Removed along EIP-1283"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/istanbul.js
var istanbul_default = {
  name: "istanbul",
  comment: "HF targeted for December 2019 following the Constantinople/Petersburg HF",
  url: "https://eips.ethereum.org/EIPS/eip-1679",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    blake2Round: {
      v: 1,
      d: "Gas cost per round for the Blake2 F precompile"
    },
    ecAdd: {
      v: 150,
      d: "Gas costs for curve addition precompile"
    },
    ecMul: {
      v: 6000,
      d: "Gas costs for curve multiplication precompile"
    },
    ecPairing: {
      v: 45000,
      d: "Base gas costs for curve pairing precompile"
    },
    ecPairingWord: {
      v: 34000,
      d: "Gas costs regarding curve pairing precompile input length"
    },
    txDataNonZero: {
      v: 16,
      d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
    },
    sstoreSentryGasEIP2200: {
      v: 2300,
      d: "Minimum gas required to be present for an SSTORE call, not consumed"
    },
    sstoreNoopGasEIP2200: {
      v: 800,
      d: "Once per SSTORE operation if the value doesn't change"
    },
    sstoreDirtyGasEIP2200: {
      v: 800,
      d: "Once per SSTORE operation if a dirty value is changed"
    },
    sstoreInitGasEIP2200: {
      v: 20000,
      d: "Once per SSTORE operation from clean zero to non-zero"
    },
    sstoreInitRefundEIP2200: {
      v: 19200,
      d: "Once per SSTORE operation for resetting to the original zero value"
    },
    sstoreCleanGasEIP2200: {
      v: 5000,
      d: "Once per SSTORE operation from clean non-zero to something else"
    },
    sstoreCleanRefundEIP2200: {
      v: 4200,
      d: "Once per SSTORE operation for resetting to the original non-zero value"
    },
    sstoreClearRefundEIP2200: {
      v: 15000,
      d: "Once per SSTORE operation for clearing an originally existing storage slot"
    },
    balance: {
      v: 700,
      d: "Base fee of the BALANCE opcode"
    },
    extcodehash: {
      v: 700,
      d: "Base fee of the EXTCODEHASH opcode"
    },
    chainid: {
      v: 2,
      d: "Base fee of the CHAINID opcode"
    },
    selfbalance: {
      v: 5,
      d: "Base fee of the SELFBALANCE opcode"
    },
    sload: {
      v: 800,
      d: "Base fee of the SLOAD opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/muirGlacier.js
var muirGlacier_default = {
  name: "muirGlacier",
  comment: "HF to delay the difficulty bomb",
  url: "https://eips.ethereum.org/EIPS/eip-2384",
  status: "Final",
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {
    difficultyBombDelay: {
      v: 9000000,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/berlin.js
var berlin_default = {
  name: "berlin",
  comment: "HF targeted for July 2020 following the Muir Glacier HF",
  url: "https://eips.ethereum.org/EIPS/eip-2070",
  status: "Final",
  eips: [2565, 2929, 2718, 2930]
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/london.js
var london_default = {
  name: "london",
  comment: "HF targeted for July 2021 following the Berlin fork",
  url: "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
  status: "Final",
  eips: [1559, 3198, 3529, 3541]
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/shanghai.js
var shanghai_default = {
  name: "shanghai",
  comment: "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
  url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
  status: "Final",
  eips: [3651, 3855, 3860, 4895]
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/arrowGlacier.js
var arrowGlacier_default = {
  name: "arrowGlacier",
  comment: "HF to delay the difficulty bomb",
  url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
  status: "Final",
  eips: [4345],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/grayGlacier.js
var grayGlacier_default = {
  name: "grayGlacier",
  comment: "Delaying the difficulty bomb to Mid September 2022",
  url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
  status: "Draft",
  eips: [5133],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/mergeForkIdTransition.js
var mergeForkIdTransition_default = {
  name: "mergeForkIdTransition",
  comment: "Pre-merge hardfork to fork off non-upgraded clients",
  url: "https://eips.ethereum.org/EIPS/eip-3675",
  status: "Draft",
  eips: []
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/merge.js
var merge_default = {
  name: "merge",
  comment: "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
  url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
  status: "Final",
  consensus: {
    type: "pos",
    algorithm: "casper",
    casper: {}
  },
  eips: [3675, 4399]
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/index.js
var hardforks = {
  chainstart: chainstart_default,
  homestead: homestead_default,
  dao: dao_default,
  tangerineWhistle: tangerineWhistle_default,
  spuriousDragon: spuriousDragon_default,
  byzantium: byzantium_default,
  constantinople: constantinople_default,
  petersburg: petersburg_default,
  istanbul: istanbul_default,
  muirGlacier: muirGlacier_default,
  berlin: berlin_default,
  london: london_default,
  shanghai: shanghai_default,
  arrowGlacier: arrowGlacier_default,
  grayGlacier: grayGlacier_default,
  mergeForkIdTransition: mergeForkIdTransition_default,
  merge: merge_default
};

// node_modules/web3-eth-accounts/lib/esm/common/common.js
var { buf: crc32Uint8Array } = import_crc_32.default;

class Common extends EventEmitter2 {
  constructor(opts) {
    var _a3, _b;
    super();
    this._eips = [];
    this._customChains = (_a3 = opts.customChains) !== null && _a3 !== undefined ? _a3 : [];
    this._chainParams = this.setChain(opts.chain);
    this.DEFAULT_HARDFORK = (_b = this._chainParams.defaultHardfork) !== null && _b !== undefined ? _b : Hardfork.Merge;
    this.HARDFORK_CHANGES = this.hardforks().map((hf) => [
      hf.name,
      hardforks[hf.name]
    ]);
    this._hardfork = this.DEFAULT_HARDFORK;
    if (opts.hardfork !== undefined) {
      this.setHardfork(opts.hardfork);
    }
    if (opts.eips) {
      this.setEIPs(opts.eips);
    }
  }
  static custom(chainParamsOrName, opts = {}) {
    var _a3;
    const baseChain = (_a3 = opts.baseChain) !== null && _a3 !== undefined ? _a3 : "mainnet";
    const standardChainParams = Object.assign({}, Common._getChainParams(baseChain));
    standardChainParams.name = "custom-chain";
    if (typeof chainParamsOrName !== "string") {
      return new Common(Object.assign({ chain: Object.assign(Object.assign({}, standardChainParams), chainParamsOrName) }, opts));
    }
    if (chainParamsOrName === CustomChain.PolygonMainnet) {
      return Common.custom({
        name: CustomChain.PolygonMainnet,
        chainId: 137,
        networkId: 137
      }, opts);
    }
    if (chainParamsOrName === CustomChain.PolygonMumbai) {
      return Common.custom({
        name: CustomChain.PolygonMumbai,
        chainId: 80001,
        networkId: 80001
      }, opts);
    }
    if (chainParamsOrName === CustomChain.ArbitrumRinkebyTestnet) {
      return Common.custom({
        name: CustomChain.ArbitrumRinkebyTestnet,
        chainId: 421611,
        networkId: 421611
      }, opts);
    }
    if (chainParamsOrName === CustomChain.ArbitrumOne) {
      return Common.custom({
        name: CustomChain.ArbitrumOne,
        chainId: 42161,
        networkId: 42161
      }, opts);
    }
    if (chainParamsOrName === CustomChain.xDaiChain) {
      return Common.custom({
        name: CustomChain.xDaiChain,
        chainId: 100,
        networkId: 100
      }, opts);
    }
    if (chainParamsOrName === CustomChain.OptimisticKovan) {
      return Common.custom({
        name: CustomChain.OptimisticKovan,
        chainId: 69,
        networkId: 69
      }, Object.assign({ hardfork: Hardfork.Berlin }, opts));
    }
    if (chainParamsOrName === CustomChain.OptimisticEthereum) {
      return Common.custom({
        name: CustomChain.OptimisticEthereum,
        chainId: 10,
        networkId: 10
      }, Object.assign({ hardfork: Hardfork.Berlin }, opts));
    }
    throw new Error(`Custom chain ${chainParamsOrName} not supported`);
  }
  static fromGethGenesis(genesisJson, { chain, eips: eips2, genesisHash, hardfork, mergeForkIdPostMerge }) {
    var _a3;
    const genesisParams = parseGethGenesis(genesisJson, chain, mergeForkIdPostMerge);
    const common = new Common({
      chain: (_a3 = genesisParams.name) !== null && _a3 !== undefined ? _a3 : "custom",
      customChains: [genesisParams],
      eips: eips2,
      hardfork: hardfork !== null && hardfork !== undefined ? hardfork : genesisParams.hardfork
    });
    if (genesisHash !== undefined) {
      common.setForkHashes(genesisHash);
    }
    return common;
  }
  static isSupportedChainId(chainId) {
    const initializedChains = this._getInitializedChains();
    return Boolean(initializedChains.names[chainId.toString()]);
  }
  static _getChainParams(_chain, customChains) {
    let chain = _chain;
    const initializedChains = this._getInitializedChains(customChains);
    if (typeof chain === "number" || typeof chain === "bigint") {
      chain = chain.toString();
      if (initializedChains.names[chain]) {
        const name = initializedChains.names[chain];
        return initializedChains[name];
      }
      throw new Error(`Chain with ID ${chain} not supported`);
    }
    if (initializedChains[chain] !== undefined) {
      return initializedChains[chain];
    }
    throw new Error(`Chain with name ${chain} not supported`);
  }
  setChain(chain) {
    if (typeof chain === "number" || typeof chain === "bigint" || typeof chain === "string") {
      this._chainParams = Common._getChainParams(chain, this._customChains);
    } else if (typeof chain === "object") {
      if (this._customChains.length > 0) {
        throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");
      }
      const required = ["networkId", "genesis", "hardforks", "bootstrapNodes"];
      for (const param of required) {
        if (!(param in chain)) {
          throw new Error(`Missing required chain parameter: ${param}`);
        }
      }
      this._chainParams = chain;
    } else {
      throw new Error("Wrong input format");
    }
    for (const hf of this.hardforks()) {
      if (hf.block === undefined) {
        throw new Error(`Hardfork cannot have undefined block number`);
      }
    }
    return this._chainParams;
  }
  setHardfork(hardfork) {
    let existing = false;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if (hfChanges[0] === hardfork) {
        if (this._hardfork !== hardfork) {
          this._hardfork = hardfork;
          this.emit("hardforkChanged", hardfork);
        }
        existing = true;
      }
    }
    if (!existing) {
      throw new Error(`Hardfork with name ${hardfork} not supported`);
    }
  }
  getHardforkByBlockNumber(_blockNumber, _td, _timestamp) {
    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);
    const td = toType(_td, TypeOutput.BigInt);
    const timestamp = toType(_timestamp, TypeOutput.Number);
    const hfs = this.hardforks().filter((hf) => hf.block !== null || hf.ttd !== null && hf.ttd !== undefined || hf.timestamp !== undefined);
    const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);
    const doubleTTDHF = hfs.slice(mergeIndex + 1).findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);
    if (doubleTTDHF >= 0) {
      throw Error(`More than one merge hardforks found with ttd specified`);
    }
    let hfIndex = hfs.findIndex((hf) => hf.block !== null && hf.block > blockNumber || timestamp !== undefined && Number(hf.timestamp) > timestamp);
    if (hfIndex === -1) {
      hfIndex = hfs.length;
    } else if (hfIndex === 0) {
      throw Error("Must have at least one hardfork at block 0");
    }
    if (timestamp === undefined) {
      const stepBack = hfs.slice(0, hfIndex).reverse().findIndex((hf) => hf.block !== null || hf.ttd !== undefined);
      hfIndex -= stepBack;
    }
    hfIndex -= 1;
    if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === undefined) {
      if (td === undefined || td === null || BigInt(hfs[hfIndex].ttd) > td) {
        hfIndex -= 1;
      }
    } else if (mergeIndex >= 0 && td !== undefined && td !== null) {
      if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {
        throw Error("Maximum HF determined by total difficulty is lower than the block number HF");
      } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) <= td) {
        throw Error("HF determined by block number is lower than the minimum total difficulty HF");
      }
    }
    const hfStartIndex = hfIndex;
    for (;hfIndex < hfs.length - 1; hfIndex += 1) {
      if (hfs[hfIndex].block !== hfs[hfIndex + 1].block || hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {
        break;
      }
    }
    if (timestamp) {
      const minTimeStamp = hfs.slice(0, hfStartIndex).reduce((acc, hf) => {
        var _a3;
        return Math.max(Number((_a3 = hf.timestamp) !== null && _a3 !== undefined ? _a3 : "0"), acc);
      }, 0);
      if (minTimeStamp > timestamp) {
        throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);
      }
      const maxTimeStamp = hfs.slice(hfIndex + 1).reduce((acc, hf) => {
        var _a3;
        return Math.min(Number((_a3 = hf.timestamp) !== null && _a3 !== undefined ? _a3 : timestamp), acc);
      }, timestamp);
      if (maxTimeStamp < timestamp) {
        throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);
      }
    }
    const hardfork = hfs[hfIndex];
    return hardfork.name;
  }
  setHardforkByBlockNumber(blockNumber, td, timestamp) {
    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
    this.setHardfork(hardfork);
    return hardfork;
  }
  _getHardfork(hardfork) {
    const hfs = this.hardforks();
    for (const hf of hfs) {
      if (hf.name === hardfork)
        return hf;
    }
    return null;
  }
  setEIPs(eips2 = []) {
    for (const eip of eips2) {
      if (!(eip in EIPs)) {
        throw new Error(`${eip} not supported`);
      }
      const minHF = this.gteHardfork(EIPs[eip].minimumHardfork);
      if (!minHF) {
        throw new Error(`${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);
      }
      if (EIPs[eip].requiredEIPs !== undefined) {
        for (const elem of EIPs[eip].requiredEIPs) {
          if (!(eips2.includes(elem) || this.isActivatedEIP(elem))) {
            throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`);
          }
        }
      }
    }
    this._eips = eips2;
  }
  param(topic3, name) {
    let value;
    for (const eip of this._eips) {
      value = this.paramByEIP(topic3, name, eip);
      if (value !== undefined)
        return value;
    }
    return this.paramByHardfork(topic3, name, this._hardfork);
  }
  paramByHardfork(topic3, name, hardfork) {
    let value = null;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if ("eips" in hfChanges[1]) {
        const hfEIPs = hfChanges[1].eips;
        for (const eip of hfEIPs) {
          const valueEIP = this.paramByEIP(topic3, name, eip);
          value = typeof valueEIP === "bigint" ? valueEIP : value;
        }
      } else {
        if (hfChanges[1][topic3] === undefined) {
          throw new Error(`Topic ${topic3} not defined`);
        }
        if (hfChanges[1][topic3][name] !== undefined) {
          value = hfChanges[1][topic3][name].v;
        }
      }
      if (hfChanges[0] === hardfork)
        break;
    }
    return BigInt(value !== null && value !== undefined ? value : 0);
  }
  paramByEIP(topic3, name, eip) {
    if (!(eip in EIPs)) {
      throw new Error(`${eip} not supported`);
    }
    const eipParams = EIPs[eip];
    if (!(topic3 in eipParams)) {
      throw new Error(`Topic ${topic3} not defined`);
    }
    if (eipParams[topic3][name] === undefined) {
      return;
    }
    const value = eipParams[topic3][name].v;
    return BigInt(value);
  }
  paramByBlock(topic3, name, blockNumber, td, timestamp) {
    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
    return this.paramByHardfork(topic3, name, hardfork);
  }
  isActivatedEIP(eip) {
    if (this.eips().includes(eip)) {
      return true;
    }
    for (const hfChanges of this.HARDFORK_CHANGES) {
      const hf = hfChanges[1];
      if (this.gteHardfork(hf.name) && "eips" in hf) {
        if (hf.eips.includes(eip)) {
          return true;
        }
      }
    }
    return false;
  }
  hardforkIsActiveOnBlock(_hardfork, _blockNumber) {
    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const hfBlock = this.hardforkBlock(hardfork);
    if (typeof hfBlock === "bigint" && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {
      return true;
    }
    return false;
  }
  activeOnBlock(blockNumber) {
    return this.hardforkIsActiveOnBlock(null, blockNumber);
  }
  hardforkGteHardfork(_hardfork1, hardfork2) {
    const hardfork1 = _hardfork1 !== null && _hardfork1 !== undefined ? _hardfork1 : this._hardfork;
    const hardforks3 = this.hardforks();
    let posHf1 = -1;
    let posHf2 = -1;
    let index = 0;
    for (const hf of hardforks3) {
      if (hf.name === hardfork1)
        posHf1 = index;
      if (hf.name === hardfork2)
        posHf2 = index;
      index += 1;
    }
    return posHf1 >= posHf2 && posHf2 !== -1;
  }
  gteHardfork(hardfork) {
    return this.hardforkGteHardfork(null, hardfork);
  }
  hardforkBlock(_hardfork) {
    var _a3;
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const block4 = (_a3 = this._getHardfork(hardfork)) === null || _a3 === undefined ? undefined : _a3.block;
    if (block4 === undefined || block4 === null) {
      return null;
    }
    return BigInt(block4);
  }
  hardforkTimestamp(_hardfork) {
    var _a3;
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const timestamp = (_a3 = this._getHardfork(hardfork)) === null || _a3 === undefined ? undefined : _a3.timestamp;
    if (timestamp === undefined || timestamp === null) {
      return null;
    }
    return BigInt(timestamp);
  }
  eipBlock(eip) {
    for (const hfChanges of this.HARDFORK_CHANGES) {
      const hf = hfChanges[1];
      if ("eips" in hf) {
        if (hf.eips.includes(eip)) {
          return this.hardforkBlock(typeof hfChanges[0] === "number" ? String(hfChanges[0]) : hfChanges[0]);
        }
      }
    }
    return null;
  }
  hardforkTTD(_hardfork) {
    var _a3;
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const ttd = (_a3 = this._getHardfork(hardfork)) === null || _a3 === undefined ? undefined : _a3.ttd;
    if (ttd === undefined || ttd === null) {
      return null;
    }
    return BigInt(ttd);
  }
  isHardforkBlock(_blockNumber, _hardfork) {
    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const block4 = this.hardforkBlock(hardfork);
    return typeof block4 === "bigint" && block4 !== BigInt(0) ? block4 === blockNumber : false;
  }
  nextHardforkBlockOrTimestamp(_hardfork) {
    var _a3, _b;
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const hfs = this.hardforks();
    let hfIndex = hfs.findIndex((hf) => hf.name === hardfork);
    if (hardfork === Hardfork.Merge) {
      hfIndex -= 1;
    }
    if (hfIndex < 0) {
      return null;
    }
    let currHfTimeOrBlock = (_a3 = hfs[hfIndex].timestamp) !== null && _a3 !== undefined ? _a3 : hfs[hfIndex].block;
    currHfTimeOrBlock = currHfTimeOrBlock !== null && currHfTimeOrBlock !== undefined ? Number(currHfTimeOrBlock) : null;
    const nextHf = hfs.slice(hfIndex + 1).find((hf) => {
      var _a4;
      let hfTimeOrBlock = (_a4 = hf.timestamp) !== null && _a4 !== undefined ? _a4 : hf.block;
      hfTimeOrBlock = hfTimeOrBlock !== null && hfTimeOrBlock !== undefined ? Number(hfTimeOrBlock) : null;
      return hf.name !== Hardfork.Merge && hfTimeOrBlock !== null && hfTimeOrBlock !== undefined && hfTimeOrBlock !== currHfTimeOrBlock;
    });
    if (nextHf === undefined) {
      return null;
    }
    const nextHfBlock = (_b = nextHf.timestamp) !== null && _b !== undefined ? _b : nextHf.block;
    if (nextHfBlock === null || nextHfBlock === undefined) {
      return null;
    }
    return BigInt(nextHfBlock);
  }
  nextHardforkBlock(_hardfork) {
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    let hfBlock = this.hardforkBlock(hardfork);
    if (hfBlock === null && hardfork === Hardfork.Merge) {
      const hfs = this.hardforks();
      const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);
      if (mergeIndex < 0) {
        throw Error(`Merge hardfork should have been found`);
      }
      hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name);
    }
    if (hfBlock === null) {
      return null;
    }
    const nextHfBlock = this.hardforks().reduce((acc, hf) => {
      const block4 = BigInt(hf.block === null || hf.ttd !== undefined && hf.ttd !== null ? 0 : hf.block);
      return block4 > hfBlock && acc === null ? block4 : acc;
    }, null);
    return nextHfBlock;
  }
  isNextHardforkBlock(_blockNumber, _hardfork) {
    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const nextHardforkBlock = this.nextHardforkBlock(hardfork);
    return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber;
  }
  _calcForkHash(hardfork, genesisHash) {
    let hfUint8Array = new Uint8Array;
    let prevBlockOrTime = 0;
    for (const hf of this.hardforks()) {
      const { block: block4, timestamp, name } = hf;
      let blockOrTime = timestamp !== null && timestamp !== undefined ? timestamp : block4;
      blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null;
      if (typeof blockOrTime === "number" && blockOrTime !== 0 && blockOrTime !== prevBlockOrTime && name !== Hardfork.Merge) {
        const hfBlockUint8Array = hexToBytes(blockOrTime.toString(16).padStart(16, "0"));
        hfUint8Array = uint8ArrayConcat(hfUint8Array, hfBlockUint8Array);
        prevBlockOrTime = blockOrTime;
      }
      if (hf.name === hardfork)
        break;
    }
    const inputUint8Array = uint8ArrayConcat(genesisHash, hfUint8Array);
    const forkhash = bytesToHex2(intToUint8Array(crc32Uint8Array(inputUint8Array) >>> 0));
    return forkhash;
  }
  forkHash(_hardfork, genesisHash) {
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const data = this._getHardfork(hardfork);
    if (data === null || (data === null || data === undefined ? undefined : data.block) === null && (data === null || data === undefined ? undefined : data.timestamp) === undefined && (data === null || data === undefined ? undefined : data.ttd) === undefined) {
      const msg = "No fork hash calculation possible for future hardfork";
      throw new Error(msg);
    }
    if ((data === null || data === undefined ? undefined : data.forkHash) !== null && (data === null || data === undefined ? undefined : data.forkHash) !== undefined) {
      return data.forkHash;
    }
    if (!genesisHash)
      throw new Error("genesisHash required for forkHash calculation");
    return this._calcForkHash(hardfork, genesisHash);
  }
  hardforkForForkHash(forkHash) {
    const resArray = this.hardforks().filter((hf) => hf.forkHash === forkHash);
    return resArray.length >= 1 ? resArray[resArray.length - 1] : null;
  }
  setForkHashes(genesisHash) {
    var _a3;
    for (const hf of this.hardforks()) {
      const blockOrTime = (_a3 = hf.timestamp) !== null && _a3 !== undefined ? _a3 : hf.block;
      if ((hf.forkHash === null || hf.forkHash === undefined) && (blockOrTime !== null && blockOrTime !== undefined || typeof hf.ttd !== "undefined")) {
        hf.forkHash = this.forkHash(hf.name, genesisHash);
      }
    }
  }
  genesis() {
    return this._chainParams.genesis;
  }
  hardforks() {
    return this._chainParams.hardforks;
  }
  bootstrapNodes() {
    return this._chainParams.bootstrapNodes;
  }
  dnsNetworks() {
    return this._chainParams.dnsNetworks;
  }
  hardfork() {
    return this._hardfork;
  }
  chainId() {
    return BigInt(this._chainParams.chainId);
  }
  chainName() {
    return this._chainParams.name;
  }
  networkId() {
    return BigInt(this._chainParams.networkId);
  }
  eips() {
    return this._eips;
  }
  consensusType() {
    const hardfork = this.hardfork();
    let value;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if ("consensus" in hfChanges[1]) {
        value = hfChanges[1].consensus.type;
      }
      if (hfChanges[0] === hardfork)
        break;
    }
    return value !== null && value !== undefined ? value : this._chainParams.consensus.type;
  }
  consensusAlgorithm() {
    const hardfork = this.hardfork();
    let value;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if ("consensus" in hfChanges[1]) {
        value = hfChanges[1].consensus.algorithm;
      }
      if (hfChanges[0] === hardfork)
        break;
    }
    return value !== null && value !== undefined ? value : this._chainParams.consensus.algorithm;
  }
  consensusConfig() {
    var _a3;
    const hardfork = this.hardfork();
    let value;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if ("consensus" in hfChanges[1]) {
        value = hfChanges[1].consensus[hfChanges[1].consensus.algorithm];
      }
      if (hfChanges[0] === hardfork)
        break;
    }
    return (_a3 = value !== null && value !== undefined ? value : this._chainParams.consensus[this.consensusAlgorithm()]) !== null && _a3 !== undefined ? _a3 : {};
  }
  copy() {
    const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
    copy.removeAllListeners();
    return copy;
  }
  static _getInitializedChains(customChains) {
    const names = {};
    for (const [name, id] of Object.entries(Chain)) {
      names[id] = name.toLowerCase();
    }
    const chains = { mainnet: mainnet_default, goerli: goerli_default, sepolia: sepolia_default };
    if (customChains) {
      for (const chain of customChains) {
        const { name } = chain;
        names[chain.chainId.toString()] = name;
        chains[name] = chain;
      }
    }
    chains.names = names;
    return chains;
  }
}

// node_modules/web3-eth-accounts/lib/esm/tx/types.js
function isAccessListUint8Array(input) {
  if (input.length === 0) {
    return true;
  }
  const firstItem = input[0];
  if (Array.isArray(firstItem)) {
    return true;
  }
  return false;
}
function isAccessList(input) {
  return !isAccessListUint8Array(input);
}
var Capability;
(function(Capability2) {
  Capability2[Capability2["EIP155ReplayProtection"] = 155] = "EIP155ReplayProtection";
  Capability2[Capability2["EIP1559FeeMarket"] = 1559] = "EIP1559FeeMarket";
  Capability2[Capability2["EIP2718TypedTransaction"] = 2718] = "EIP2718TypedTransaction";
  Capability2[Capability2["EIP2930AccessLists"] = 2930] = "EIP2930AccessLists";
})(Capability || (Capability = {}));

// node_modules/web3-eth-accounts/lib/esm/tx/address.js
class Address {
  constructor(buf) {
    if (buf.length !== 20) {
      throw new Error("Invalid address length");
    }
    this.buf = buf;
  }
  static zero() {
    return new Address(zeros(20));
  }
  equals(address5) {
    return uint8ArrayEquals(this.buf, address5.buf);
  }
  isZero() {
    return this.equals(Address.zero());
  }
  toString() {
    return bytesToHex2(this.buf);
  }
  toArray() {
    return this.buf;
  }
  static publicToAddress(_pubKey, sanitize = false) {
    let pubKey = _pubKey;
    assertIsUint8Array(pubKey);
    if (sanitize && pubKey.length !== 64) {
      pubKey = secp256k12.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);
    }
    if (pubKey.length !== 64) {
      throw new Error("Expected pubKey to be of length 64");
    }
    return keccak256(pubKey).slice(-20);
  }
}

// node_modules/web3-eth-accounts/lib/esm/tx/utils.js
var checkMaxInitCodeSize = (common, length) => {
  const maxInitCodeSize = common.param("vm", "maxInitCodeSize");
  if (maxInitCodeSize && BigInt(length) > maxInitCodeSize) {
    throw new Error(`the initcode size of this transaction is too large: it is ${length} while the max is ${common.param("vm", "maxInitCodeSize")}`);
  }
};
var getAccessListData = (accessList) => {
  let AccessListJSON;
  let uint8arrayAccessList;
  if (isAccessList(accessList)) {
    AccessListJSON = accessList;
    const newAccessList = [];
    for (let i = 0;i < accessList.length; i += 1) {
      const item = accessList[i];
      const addressBytes = toUint8Array(item.address);
      const storageItems = [];
      for (let index = 0;index < item.storageKeys.length; index += 1) {
        storageItems.push(toUint8Array(item.storageKeys[index]));
      }
      newAccessList.push([addressBytes, storageItems]);
    }
    uint8arrayAccessList = newAccessList;
  } else {
    uint8arrayAccessList = accessList !== null && accessList !== undefined ? accessList : [];
    const json = [];
    for (let i = 0;i < uint8arrayAccessList.length; i += 1) {
      const data = uint8arrayAccessList[i];
      const address5 = bytesToHex2(data[0]);
      const storageKeys = [];
      for (let item = 0;item < data[1].length; item += 1) {
        storageKeys.push(bytesToHex2(data[1][item]));
      }
      const jsonItem = {
        address: address5,
        storageKeys
      };
      json.push(jsonItem);
    }
    AccessListJSON = json;
  }
  return {
    AccessListJSON,
    accessList: uint8arrayAccessList
  };
};
var verifyAccessList = (accessList) => {
  for (let key = 0;key < accessList.length; key += 1) {
    const accessListItem = accessList[key];
    const address5 = accessListItem[0];
    const storageSlots = accessListItem[1];
    if (accessListItem[2] !== undefined) {
      throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");
    }
    if (address5.length !== 20) {
      throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");
    }
    for (let storageSlot = 0;storageSlot < storageSlots.length; storageSlot += 1) {
      if (storageSlots[storageSlot].length !== 32) {
        throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes");
      }
    }
  }
};
var getAccessListJSON = (accessList) => {
  const accessListJSON = [];
  for (let index = 0;index < accessList.length; index += 1) {
    const item = accessList[index];
    const JSONItem = {
      address: bytesToHex2(setLengthLeft(item[0], 20)),
      storageKeys: []
    };
    const storageSlots = item && item[1];
    for (let slot = 0;slot < storageSlots.length; slot += 1) {
      const storageSlot = storageSlots[slot];
      JSONItem.storageKeys.push(bytesToHex2(setLengthLeft(storageSlot, 32)));
    }
    accessListJSON.push(JSONItem);
  }
  return accessListJSON;
};
var getDataFeeEIP2930 = (accessList, common) => {
  const accessListStorageKeyCost = common.param("gasPrices", "accessListStorageKeyCost");
  const accessListAddressCost = common.param("gasPrices", "accessListAddressCost");
  let slots = 0;
  for (let index = 0;index < accessList.length; index += 1) {
    const item = accessList[index];
    const storageSlots = item[1];
    slots += storageSlots.length;
  }
  const addresses = accessList.length;
  return addresses * Number(accessListAddressCost) + slots * Number(accessListStorageKeyCost);
};

// node_modules/web3-eth-accounts/lib/esm/tx/baseTransaction.js
class BaseTransaction {
  constructor(txData, opts) {
    var _a3, _b;
    this.cache = {
      hash: undefined,
      dataFee: undefined
    };
    this.activeCapabilities = [];
    this.DEFAULT_CHAIN = Chain.Mainnet;
    this.DEFAULT_HARDFORK = Hardfork.Merge;
    const { nonce, gasLimit, to, value, data, v, r, s, type } = txData;
    this._type = Number(uint8ArrayToBigInt(toUint8Array(type)));
    this.txOptions = opts;
    const toB = toUint8Array(to === "" ? "0x" : to);
    const vB = toUint8Array(v === "" ? "0x" : v);
    const rB = toUint8Array(r === "" ? "0x" : r);
    const sB = toUint8Array(s === "" ? "0x" : s);
    this.nonce = uint8ArrayToBigInt(toUint8Array(nonce === "" ? "0x" : nonce));
    this.gasLimit = uint8ArrayToBigInt(toUint8Array(gasLimit === "" ? "0x" : gasLimit));
    this.to = toB.length > 0 ? new Address(toB) : undefined;
    this.value = uint8ArrayToBigInt(toUint8Array(value === "" ? "0x" : value));
    this.data = toUint8Array(data === "" ? "0x" : data);
    this.v = vB.length > 0 ? uint8ArrayToBigInt(vB) : undefined;
    this.r = rB.length > 0 ? uint8ArrayToBigInt(rB) : undefined;
    this.s = sB.length > 0 ? uint8ArrayToBigInt(sB) : undefined;
    this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s });
    this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64);
    this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true);
    const createContract = this.to === undefined || this.to === null;
    const allowUnlimitedInitCodeSize = (_a3 = opts.allowUnlimitedInitCodeSize) !== null && _a3 !== undefined ? _a3 : false;
    const common2 = (_b = opts.common) !== null && _b !== undefined ? _b : this._getCommon();
    if (createContract && common2.isActivatedEIP(3860) && !allowUnlimitedInitCodeSize) {
      checkMaxInitCodeSize(common2, this.data.length);
    }
  }
  get type() {
    return this._type;
  }
  supports(capability) {
    return this.activeCapabilities.includes(capability);
  }
  validate(stringError = false) {
    const errors5 = [];
    if (this.getBaseFee() > this.gasLimit) {
      errors5.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`);
    }
    if (this.isSigned() && !this.verifySignature()) {
      errors5.push("Invalid Signature");
    }
    return stringError ? errors5 : errors5.length === 0;
  }
  _validateYParity() {
    const { v } = this;
    if (v !== undefined && v !== BigInt(0) && v !== BigInt(1)) {
      const msg = this._errorMsg("The y-parity of the transaction should either be 0 or 1");
      throw new Error(msg);
    }
  }
  _validateHighS() {
    const { s } = this;
    if (this.common.gteHardfork("homestead") && s !== undefined && s > SECP256K1_ORDER_DIV_2) {
      const msg = this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");
      throw new Error(msg);
    }
  }
  getBaseFee() {
    const txFee = this.common.param("gasPrices", "tx");
    let fee = this.getDataFee();
    if (txFee)
      fee += txFee;
    if (this.common.gteHardfork("homestead") && this.toCreationAddress()) {
      const txCreationFee = this.common.param("gasPrices", "txCreation");
      if (txCreationFee)
        fee += txCreationFee;
    }
    return fee;
  }
  getDataFee() {
    const txDataZero = this.common.param("gasPrices", "txDataZero");
    const txDataNonZero = this.common.param("gasPrices", "txDataNonZero");
    let cost = BigInt(0);
    for (let i = 0;i < this.data.length; i += 1) {
      this.data[i] === 0 ? cost += txDataZero : cost += txDataNonZero;
    }
    if ((this.to === undefined || this.to === null) && this.common.isActivatedEIP(3860)) {
      const dataLength = BigInt(Math.ceil(this.data.length / 32));
      const initCodeCost = this.common.param("gasPrices", "initCodeWordCost") * dataLength;
      cost += initCodeCost;
    }
    return cost;
  }
  toCreationAddress() {
    return this.to === undefined || this.to.buf.length === 0;
  }
  isSigned() {
    const { v, r, s } = this;
    if (v === undefined || r === undefined || s === undefined) {
      return false;
    }
    return true;
  }
  verifySignature() {
    try {
      const publicKey = this.getSenderPublicKey();
      return unpadUint8Array(publicKey).length !== 0;
    } catch (e) {
      return false;
    }
  }
  getSenderAddress() {
    return new Address(Address.publicToAddress(this.getSenderPublicKey()));
  }
  sign(privateKey) {
    if (privateKey.length !== 32) {
      const msg = this._errorMsg("Private key must be 32 bytes in length.");
      throw new Error(msg);
    }
    let hackApplied = false;
    if (this.type === 0 && this.common.gteHardfork("spuriousDragon") && !this.supports(Capability.EIP155ReplayProtection)) {
      this.activeCapabilities.push(Capability.EIP155ReplayProtection);
      hackApplied = true;
    }
    const msgHash = this.getMessageToSign(true);
    const { v, r, s } = this._ecsign(msgHash, privateKey);
    const tx = this._processSignature(v, r, s);
    if (hackApplied) {
      const index = this.activeCapabilities.indexOf(Capability.EIP155ReplayProtection);
      if (index > -1) {
        this.activeCapabilities.splice(index, 1);
      }
    }
    return tx;
  }
  _getCommon(common2, chainId) {
    var _a3, _b, _c, _d;
    if (chainId !== undefined) {
      const chainIdBigInt = uint8ArrayToBigInt(toUint8Array(chainId));
      if (common2) {
        if (common2.chainId() !== chainIdBigInt) {
          const msg = this._errorMsg("The chain ID does not match the chain ID of Common");
          throw new Error(msg);
        }
        return common2.copy();
      }
      if (Common.isSupportedChainId(chainIdBigInt)) {
        return new Common({ chain: chainIdBigInt, hardfork: this.DEFAULT_HARDFORK });
      }
      return Common.custom({
        name: "custom-chain",
        networkId: chainIdBigInt,
        chainId: chainIdBigInt
      }, { baseChain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
    }
    if ((common2 === null || common2 === undefined ? undefined : common2.copy) && typeof (common2 === null || common2 === undefined ? undefined : common2.copy) === "function") {
      return common2.copy();
    }
    if (common2) {
      const hardfork = typeof common2.hardfork === "function" ? common2.hardfork() : common2.hardfork;
      return Common.custom({
        name: "custom-chain",
        networkId: common2.networkId ? common2.networkId() : (_b = BigInt((_a3 = common2.customChain) === null || _a3 === undefined ? undefined : _a3.networkId)) !== null && _b !== undefined ? _b : undefined,
        chainId: common2.chainId ? common2.chainId() : (_d = BigInt((_c = common2.customChain) === null || _c === undefined ? undefined : _c.chainId)) !== null && _d !== undefined ? _d : undefined
      }, {
        baseChain: this.DEFAULT_CHAIN,
        hardfork: hardfork || this.DEFAULT_HARDFORK
      });
    }
    return new Common({ chain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
  }
  _validateCannotExceedMaxInteger(values, bits = 256, cannotEqual = false) {
    for (const [key, value] of Object.entries(values)) {
      switch (bits) {
        case 64:
          if (cannotEqual) {
            if (value !== undefined && value >= MAX_UINT64) {
              const msg = this._errorMsg(`${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`);
              throw new Error(msg);
            }
          } else if (value !== undefined && value > MAX_UINT64) {
            const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`);
            throw new Error(msg);
          }
          break;
        case 256:
          if (cannotEqual) {
            if (value !== undefined && value >= MAX_INTEGER) {
              const msg = this._errorMsg(`${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`);
              throw new Error(msg);
            }
          } else if (value !== undefined && value > MAX_INTEGER) {
            const msg = this._errorMsg(`${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`);
            throw new Error(msg);
          }
          break;
        default: {
          const msg = this._errorMsg("unimplemented bits value");
          throw new Error(msg);
        }
      }
    }
  }
  static _validateNotArray(values) {
    const txDataKeys = [
      "nonce",
      "gasPrice",
      "gasLimit",
      "to",
      "value",
      "data",
      "v",
      "r",
      "s",
      "type",
      "baseFee",
      "maxFeePerGas",
      "chainId"
    ];
    for (const [key, value] of Object.entries(values)) {
      if (txDataKeys.includes(key)) {
        if (Array.isArray(value)) {
          throw new Error(`${key} cannot be an array`);
        }
      }
    }
  }
  _getSharedErrorPostfix() {
    let hash3 = "";
    try {
      hash3 = this.isSigned() ? bytesToHex2(this.hash()) : "not available (unsigned)";
    } catch (e) {
      hash3 = "error";
    }
    let isSigned = "";
    try {
      isSigned = this.isSigned().toString();
    } catch (e) {
      hash3 = "error";
    }
    let hf = "";
    try {
      hf = this.common.hardfork();
    } catch (e) {
      hf = "error";
    }
    let postfix = `tx type=${this.type} hash=${hash3} nonce=${this.nonce} value=${this.value} `;
    postfix += `signed=${isSigned} hf=${hf}`;
    return postfix;
  }
  _ecsign(msgHash, privateKey, chainId) {
    const signature = secp256k12.sign(msgHash, privateKey);
    const signatureBytes = signature.toCompactRawBytes();
    const r = signatureBytes.subarray(0, 32);
    const s = signatureBytes.subarray(32, 64);
    const v = chainId === undefined ? BigInt(signature.recovery + 27) : BigInt(signature.recovery + 35) + BigInt(chainId) * BigInt(2);
    return { r, s, v };
  }
  static fromSerializedTx(serialized, opts = {}) {
  }
  static fromTxData(txData, opts = {}) {
  }
}

// node_modules/web3-eth-accounts/lib/esm/tx/eip1559Transaction.js
var TRANSACTION_TYPE = 2;
var TRANSACTION_TYPE_UINT8ARRAY = hexToBytes(TRANSACTION_TYPE.toString(16).padStart(2, "0"));

class FeeMarketEIP1559Transaction extends BaseTransaction {
  constructor(txData, opts = {}) {
    var _a3;
    super(Object.assign(Object.assign({}, txData), { type: TRANSACTION_TYPE }), opts);
    this.DEFAULT_HARDFORK = "london";
    const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas } = txData;
    this.common = this._getCommon(opts.common, chainId);
    this.chainId = this.common.chainId();
    if (!this.common.isActivatedEIP(1559)) {
      throw new Error("EIP-1559 not enabled on Common");
    }
    this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
    const accessListData = getAccessListData(accessList !== null && accessList !== undefined ? accessList : []);
    this.accessList = accessListData.accessList;
    this.AccessListJSON = accessListData.AccessListJSON;
    verifyAccessList(this.accessList);
    this.maxFeePerGas = uint8ArrayToBigInt(toUint8Array(maxFeePerGas === "" ? "0x" : maxFeePerGas));
    this.maxPriorityFeePerGas = uint8ArrayToBigInt(toUint8Array(maxPriorityFeePerGas === "" ? "0x" : maxPriorityFeePerGas));
    this._validateCannotExceedMaxInteger({
      maxFeePerGas: this.maxFeePerGas,
      maxPriorityFeePerGas: this.maxPriorityFeePerGas
    });
    BaseTransaction._validateNotArray(txData);
    if (this.gasLimit * this.maxFeePerGas > MAX_INTEGER) {
      const msg = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
      throw new Error(msg);
    }
    if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
      const msg = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
      throw new Error(msg);
    }
    this._validateYParity();
    this._validateHighS();
    const freeze = (_a3 = opts === null || opts === undefined ? undefined : opts.freeze) !== null && _a3 !== undefined ? _a3 : true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  static fromTxData(txData, opts = {}) {
    return new FeeMarketEIP1559Transaction(txData, opts);
  }
  static fromSerializedTx(serialized, opts = {}) {
    if (!uint8ArrayEquals(serialized.subarray(0, 1), TRANSACTION_TYPE_UINT8ARRAY)) {
      throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${bytesToHex2(serialized.subarray(0, 1))}`);
    }
    const values = rlp.RLP.decode(serialized.subarray(1));
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input: must be array");
    }
    return FeeMarketEIP1559Transaction.fromValuesArray(values, opts);
  }
  static fromValuesArray(values, opts = {}) {
    if (values.length !== 9 && values.length !== 12) {
      throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");
    }
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, v, r, s] = values;
    this._validateNotArray({ chainId, v });
    validateNoLeadingZeroes({
      nonce,
      maxPriorityFeePerGas,
      maxFeePerGas,
      gasLimit,
      value,
      v,
      r,
      s
    });
    return new FeeMarketEIP1559Transaction({
      chainId: uint8ArrayToBigInt(chainId),
      nonce,
      maxPriorityFeePerGas,
      maxFeePerGas,
      gasLimit,
      to,
      value,
      data,
      accessList: accessList !== null && accessList !== undefined ? accessList : [],
      v: v !== undefined ? uint8ArrayToBigInt(v) : undefined,
      r,
      s
    }, opts);
  }
  getDataFee() {
    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
      return this.cache.dataFee.value;
    }
    let cost = super.getDataFee();
    cost += BigInt(getDataFeeEIP2930(this.accessList, this.common));
    if (Object.isFrozen(this)) {
      this.cache.dataFee = {
        value: cost,
        hardfork: this.common.hardfork()
      };
    }
    return cost;
  }
  getUpfrontCost(baseFee = BigInt(0)) {
    const prio = this.maxPriorityFeePerGas;
    const maxBase = this.maxFeePerGas - baseFee;
    const inclusionFeePerGas = prio < maxBase ? prio : maxBase;
    const gasPrice = inclusionFeePerGas + baseFee;
    return this.gasLimit * gasPrice + this.value;
  }
  raw() {
    return [
      bigIntToUnpaddedUint8Array(this.chainId),
      bigIntToUnpaddedUint8Array(this.nonce),
      bigIntToUnpaddedUint8Array(this.maxPriorityFeePerGas),
      bigIntToUnpaddedUint8Array(this.maxFeePerGas),
      bigIntToUnpaddedUint8Array(this.gasLimit),
      this.to !== undefined ? this.to.buf : Uint8Array.from([]),
      bigIntToUnpaddedUint8Array(this.value),
      this.data,
      this.accessList,
      this.v !== undefined ? bigIntToUnpaddedUint8Array(this.v) : Uint8Array.from([]),
      this.r !== undefined ? bigIntToUnpaddedUint8Array(this.r) : Uint8Array.from([]),
      this.s !== undefined ? bigIntToUnpaddedUint8Array(this.s) : Uint8Array.from([])
    ];
  }
  serialize() {
    const base = this.raw();
    return uint8ArrayConcat(TRANSACTION_TYPE_UINT8ARRAY, rlp.RLP.encode(base));
  }
  getMessageToSign(hashMessage = true) {
    const base = this.raw().slice(0, 9);
    const message = uint8ArrayConcat(TRANSACTION_TYPE_UINT8ARRAY, rlp.RLP.encode(base));
    if (hashMessage) {
      return keccak256(message);
    }
    return message;
  }
  hash() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
      throw new Error(msg);
    }
    if (Object.isFrozen(this)) {
      if (!this.cache.hash) {
        this.cache.hash = keccak256(this.serialize());
      }
      return this.cache.hash;
    }
    return keccak256(this.serialize());
  }
  getMessageToVerifySignature() {
    return this.getMessageToSign();
  }
  getSenderPublicKey() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call this method if transaction is not signed");
      throw new Error(msg);
    }
    const msgHash = this.getMessageToVerifySignature();
    const { v, r, s } = this;
    this._validateHighS();
    try {
      return ecrecover(msgHash, v + BigInt(27), bigIntToUnpaddedUint8Array(r), bigIntToUnpaddedUint8Array(s));
    } catch (e) {
      const msg = this._errorMsg("Invalid Signature");
      throw new Error(msg);
    }
  }
  _processSignature(v, r, s) {
    const opts = Object.assign(Object.assign({}, this.txOptions), { common: this.common });
    return FeeMarketEIP1559Transaction.fromTxData({
      chainId: this.chainId,
      nonce: this.nonce,
      maxPriorityFeePerGas: this.maxPriorityFeePerGas,
      maxFeePerGas: this.maxFeePerGas,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      accessList: this.accessList,
      v: v - BigInt(27),
      r: uint8ArrayToBigInt(r),
      s: uint8ArrayToBigInt(s)
    }, opts);
  }
  toJSON() {
    const accessListJSON = getAccessListJSON(this.accessList);
    return {
      chainId: bigIntToHex(this.chainId),
      nonce: bigIntToHex(this.nonce),
      maxPriorityFeePerGas: bigIntToHex(this.maxPriorityFeePerGas),
      maxFeePerGas: bigIntToHex(this.maxFeePerGas),
      gasLimit: bigIntToHex(this.gasLimit),
      to: this.to !== undefined ? this.to.toString() : undefined,
      value: bigIntToHex(this.value),
      data: bytesToHex2(this.data),
      accessList: accessListJSON,
      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,
      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,
      s: this.s !== undefined ? bigIntToHex(this.s) : undefined
    };
  }
  errorStr() {
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
    return errorStr;
  }
  _errorMsg(msg) {
    return `${msg} (${this.errorStr()})`;
  }
}

// node_modules/web3-eth-accounts/lib/esm/tx/eip2930Transaction.js
var rlp2 = __toESM(require_dist(), 1);
var TRANSACTION_TYPE2 = 1;
var TRANSACTION_TYPE_UINT8ARRAY2 = hexToBytes(TRANSACTION_TYPE2.toString(16).padStart(2, "0"));

class AccessListEIP2930Transaction extends BaseTransaction {
  constructor(txData, opts = {}) {
    var _a3;
    super(Object.assign(Object.assign({}, txData), { type: TRANSACTION_TYPE2 }), opts);
    this.DEFAULT_HARDFORK = "berlin";
    const { chainId, accessList, gasPrice } = txData;
    this.common = this._getCommon(opts.common, chainId);
    this.chainId = this.common.chainId();
    if (!this.common.isActivatedEIP(2930)) {
      throw new Error("EIP-2930 not enabled on Common");
    }
    this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
    const accessListData = getAccessListData(accessList !== null && accessList !== undefined ? accessList : []);
    this.accessList = accessListData.accessList;
    this.AccessListJSON = accessListData.AccessListJSON;
    verifyAccessList(this.accessList);
    this.gasPrice = uint8ArrayToBigInt(toUint8Array(gasPrice === "" ? "0x" : gasPrice));
    this._validateCannotExceedMaxInteger({
      gasPrice: this.gasPrice
    });
    BaseTransaction._validateNotArray(txData);
    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {
      const msg = this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");
      throw new Error(msg);
    }
    this._validateYParity();
    this._validateHighS();
    const freeze = (_a3 = opts === null || opts === undefined ? undefined : opts.freeze) !== null && _a3 !== undefined ? _a3 : true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  static fromTxData(txData, opts = {}) {
    return new AccessListEIP2930Transaction(txData, opts);
  }
  static fromSerializedTx(serialized, opts = {}) {
    if (!uint8ArrayEquals(serialized.subarray(0, 1), TRANSACTION_TYPE_UINT8ARRAY2)) {
      throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${TRANSACTION_TYPE2}, received: ${bytesToHex2(serialized.subarray(0, 1))}`);
    }
    const values = rlp2.RLP.decode(Uint8Array.from(serialized.subarray(1)));
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input: must be array");
    }
    return AccessListEIP2930Transaction.fromValuesArray(values, opts);
  }
  static fromValuesArray(values, opts = {}) {
    if (values.length !== 8 && values.length !== 11) {
      throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");
    }
    const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values;
    this._validateNotArray({ chainId, v });
    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s });
    const emptyAccessList = [];
    return new AccessListEIP2930Transaction({
      chainId: uint8ArrayToBigInt(chainId),
      nonce,
      gasPrice,
      gasLimit,
      to,
      value,
      data,
      accessList: accessList !== null && accessList !== undefined ? accessList : emptyAccessList,
      v: v !== undefined ? uint8ArrayToBigInt(v) : undefined,
      r,
      s
    }, opts);
  }
  getDataFee() {
    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
      return this.cache.dataFee.value;
    }
    let cost = super.getDataFee();
    cost += BigInt(getDataFeeEIP2930(this.accessList, this.common));
    if (Object.isFrozen(this)) {
      this.cache.dataFee = {
        value: cost,
        hardfork: this.common.hardfork()
      };
    }
    return cost;
  }
  getUpfrontCost() {
    return this.gasLimit * this.gasPrice + this.value;
  }
  raw() {
    return [
      bigIntToUnpaddedUint8Array(this.chainId),
      bigIntToUnpaddedUint8Array(this.nonce),
      bigIntToUnpaddedUint8Array(this.gasPrice),
      bigIntToUnpaddedUint8Array(this.gasLimit),
      this.to !== undefined ? this.to.buf : Uint8Array.from([]),
      bigIntToUnpaddedUint8Array(this.value),
      this.data,
      this.accessList,
      this.v !== undefined ? bigIntToUnpaddedUint8Array(this.v) : Uint8Array.from([]),
      this.r !== undefined ? bigIntToUnpaddedUint8Array(this.r) : Uint8Array.from([]),
      this.s !== undefined ? bigIntToUnpaddedUint8Array(this.s) : Uint8Array.from([])
    ];
  }
  serialize() {
    const base = this.raw();
    return uint8ArrayConcat(TRANSACTION_TYPE_UINT8ARRAY2, rlp2.RLP.encode(base));
  }
  getMessageToSign(hashMessage = true) {
    const base = this.raw().slice(0, 8);
    const message = uint8ArrayConcat(TRANSACTION_TYPE_UINT8ARRAY2, rlp2.RLP.encode(base));
    if (hashMessage) {
      return keccak256(message);
    }
    return message;
  }
  hash() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
      throw new Error(msg);
    }
    if (Object.isFrozen(this)) {
      if (!this.cache.hash) {
        this.cache.hash = keccak256(this.serialize());
      }
      return this.cache.hash;
    }
    return keccak256(this.serialize());
  }
  getMessageToVerifySignature() {
    return this.getMessageToSign();
  }
  getSenderPublicKey() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call this method if transaction is not signed");
      throw new Error(msg);
    }
    const msgHash = this.getMessageToVerifySignature();
    const { v, r, s } = this;
    this._validateHighS();
    try {
      return ecrecover(msgHash, v + BigInt(27), bigIntToUnpaddedUint8Array(r), bigIntToUnpaddedUint8Array(s));
    } catch (e) {
      const msg = this._errorMsg("Invalid Signature");
      throw new Error(msg);
    }
  }
  _processSignature(v, r, s) {
    const opts = Object.assign(Object.assign({}, this.txOptions), { common: this.common });
    return AccessListEIP2930Transaction.fromTxData({
      chainId: this.chainId,
      nonce: this.nonce,
      gasPrice: this.gasPrice,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      accessList: this.accessList,
      v: v - BigInt(27),
      r: uint8ArrayToBigInt(r),
      s: uint8ArrayToBigInt(s)
    }, opts);
  }
  toJSON() {
    const accessListJSON = getAccessListJSON(this.accessList);
    return {
      chainId: bigIntToHex(this.chainId),
      nonce: bigIntToHex(this.nonce),
      gasPrice: bigIntToHex(this.gasPrice),
      gasLimit: bigIntToHex(this.gasLimit),
      to: this.to !== undefined ? this.to.toString() : undefined,
      value: bigIntToHex(this.value),
      data: bytesToHex2(this.data),
      accessList: accessListJSON,
      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,
      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,
      s: this.s !== undefined ? bigIntToHex(this.s) : undefined
    };
  }
  errorStr() {
    var _a3, _b;
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` gasPrice=${this.gasPrice} accessListCount=${(_b = (_a3 = this.accessList) === null || _a3 === undefined ? undefined : _a3.length) !== null && _b !== undefined ? _b : 0}`;
    return errorStr;
  }
  _errorMsg(msg) {
    return `${msg} (${this.errorStr()})`;
  }
}

// node_modules/web3-eth-accounts/lib/esm/tx/legacyTransaction.js
var rlp3 = __toESM(require_dist(), 1);
var meetsEIP155 = function(_v, chainId) {
  const v = Number(_v);
  const chainIdDoubled = Number(chainId) * 2;
  return v === chainIdDoubled + 35 || v === chainIdDoubled + 36;
};
var TRANSACTION_TYPE3 = 0;

class Transaction extends BaseTransaction {
  constructor(txData, opts = {}) {
    var _a3;
    super(Object.assign(Object.assign({}, txData), { type: TRANSACTION_TYPE3 }), opts);
    this.common = this._validateTxV(this.v, opts.common);
    this.gasPrice = uint8ArrayToBigInt(toUint8Array(txData.gasPrice === "" ? "0x" : txData.gasPrice));
    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {
      const msg = this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");
      throw new Error(msg);
    }
    this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice });
    BaseTransaction._validateNotArray(txData);
    if (this.common.gteHardfork("spuriousDragon")) {
      if (!this.isSigned()) {
        this.activeCapabilities.push(Capability.EIP155ReplayProtection);
      } else {
        if (meetsEIP155(this.v, this.common.chainId())) {
          this.activeCapabilities.push(Capability.EIP155ReplayProtection);
        }
      }
    }
    const freeze = (_a3 = opts === null || opts === undefined ? undefined : opts.freeze) !== null && _a3 !== undefined ? _a3 : true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  static fromTxData(txData, opts = {}) {
    return new Transaction(txData, opts);
  }
  static fromSerializedTx(serialized, opts = {}) {
    const values = rlp3.RLP.decode(serialized);
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input. Must be array");
    }
    return this.fromValuesArray(values, opts);
  }
  static fromValuesArray(values, opts = {}) {
    if (values.length !== 6 && values.length !== 9) {
      throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");
    }
    const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values;
    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s });
    return new Transaction({
      nonce,
      gasPrice,
      gasLimit,
      to,
      value,
      data,
      v,
      r,
      s
    }, opts);
  }
  raw() {
    return [
      bigIntToUnpaddedUint8Array(this.nonce),
      bigIntToUnpaddedUint8Array(this.gasPrice),
      bigIntToUnpaddedUint8Array(this.gasLimit),
      this.to !== undefined ? this.to.buf : Uint8Array.from([]),
      bigIntToUnpaddedUint8Array(this.value),
      this.data,
      this.v !== undefined ? bigIntToUnpaddedUint8Array(this.v) : Uint8Array.from([]),
      this.r !== undefined ? bigIntToUnpaddedUint8Array(this.r) : Uint8Array.from([]),
      this.s !== undefined ? bigIntToUnpaddedUint8Array(this.s) : Uint8Array.from([])
    ];
  }
  serialize() {
    return rlp3.RLP.encode(this.raw());
  }
  _getMessageToSign() {
    const values = [
      bigIntToUnpaddedUint8Array(this.nonce),
      bigIntToUnpaddedUint8Array(this.gasPrice),
      bigIntToUnpaddedUint8Array(this.gasLimit),
      this.to !== undefined ? this.to.buf : Uint8Array.from([]),
      bigIntToUnpaddedUint8Array(this.value),
      this.data
    ];
    if (this.supports(Capability.EIP155ReplayProtection)) {
      values.push(toUint8Array(this.common.chainId()));
      values.push(unpadUint8Array(toUint8Array(0)));
      values.push(unpadUint8Array(toUint8Array(0)));
    }
    return values;
  }
  getMessageToSign(hashMessage = true) {
    const message = this._getMessageToSign();
    if (hashMessage) {
      return keccak256(rlp3.RLP.encode(message));
    }
    return message;
  }
  getDataFee() {
    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
      return this.cache.dataFee.value;
    }
    if (Object.isFrozen(this)) {
      this.cache.dataFee = {
        value: super.getDataFee(),
        hardfork: this.common.hardfork()
      };
    }
    return super.getDataFee();
  }
  getUpfrontCost() {
    return this.gasLimit * this.gasPrice + this.value;
  }
  hash() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
      throw new Error(msg);
    }
    if (Object.isFrozen(this)) {
      if (!this.cache.hash) {
        this.cache.hash = keccak256(rlp3.RLP.encode(this.raw()));
      }
      return this.cache.hash;
    }
    return keccak256(rlp3.RLP.encode(this.raw()));
  }
  getMessageToVerifySignature() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("This transaction is not signed");
      throw new Error(msg);
    }
    const message = this._getMessageToSign();
    return keccak256(rlp3.RLP.encode(message));
  }
  getSenderPublicKey() {
    const msgHash = this.getMessageToVerifySignature();
    const { v, r, s } = this;
    this._validateHighS();
    try {
      return ecrecover(msgHash, v, bigIntToUnpaddedUint8Array(r), bigIntToUnpaddedUint8Array(s), this.supports(Capability.EIP155ReplayProtection) ? this.common.chainId() : undefined);
    } catch (e) {
      const msg = this._errorMsg("Invalid Signature");
      throw new Error(msg);
    }
  }
  _processSignature(_v, r, s) {
    let v = _v;
    if (this.supports(Capability.EIP155ReplayProtection)) {
      v += this.common.chainId() * BigInt(2) + BigInt(8);
    }
    const opts = Object.assign(Object.assign({}, this.txOptions), { common: this.common });
    return Transaction.fromTxData({
      nonce: this.nonce,
      gasPrice: this.gasPrice,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      v,
      r: uint8ArrayToBigInt(r),
      s: uint8ArrayToBigInt(s)
    }, opts);
  }
  toJSON() {
    return {
      nonce: bigIntToHex(this.nonce),
      gasPrice: bigIntToHex(this.gasPrice),
      gasLimit: bigIntToHex(this.gasLimit),
      to: this.to !== undefined ? this.to.toString() : undefined,
      value: bigIntToHex(this.value),
      data: bytesToHex2(this.data),
      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,
      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,
      s: this.s !== undefined ? bigIntToHex(this.s) : undefined
    };
  }
  _validateTxV(_v, common2) {
    let chainIdBigInt;
    const v = _v !== undefined ? Number(_v) : undefined;
    if (v !== undefined) {
      if (v < 37 && v !== 27 && v !== 28) {
        throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${v}`);
      }
    }
    if (v !== undefined && v !== 0 && (!common2 || common2.gteHardfork("spuriousDragon")) && v !== 27 && v !== 28) {
      if (common2) {
        if (!meetsEIP155(BigInt(v), common2.chainId())) {
          throw new Error(`Incompatible EIP155-based V ${v} and chain id ${common2.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`);
        }
      } else {
        let numSub;
        if ((v - 35) % 2 === 0) {
          numSub = 35;
        } else {
          numSub = 36;
        }
        chainIdBigInt = BigInt(v - numSub) / BigInt(2);
      }
    }
    return this._getCommon(common2, chainIdBigInt);
  }
  errorStr() {
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` gasPrice=${this.gasPrice}`;
    return errorStr;
  }
  _errorMsg(msg) {
    return `${msg} (${this.errorStr()})`;
  }
}

// node_modules/web3-eth-accounts/lib/esm/tx/transactionFactory.js
var extraTxTypes = new Map;

class TransactionFactory {
  constructor() {
  }
  static typeToInt(txType) {
    return Number(uint8ArrayToBigInt(toUint8Array(txType)));
  }
  static registerTransactionType(type, txClass) {
    const txType = TransactionFactory.typeToInt(type);
    extraTxTypes.set(txType, txClass);
  }
  static fromTxData(txData, txOptions = {}) {
    if (!("type" in txData) || txData.type === undefined) {
      return Transaction.fromTxData(txData, txOptions);
    }
    const txType = TransactionFactory.typeToInt(txData.type);
    if (txType === 0) {
      return Transaction.fromTxData(txData, txOptions);
    }
    if (txType === 1) {
      return AccessListEIP2930Transaction.fromTxData(txData, txOptions);
    }
    if (txType === 2) {
      return FeeMarketEIP1559Transaction.fromTxData(txData, txOptions);
    }
    const ExtraTransaction = extraTxTypes.get(txType);
    if (ExtraTransaction === null || ExtraTransaction === undefined ? undefined : ExtraTransaction.fromTxData) {
      return ExtraTransaction.fromTxData(txData, txOptions);
    }
    throw new Error(`Tx instantiation with type ${txType} not supported`);
  }
  static fromSerializedData(data, txOptions = {}) {
    if (data[0] <= 127) {
      switch (data[0]) {
        case 1:
          return AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);
        case 2:
          return FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);
        default: {
          const ExtraTransaction = extraTxTypes.get(Number(data[0]));
          if (ExtraTransaction === null || ExtraTransaction === undefined ? undefined : ExtraTransaction.fromSerializedTx) {
            return ExtraTransaction.fromSerializedTx(data, txOptions);
          }
          throw new Error(`TypedTransaction with ID ${data[0]} unknown`);
        }
      }
    } else {
      return Transaction.fromSerializedTx(data, txOptions);
    }
  }
  static fromBlockBodyData(data, txOptions = {}) {
    if (isUint8Array2(data)) {
      return this.fromSerializedData(data, txOptions);
    }
    if (Array.isArray(data)) {
      return Transaction.fromValuesArray(data, txOptions);
    }
    throw new Error("Cannot decode transaction: unknown type input");
  }
}

// node_modules/web3-eth-accounts/lib/esm/account.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var parseAndValidatePrivateKey = (data, ignoreLength) => {
  let privateKeyUint8Array;
  if (!ignoreLength && typeof data === "string" && isHexStrict(data) && data.length !== 66) {
    throw new PrivateKeyLengthError;
  }
  try {
    privateKeyUint8Array = isUint8Array2(data) ? data : bytesToUint8Array(data);
  } catch (_a3) {
    throw new InvalidPrivateKeyError;
  }
  if (!ignoreLength && privateKeyUint8Array.byteLength !== 32) {
    throw new PrivateKeyLengthError;
  }
  return privateKeyUint8Array;
};
var hashMessage = (message) => {
  const messageHex = isHexStrict(message) ? message : utf8ToHex(message);
  const messageBytes = hexToBytes(messageHex);
  const preamble = hexToBytes(fromUtf8(`\x19Ethereum Signed Message:
${messageBytes.byteLength}`));
  const ethMessage = uint8ArrayConcat(preamble, messageBytes);
  return sha3Raw(ethMessage);
};
var sign = (data, privateKey) => {
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);
  const hash3 = hashMessage(data);
  const signature = secp256k12.sign(hash3.substring(2), privateKeyUint8Array);
  const signatureBytes = signature.toCompactRawBytes();
  const r = signature.r.toString(16).padStart(64, "0");
  const s = signature.s.toString(16).padStart(64, "0");
  const v = signature.recovery + 27;
  return {
    message: data,
    messageHash: hash3,
    v: numberToHex2(v),
    r: `0x${r}`,
    s: `0x${s}`,
    signature: `${bytesToHex2(signatureBytes)}${v.toString(16)}`
  };
};
var signTransaction = (transaction, privateKey) => __awaiter11(undefined, undefined, undefined, function* () {
  const signedTx = transaction.sign(hexToBytes(privateKey));
  if (isNullish(signedTx.v) || isNullish(signedTx.r) || isNullish(signedTx.s))
    throw new TransactionSigningError("Signer Error");
  const validationErrors = signedTx.validate(true);
  if (validationErrors.length > 0) {
    let errorString = "Signer Error ";
    for (const validationError of validationErrors) {
      errorString += `${errorString} ${validationError}.`;
    }
    throw new TransactionSigningError(errorString);
  }
  const rawTx = bytesToHex2(signedTx.serialize());
  const txHash = sha3Raw(rawTx);
  return {
    messageHash: bytesToHex2(signedTx.getMessageToSign(true)),
    v: `0x${signedTx.v.toString(16)}`,
    r: `0x${signedTx.r.toString(16).padStart(64, "0")}`,
    s: `0x${signedTx.s.toString(16).padStart(64, "0")}`,
    rawTransaction: rawTx,
    transactionHash: bytesToHex2(txHash)
  };
});
var recoverTransaction = (rawTransaction) => {
  if (isNullish(rawTransaction))
    throw new UndefinedRawTransactionError;
  const tx = TransactionFactory.fromSerializedData(hexToBytes(rawTransaction));
  return toChecksumAddress(tx.getSenderAddress().toString());
};
var recover = (data, signatureOrV, prefixedOrR, s, prefixed) => {
  if (typeof data === "object") {
    const signatureStr = `${data.r}${data.s.slice(2)}${data.v.slice(2)}`;
    return recover(data.messageHash, signatureStr, prefixedOrR);
  }
  if (typeof signatureOrV === "string" && typeof prefixedOrR === "string" && !isNullish(s)) {
    const signatureStr = `${prefixedOrR}${s.slice(2)}${signatureOrV.slice(2)}`;
    return recover(data, signatureStr, prefixed);
  }
  if (isNullish(signatureOrV))
    throw new InvalidSignatureError("signature string undefined");
  const V_INDEX = 130;
  const hashedMessage = prefixedOrR ? data : hashMessage(data);
  let v = parseInt(signatureOrV.substring(V_INDEX), 16);
  if (v > 26) {
    v -= 27;
  }
  const ecPublicKey = secp256k12.Signature.fromCompact(signatureOrV.slice(2, V_INDEX)).addRecoveryBit(v).recoverPublicKey(hashedMessage.replace("0x", "")).toRawBytes(false);
  const publicHash = sha3Raw(ecPublicKey.subarray(1));
  const address6 = toChecksumAddress(`0x${publicHash.slice(-40)}`);
  return address6;
};
var privateKeyToAddress = (privateKey) => {
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);
  const publicKey = secp256k12.getPublicKey(privateKeyUint8Array, false);
  const publicKeyHash = sha3Raw(publicKey.slice(1));
  const address6 = publicKeyHash.slice(-40);
  return toChecksumAddress(`0x${address6}`);
};
var privateKeyToPublicKey = (privateKey, isCompressed) => {
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);
  return `0x${bytesToHex2(secp256k12.getPublicKey(privateKeyUint8Array, isCompressed)).slice(4)}`;
};
var encrypt2 = (privateKey, password, options) => __awaiter11(undefined, undefined, undefined, function* () {
  var _a3, _b, _c, _d, _e, _f, _g;
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);
  let salt;
  if (options === null || options === undefined ? undefined : options.salt) {
    salt = typeof options.salt === "string" ? hexToBytes(options.salt) : options.salt;
  } else {
    salt = randomBytes2(32);
  }
  if (!(isString(password) || isUint8Array2(password))) {
    throw new InvalidPasswordError;
  }
  const uint8ArrayPassword = typeof password === "string" ? hexToBytes(utf8ToHex(password)) : password;
  let initializationVector;
  if (options === null || options === undefined ? undefined : options.iv) {
    initializationVector = typeof options.iv === "string" ? hexToBytes(options.iv) : options.iv;
    if (initializationVector.length !== 16) {
      throw new IVLengthError;
    }
  } else {
    initializationVector = randomBytes2(16);
  }
  const kdf = (_a3 = options === null || options === undefined ? undefined : options.kdf) !== null && _a3 !== undefined ? _a3 : "scrypt";
  let derivedKey;
  let kdfparams;
  if (kdf === "pbkdf2") {
    kdfparams = {
      dklen: (_b = options === null || options === undefined ? undefined : options.dklen) !== null && _b !== undefined ? _b : 32,
      salt: bytesToHex2(salt).replace("0x", ""),
      c: (_c = options === null || options === undefined ? undefined : options.c) !== null && _c !== undefined ? _c : 262144,
      prf: "hmac-sha256"
    };
    if (kdfparams.c < 1000) {
      throw new PBKDF2IterationsError;
    }
    derivedKey = pbkdf2Sync(uint8ArrayPassword, salt, kdfparams.c, kdfparams.dklen, "sha256");
  } else if (kdf === "scrypt") {
    kdfparams = {
      n: (_d = options === null || options === undefined ? undefined : options.n) !== null && _d !== undefined ? _d : 8192,
      r: (_e = options === null || options === undefined ? undefined : options.r) !== null && _e !== undefined ? _e : 8,
      p: (_f = options === null || options === undefined ? undefined : options.p) !== null && _f !== undefined ? _f : 1,
      dklen: (_g = options === null || options === undefined ? undefined : options.dklen) !== null && _g !== undefined ? _g : 32,
      salt: bytesToHex2(salt).replace("0x", "")
    };
    derivedKey = scryptSync(uint8ArrayPassword, salt, kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);
  } else {
    throw new InvalidKdfError;
  }
  const cipher = yield encrypt(privateKeyUint8Array, derivedKey.slice(0, 16), initializationVector, "aes-128-ctr");
  const ciphertext = bytesToHex2(cipher).slice(2);
  const mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), cipher)).replace("0x", "");
  return {
    version: 3,
    id: uuidV4(),
    address: privateKeyToAddress(privateKeyUint8Array).toLowerCase().replace("0x", ""),
    crypto: {
      ciphertext,
      cipherparams: {
        iv: bytesToHex2(initializationVector).replace("0x", "")
      },
      cipher: "aes-128-ctr",
      kdf,
      kdfparams,
      mac
    }
  };
});
var privateKeyToAccount = (privateKey, ignoreLength) => {
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey, ignoreLength);
  return {
    address: privateKeyToAddress(privateKeyUint8Array),
    privateKey: bytesToHex2(privateKeyUint8Array),
    signTransaction: (_tx) => {
      throw new TransactionSigningError("Do not have network access to sign the transaction");
    },
    sign: (data) => sign(typeof data === "string" ? data : JSON.stringify(data), privateKeyUint8Array),
    encrypt: (password, options) => __awaiter11(undefined, undefined, undefined, function* () {
      return encrypt2(privateKeyUint8Array, password, options);
    })
  };
};
var create = () => {
  const privateKey = secp256k12.utils.randomPrivateKey();
  return privateKeyToAccount(`${bytesToHex2(privateKey)}`);
};
var decrypt2 = (keystore, password, nonStrict) => __awaiter11(undefined, undefined, undefined, function* () {
  const json = typeof keystore === "object" ? keystore : JSON.parse(nonStrict ? keystore.toLowerCase() : keystore);
  validator2.validateJSONSchema(keyStoreSchema, json);
  if (json.version !== 3)
    throw new KeyStoreVersionError;
  const uint8ArrayPassword = typeof password === "string" ? hexToBytes(utf8ToHex(password)) : password;
  validator2.validate(["bytes"], [uint8ArrayPassword]);
  let derivedKey;
  if (json.crypto.kdf === "scrypt") {
    const kdfparams = json.crypto.kdfparams;
    const uint8ArraySalt = typeof kdfparams.salt === "string" ? hexToBytes(kdfparams.salt) : kdfparams.salt;
    derivedKey = scryptSync(uint8ArrayPassword, uint8ArraySalt, kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);
  } else if (json.crypto.kdf === "pbkdf2") {
    const kdfparams = json.crypto.kdfparams;
    const uint8ArraySalt = typeof kdfparams.salt === "string" ? hexToBytes(kdfparams.salt) : kdfparams.salt;
    derivedKey = pbkdf2Sync(uint8ArrayPassword, uint8ArraySalt, kdfparams.c, kdfparams.dklen, "sha256");
  } else {
    throw new InvalidKdfError;
  }
  const ciphertext = hexToBytes(json.crypto.ciphertext);
  const mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), ciphertext)).replace("0x", "");
  if (mac !== json.crypto.mac) {
    throw new KeyDerivationError;
  }
  const seed = yield decrypt(hexToBytes(json.crypto.ciphertext), derivedKey.slice(0, 16), hexToBytes(json.crypto.cipherparams.iv));
  return privateKeyToAccount(seed);
});
// node_modules/web3-core/lib/esm/web3_batch_request.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_BATCH_REQUEST_TIMEOUT = 1000;

class Web3BatchRequest {
  constructor(requestManager) {
    this._requestManager = requestManager;
    this._requests = new Map;
  }
  get requests() {
    return [...this._requests.values()].map((r) => r.payload);
  }
  add(request) {
    const payload = exports_json_rpc.toPayload(request);
    const promise = new Web3DeferredPromise;
    this._requests.set(payload.id, { payload, promise });
    return promise;
  }
  execute(options) {
    var _a3;
    return __awaiter12(this, undefined, undefined, function* () {
      if (this.requests.length === 0) {
        return Promise.resolve([]);
      }
      const request = new Web3DeferredPromise({
        timeout: (_a3 = options === null || options === undefined ? undefined : options.timeout) !== null && _a3 !== undefined ? _a3 : DEFAULT_BATCH_REQUEST_TIMEOUT,
        eagerStart: true,
        timeoutMessage: "Batch request timeout"
      });
      this._processBatchRequest(request).catch((err) => request.reject(err));
      request.catch((err) => {
        if (err instanceof OperationTimeoutError) {
          this._abortAllRequests("Batch request timeout");
        }
        request.reject(err);
      });
      return request;
    });
  }
  _processBatchRequest(promise) {
    var _a3, _b;
    return __awaiter12(this, undefined, undefined, function* () {
      const response = yield this._requestManager.sendBatch([...this._requests.values()].map((r) => r.payload));
      if (response.length !== this._requests.size) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${response.length}`);
      }
      const requestIds = this.requests.map((r) => r.id).map(Number).sort((a, b) => a - b);
      const responseIds = response.map((r) => r.id).map(Number).sort((a, b) => a - b);
      if (JSON.stringify(requestIds) !== JSON.stringify(responseIds)) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request mismatch the results. Requests: [${requestIds.join()}], Responses: [${responseIds.join()}]`);
      }
      for (const res of response) {
        if (exports_json_rpc.isResponseWithResult(res)) {
          (_a3 = this._requests.get(res.id)) === null || _a3 === undefined || _a3.promise.resolve(res.result);
        } else if (exports_json_rpc.isResponseWithError(res)) {
          (_b = this._requests.get(res.id)) === null || _b === undefined || _b.promise.reject(res.error);
        }
      }
      promise.resolve(response);
    });
  }
  _abortAllRequests(msg) {
    for (const { promise } of this._requests.values()) {
      promise.reject(new OperationAbortError(msg));
    }
  }
}

// node_modules/web3-core/lib/esm/web3_context.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Web3Context extends Web3Config {
  constructor(providerOrContext) {
    var _a3;
    super();
    this.providers = Web3RequestManager.providers;
    if (isNullish2(providerOrContext) || typeof providerOrContext === "string" && providerOrContext.trim() !== "" || isSupportedProvider(providerOrContext)) {
      this._requestManager = new Web3RequestManager(providerOrContext);
      this._subscriptionManager = new Web3SubscriptionManager(this._requestManager, {});
      return;
    }
    const { config: config2, provider, requestManager, subscriptionManager, registeredSubscriptions, accountProvider, wallet: wallet2 } = providerOrContext;
    this.setConfig(config2 !== null && config2 !== undefined ? config2 : {});
    this._requestManager = requestManager !== null && requestManager !== undefined ? requestManager : new Web3RequestManager(provider, (_a3 = config2 === null || config2 === undefined ? undefined : config2.enableExperimentalFeatures) === null || _a3 === undefined ? undefined : _a3.useSubscriptionWhenCheckingBlockTimeout);
    if (subscriptionManager) {
      this._subscriptionManager = subscriptionManager;
    } else {
      this._subscriptionManager = new Web3SubscriptionManager(this.requestManager, registeredSubscriptions !== null && registeredSubscriptions !== undefined ? registeredSubscriptions : {});
    }
    if (accountProvider) {
      this._accountProvider = accountProvider;
    }
    if (wallet2) {
      this._wallet = wallet2;
    }
  }
  get requestManager() {
    return this._requestManager;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  get wallet() {
    return this._wallet;
  }
  get accountProvider() {
    return this._accountProvider;
  }
  static fromContextObject(...args) {
    return new this(...args.reverse());
  }
  getContextObject() {
    var _a3;
    return {
      config: this.config,
      provider: this.provider,
      requestManager: this.requestManager,
      subscriptionManager: this.subscriptionManager,
      registeredSubscriptions: (_a3 = this.subscriptionManager) === null || _a3 === undefined ? undefined : _a3.registeredSubscriptions,
      providers: this.providers,
      wallet: this.wallet,
      accountProvider: this.accountProvider
    };
  }
  use(ContextRef, ...args) {
    const newContextChild = new ContextRef(...[...args, this.getContextObject()]);
    this.on(Web3ConfigEvent.CONFIG_CHANGE, (event) => {
      newContextChild.setConfig({ [event.name]: event.newValue });
    });
    return newContextChild;
  }
  link(parentContext) {
    this.setConfig(parentContext.config);
    this._requestManager = parentContext.requestManager;
    this.provider = parentContext.provider;
    this._subscriptionManager = parentContext.subscriptionManager;
    this._wallet = parentContext.wallet;
    this._accountProvider = parentContext._accountProvider;
    parentContext.on(Web3ConfigEvent.CONFIG_CHANGE, (event) => {
      this.setConfig({ [event.name]: event.newValue });
    });
  }
  registerPlugin(plugin) {
    if (this[plugin.pluginNamespace] !== undefined)
      throw new ExistingPluginNamespaceError(plugin.pluginNamespace);
    const _pluginObject = {
      [plugin.pluginNamespace]: plugin
    };
    _pluginObject[plugin.pluginNamespace].link(this);
    Object.assign(this, _pluginObject);
  }
  get provider() {
    return this.currentProvider;
  }
  set provider(provider) {
    this.requestManager.setProvider(provider);
  }
  get currentProvider() {
    return this.requestManager.provider;
  }
  set currentProvider(provider) {
    this.requestManager.setProvider(provider);
  }
  get givenProvider() {
    return Web3Context.givenProvider;
  }
  setProvider(provider) {
    this.provider = provider;
    return true;
  }
  get BatchRequest() {
    return Web3BatchRequest.bind(undefined, this._requestManager);
  }
  extend(extendObj) {
    var _a3;
    if (extendObj.property && !this[extendObj.property])
      this[extendObj.property] = {};
    (_a3 = extendObj.methods) === null || _a3 === undefined || _a3.forEach((element) => {
      const method = (...givenParams) => __awaiter13(this, undefined, undefined, function* () {
        return this.requestManager.send({
          method: element.call,
          params: givenParams
        });
      });
      if (extendObj.property)
        this[extendObj.property][element.name] = method;
      else
        this[element.name] = method;
    });
    return this;
  }
}
Web3Context.providers = Web3RequestManager.providers;
// node_modules/web3-eth-iban/lib/esm/iban.js
class Iban {
  constructor(iban) {
    this.toAddress = () => {
      if (this.isDirect()) {
        const base36 = this._iban.slice(4);
        const parsedBigInt = Iban._parseInt(base36, 36);
        const paddedBigInt = leftPad(parsedBigInt, 40);
        return toChecksumAddress(paddedBigInt);
      }
      throw new Error("Iban is indirect and cannot be converted. Must be length of 34 or 35");
    };
    if (Iban.isIndirect(iban) || Iban.isDirect(iban)) {
      this._iban = iban;
    } else {
      throw new Error("Invalid IBAN was provided");
    }
  }
  static isDirect(iban) {
    return iban.length === 34 || iban.length === 35;
  }
  isDirect() {
    return Iban.isDirect(this._iban);
  }
  static isIndirect(iban) {
    return iban.length === 20;
  }
  isIndirect() {
    return Iban.isIndirect(this._iban);
  }
  static isValid(iban) {
    return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(iban) && Iban._mod9710(Iban._iso13616Prepare(iban)) === 1;
  }
  isValid() {
    return Iban.isValid(this._iban);
  }
  static fromBban(bban) {
    const countryCode = "XE";
    const remainder = this._mod9710(this._iso13616Prepare(`${countryCode}00${bban}`));
    const checkDigit = `0${(98 - remainder).toString()}`.slice(-2);
    return new Iban(`${countryCode}${checkDigit}${bban}`);
  }
  static createIndirect(options) {
    return Iban.fromBban(`ETH${options.institution}${options.identifier}`);
  }
  static fromAddress(address6) {
    if (!isAddress(address6)) {
      throw new InvalidAddressError(address6);
    }
    const num = BigInt(hexToNumber2(address6));
    const base36 = num.toString(36);
    const padded = leftPad(base36, 15);
    return Iban.fromBban(padded.toUpperCase());
  }
  static toIban(address6) {
    return Iban.fromAddress(address6).toString();
  }
  client() {
    return this.isIndirect() ? this._iban.slice(11) : "";
  }
  checksum() {
    return this._iban.slice(2, 4);
  }
  institution() {
    return this.isIndirect() ? this._iban.slice(7, 11) : "";
  }
  toString() {
    return this._iban;
  }
}
Iban._iso13616Prepare = (iban) => {
  const A = "A".charCodeAt(0);
  const Z = "Z".charCodeAt(0);
  const upperIban = iban.toUpperCase();
  const modifiedIban = `${upperIban.slice(4)}${upperIban.slice(0, 4)}`;
  return modifiedIban.split("").map((n) => {
    const code = n.charCodeAt(0);
    if (code >= A && code <= Z) {
      return code - A + 10;
    }
    return n;
  }).join("");
};
Iban._parseInt = (str, base) => [...str].reduce((acc, curr) => BigInt(parseInt(curr, base)) + BigInt(base) * acc, BigInt(0));
Iban._mod9710 = (iban) => {
  let remainder = iban;
  let block4;
  while (remainder.length > 2) {
    block4 = remainder.slice(0, 9);
    remainder = `${(parseInt(block4, 10) % 97).toString()}${remainder.slice(block4.length)}`;
  }
  return parseInt(remainder, 10) % 97;
};
Iban.toAddress = (iban) => {
  const ibanObject = new Iban(iban);
  return ibanObject.toAddress();
};
// node_modules/web3-core/lib/esm/web3_promi_event.js
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a3;

class Web3PromiEvent extends Web3EventEmitter {
  constructor(executor) {
    super();
    this[_a3] = "Promise";
    this._promise = new Promise(executor);
  }
  then(onfulfilled, onrejected) {
    return __awaiter14(this, undefined, undefined, function* () {
      return this._promise.then(onfulfilled, onrejected);
    });
  }
  catch(onrejected) {
    return __awaiter14(this, undefined, undefined, function* () {
      return this._promise.catch(onrejected);
    });
  }
  finally(onfinally) {
    return __awaiter14(this, undefined, undefined, function* () {
      return this._promise.finally(onfinally);
    });
  }
  on(eventName, fn) {
    super.on(eventName, fn);
    return this;
  }
  once(eventName, fn) {
    super.once(eventName, fn);
    return this;
  }
}
_a3 = Symbol.toStringTag;
// node_modules/web3-eth/lib/esm/index.js
var import_setimmediate = __toESM(require_setImmediate2(), 1);

// node_modules/web3-rpc-methods/lib/esm/eth_rpc_methods.js
var exports_eth_rpc_methods = {};
__export(exports_eth_rpc_methods, {
  uninstallFilter: () => {
    {
      return uninstallFilter;
    }
  },
  submitWork: () => {
    {
      return submitWork;
    }
  },
  submitHashrate: () => {
    {
      return submitHashrate;
    }
  },
  signTypedData: () => {
    {
      return signTypedData;
    }
  },
  signTransaction: () => {
    {
      return signTransaction2;
    }
  },
  sign: () => {
    {
      return sign2;
    }
  },
  sendTransaction: () => {
    {
      return sendTransaction;
    }
  },
  sendRawTransaction: () => {
    {
      return sendRawTransaction;
    }
  },
  requestAccounts: () => {
    {
      return requestAccounts;
    }
  },
  newPendingTransactionFilter: () => {
    {
      return newPendingTransactionFilter;
    }
  },
  newFilter: () => {
    {
      return newFilter;
    }
  },
  newBlockFilter: () => {
    {
      return newBlockFilter;
    }
  },
  getWork: () => {
    {
      return getWork;
    }
  },
  getUncleCountByBlockNumber: () => {
    {
      return getUncleCountByBlockNumber;
    }
  },
  getUncleCountByBlockHash: () => {
    {
      return getUncleCountByBlockHash;
    }
  },
  getUncleByBlockNumberAndIndex: () => {
    {
      return getUncleByBlockNumberAndIndex;
    }
  },
  getUncleByBlockHashAndIndex: () => {
    {
      return getUncleByBlockHashAndIndex;
    }
  },
  getTransactionReceipt: () => {
    {
      return getTransactionReceipt;
    }
  },
  getTransactionCount: () => {
    {
      return getTransactionCount;
    }
  },
  getTransactionByHash: () => {
    {
      return getTransactionByHash;
    }
  },
  getTransactionByBlockNumberAndIndex: () => {
    {
      return getTransactionByBlockNumberAndIndex;
    }
  },
  getTransactionByBlockHashAndIndex: () => {
    {
      return getTransactionByBlockHashAndIndex;
    }
  },
  getSyncing: () => {
    {
      return getSyncing;
    }
  },
  getStorageAt: () => {
    {
      return getStorageAt;
    }
  },
  getProtocolVersion: () => {
    {
      return getProtocolVersion;
    }
  },
  getProof: () => {
    {
      return getProof;
    }
  },
  getPendingTransactions: () => {
    {
      return getPendingTransactions;
    }
  },
  getNodeInfo: () => {
    {
      return getNodeInfo;
    }
  },
  getMining: () => {
    {
      return getMining;
    }
  },
  getMaxPriorityFeePerGas: () => {
    {
      return getMaxPriorityFeePerGas;
    }
  },
  getLogs: () => {
    {
      return getLogs;
    }
  },
  getHashRate: () => {
    {
      return getHashRate;
    }
  },
  getGasPrice: () => {
    {
      return getGasPrice;
    }
  },
  getFilterLogs: () => {
    {
      return getFilterLogs;
    }
  },
  getFilterChanges: () => {
    {
      return getFilterChanges;
    }
  },
  getFeeHistory: () => {
    {
      return getFeeHistory;
    }
  },
  getCompilers: () => {
    {
      return getCompilers;
    }
  },
  getCoinbase: () => {
    {
      return getCoinbase;
    }
  },
  getCode: () => {
    {
      return getCode;
    }
  },
  getChainId: () => {
    {
      return getChainId;
    }
  },
  getBlockTransactionCountByNumber: () => {
    {
      return getBlockTransactionCountByNumber;
    }
  },
  getBlockTransactionCountByHash: () => {
    {
      return getBlockTransactionCountByHash;
    }
  },
  getBlockNumber: () => {
    {
      return getBlockNumber;
    }
  },
  getBlockByNumber: () => {
    {
      return getBlockByNumber;
    }
  },
  getBlockByHash: () => {
    {
      return getBlockByHash;
    }
  },
  getBalance: () => {
    {
      return getBalance;
    }
  },
  getAccounts: () => {
    {
      return getAccounts;
    }
  },
  estimateGas: () => {
    {
      return estimateGas;
    }
  },
  createAccessList: () => {
    {
      return createAccessList;
    }
  },
  compileSolidity: () => {
    {
      return compileSolidity;
    }
  },
  compileSerpent: () => {
    {
      return compileSerpent;
    }
  },
  compileLLL: () => {
    {
      return compileLLL;
    }
  },
  call: () => {
    {
      return call;
    }
  }
});
function getProtocolVersion(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_protocolVersion",
      params: []
    });
  });
}
function getSyncing(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_syncing",
      params: []
    });
  });
}
function getCoinbase(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_coinbase",
      params: []
    });
  });
}
function getMining(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_mining",
      params: []
    });
  });
}
function getHashRate(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_hashrate",
      params: []
    });
  });
}
function getGasPrice(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_gasPrice",
      params: []
    });
  });
}
function getMaxPriorityFeePerGas(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_maxPriorityFeePerGas",
      params: []
    });
  });
}
function getAccounts(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_accounts",
      params: []
    });
  });
}
function getBlockNumber(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_blockNumber",
      params: []
    });
  });
}
function getBalance(requestManager, address6, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address", "blockNumberOrTag"], [address6, blockNumber]);
    return requestManager.send({
      method: "eth_getBalance",
      params: [address6, blockNumber]
    });
  });
}
function getStorageAt(requestManager, address6, storageSlot, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address", "hex", "blockNumberOrTag"], [address6, storageSlot, blockNumber]);
    return requestManager.send({
      method: "eth_getStorageAt",
      params: [address6, storageSlot, blockNumber]
    });
  });
}
function getTransactionCount(requestManager, address6, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address", "blockNumberOrTag"], [address6, blockNumber]);
    return requestManager.send({
      method: "eth_getTransactionCount",
      params: [address6, blockNumber]
    });
  });
}
function getBlockTransactionCountByHash(requestManager, blockHash) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32"], [blockHash]);
    return requestManager.send({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    });
  });
}
function getBlockTransactionCountByNumber(requestManager, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumber]
    });
  });
}
function getUncleCountByBlockHash(requestManager, blockHash) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32"], [blockHash]);
    return requestManager.send({
      method: "eth_getUncleCountByBlockHash",
      params: [blockHash]
    });
  });
}
function getUncleCountByBlockNumber(requestManager, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_getUncleCountByBlockNumber",
      params: [blockNumber]
    });
  });
}
function getCode(requestManager, address6, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address", "blockNumberOrTag"], [address6, blockNumber]);
    return requestManager.send({
      method: "eth_getCode",
      params: [address6, blockNumber]
    });
  });
}
function sign2(requestManager, address6, message) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address", "hex"], [address6, message]);
    return requestManager.send({
      method: "eth_sign",
      params: [address6, message]
    });
  });
}
function signTransaction2(requestManager, transaction) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_signTransaction",
      params: [transaction]
    });
  });
}
function sendTransaction(requestManager, transaction) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_sendTransaction",
      params: [transaction]
    });
  });
}
function sendRawTransaction(requestManager, transaction) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["hex"], [transaction]);
    return requestManager.send({
      method: "eth_sendRawTransaction",
      params: [transaction]
    });
  });
}
function call(requestManager, transaction, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_call",
      params: [transaction, blockNumber]
    });
  });
}
function estimateGas(requestManager, transaction, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_estimateGas",
      params: [transaction, blockNumber]
    });
  });
}
function getBlockByHash(requestManager, blockHash, hydrated) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32", "bool"], [blockHash, hydrated]);
    return requestManager.send({
      method: "eth_getBlockByHash",
      params: [blockHash, hydrated]
    });
  });
}
function getBlockByNumber(requestManager, blockNumber, hydrated) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag", "bool"], [blockNumber, hydrated]);
    return requestManager.send({
      method: "eth_getBlockByNumber",
      params: [blockNumber, hydrated]
    });
  });
}
function getTransactionByHash(requestManager, transactionHash) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32"], [transactionHash]);
    return requestManager.send({
      method: "eth_getTransactionByHash",
      params: [transactionHash]
    });
  });
}
function getTransactionByBlockHashAndIndex(requestManager, blockHash, transactionIndex) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32", "hex"], [blockHash, transactionIndex]);
    return requestManager.send({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, transactionIndex]
    });
  });
}
function getTransactionByBlockNumberAndIndex(requestManager, blockNumber, transactionIndex) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag", "hex"], [blockNumber, transactionIndex]);
    return requestManager.send({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumber, transactionIndex]
    });
  });
}
function getTransactionReceipt(requestManager, transactionHash) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32"], [transactionHash]);
    return requestManager.send({
      method: "eth_getTransactionReceipt",
      params: [transactionHash]
    });
  });
}
function getUncleByBlockHashAndIndex(requestManager, blockHash, uncleIndex) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32", "hex"], [blockHash, uncleIndex]);
    return requestManager.send({
      method: "eth_getUncleByBlockHashAndIndex",
      params: [blockHash, uncleIndex]
    });
  });
}
function getUncleByBlockNumberAndIndex(requestManager, blockNumber, uncleIndex) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag", "hex"], [blockNumber, uncleIndex]);
    return requestManager.send({
      method: "eth_getUncleByBlockNumberAndIndex",
      params: [blockNumber, uncleIndex]
    });
  });
}
function getCompilers(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_getCompilers",
      params: []
    });
  });
}
function compileSolidity(requestManager, code) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["string"], [code]);
    return requestManager.send({
      method: "eth_compileSolidity",
      params: [code]
    });
  });
}
function compileLLL(requestManager, code) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["string"], [code]);
    return requestManager.send({
      method: "eth_compileLLL",
      params: [code]
    });
  });
}
function compileSerpent(requestManager, code) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["string"], [code]);
    return requestManager.send({
      method: "eth_compileSerpent",
      params: [code]
    });
  });
}
function newFilter(requestManager, filter3) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["filter"], [filter3]);
    return requestManager.send({
      method: "eth_newFilter",
      params: [filter3]
    });
  });
}
function newBlockFilter(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_newBlockFilter",
      params: []
    });
  });
}
function newPendingTransactionFilter(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_newPendingTransactionFilter",
      params: []
    });
  });
}
function uninstallFilter(requestManager, filterIdentifier) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["hex"], [filterIdentifier]);
    return requestManager.send({
      method: "eth_uninstallFilter",
      params: [filterIdentifier]
    });
  });
}
function getFilterChanges(requestManager, filterIdentifier) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["hex"], [filterIdentifier]);
    return requestManager.send({
      method: "eth_getFilterChanges",
      params: [filterIdentifier]
    });
  });
}
function getFilterLogs(requestManager, filterIdentifier) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["hex"], [filterIdentifier]);
    return requestManager.send({
      method: "eth_getFilterLogs",
      params: [filterIdentifier]
    });
  });
}
function getLogs(requestManager, filter3) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["filter"], [filter3]);
    return requestManager.send({
      method: "eth_getLogs",
      params: [filter3]
    });
  });
}
function getWork(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_getWork",
      params: []
    });
  });
}
function submitWork(requestManager, nonce, hash3, digest) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes8", "bytes32", "bytes32"], [nonce, hash3, digest]);
    return requestManager.send({
      method: "eth_submitWork",
      params: [nonce, hash3, digest]
    });
  });
}
function submitHashrate(requestManager, hashRate, id) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32", "bytes32"], [hashRate, id]);
    return requestManager.send({
      method: "eth_submitHashrate",
      params: [hashRate, id]
    });
  });
}
function getFeeHistory(requestManager, blockCount, newestBlock, rewardPercentiles) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["hex", "blockNumberOrTag"], [blockCount, newestBlock]);
    for (const rewardPercentile of rewardPercentiles) {
      validator2.validate(["number"], [rewardPercentile]);
    }
    return requestManager.send({
      method: "eth_feeHistory",
      params: [blockCount, newestBlock, rewardPercentiles]
    });
  });
}
function getPendingTransactions(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_pendingTransactions",
      params: []
    });
  });
}
function requestAccounts(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_requestAccounts",
      params: []
    });
  });
}
function getChainId(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_chainId",
      params: []
    });
  });
}
function getProof(requestManager, address6, storageKeys, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address", "bytes32[]", "blockNumberOrTag"], [address6, storageKeys, blockNumber]);
    return requestManager.send({
      method: "eth_getProof",
      params: [address6, storageKeys, blockNumber]
    });
  });
}
function getNodeInfo(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "web3_clientVersion",
      params: []
    });
  });
}
function createAccessList(requestManager, transaction, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_createAccessList",
      params: [transaction, blockNumber]
    });
  });
}
function signTypedData(requestManager, address6, typedData, useLegacy = false) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address"], [address6]);
    return requestManager.send({
      method: `eth_signTypedData${useLegacy ? "" : "_v4"}`,
      params: [address6, typedData]
    });
  });
}
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-rpc-methods/lib/esm/net_rpc_methods.js
var exports_net_rpc_methods = {};
__export(exports_net_rpc_methods, {
  isListening: () => {
    {
      return isListening;
    }
  },
  getPeerCount: () => {
    {
      return getPeerCount;
    }
  },
  getId: () => {
    {
      return getId;
    }
  }
});
function getId(requestManager) {
  return __awaiter16(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "net_version",
      params: []
    });
  });
}
function getPeerCount(requestManager) {
  return __awaiter16(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "net_peerCount",
      params: []
    });
  });
}
function isListening(requestManager) {
  return __awaiter16(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "net_listening",
      params: []
    });
  });
}
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-rpc-methods/lib/esm/personal_rpc_methods.js
var exports_personal_rpc_methods = {};
__export(exports_personal_rpc_methods, {
  unlockAccount: () => {
    {
      return unlockAccount;
    }
  },
  signTransaction: () => {
    {
      return signTransaction3;
    }
  },
  sign: () => {
    {
      return sign3;
    }
  },
  sendTransaction: () => {
    {
      return sendTransaction2;
    }
  },
  newAccount: () => {
    {
      return newAccount;
    }
  },
  lockAccount: () => {
    {
      return lockAccount;
    }
  },
  importRawKey: () => {
    {
      return importRawKey;
    }
  },
  getAccounts: () => {
    {
      return getAccounts2;
    }
  },
  ecRecover: () => {
    {
      return ecRecover;
    }
  }
});
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getAccounts2 = (requestManager) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_listAccounts",
    params: []
  });
});
var newAccount = (requestManager, password) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_newAccount",
    params: [password]
  });
});
var unlockAccount = (requestManager, address6, password, unlockDuration) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_unlockAccount",
    params: [address6, password, unlockDuration]
  });
});
var lockAccount = (requestManager, address6) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_lockAccount",
    params: [address6]
  });
});
var importRawKey = (requestManager, keyData, passphrase) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_importRawKey",
    params: [keyData, passphrase]
  });
});
var sendTransaction2 = (requestManager, tx2, passphrase) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_sendTransaction",
    params: [tx2, passphrase]
  });
});
var signTransaction3 = (requestManager, tx2, passphrase) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_signTransaction",
    params: [tx2, passphrase]
  });
});
var sign3 = (requestManager, data, address6, passphrase) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_sign",
    params: [data, address6, passphrase]
  });
});
var ecRecover = (requestManager, signedData, signature) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_ecRecover",
    params: [signedData, signature]
  });
});

// node_modules/web3-eth/lib/esm/utils/detect_transaction_type.js
var transactionType0x0Schema = {
  type: "object",
  properties: {
    accessList: {
      type: "null"
    },
    maxFeePerGas: {
      type: "null"
    },
    maxPriorityFeePerGas: {
      type: "null"
    }
  }
};
var transactionType0x1Schema = {
  type: "object",
  properties: {
    maxFeePerGas: {
      type: "null"
    },
    maxPriorityFeePerGas: {
      type: "null"
    }
  }
};
var transactionType0x2Schema = {
  type: "object",
  properties: {
    gasPrice: {
      type: "null"
    }
  }
};
var validateTxTypeAndHandleErrors = (txSchema, tx2, txType) => {
  try {
    validator2.validateJSONSchema(txSchema, tx2);
  } catch (error) {
    if (error instanceof Web3ValidatorError)
      throw new InvalidPropertiesForTransactionTypeError(error.errors, txType);
    throw error;
  }
};
var defaultTransactionTypeParser = (transaction) => {
  var _a4, _b;
  const tx2 = transaction;
  if (!isNullish(tx2.type)) {
    let txSchema;
    switch (tx2.type) {
      case "0x0":
        txSchema = transactionType0x0Schema;
        break;
      case "0x1":
        txSchema = transactionType0x1Schema;
        break;
      case "0x2":
        txSchema = transactionType0x2Schema;
        break;
      default:
        return format({ format: "uint" }, tx2.type, ETH_DATA_FORMAT);
    }
    validateTxTypeAndHandleErrors(txSchema, tx2, tx2.type);
    return format({ format: "uint" }, tx2.type, ETH_DATA_FORMAT);
  }
  if (!isNullish(tx2.maxFeePerGas) || !isNullish(tx2.maxPriorityFeePerGas)) {
    validateTxTypeAndHandleErrors(transactionType0x2Schema, tx2, "0x2");
    return "0x2";
  }
  if (!isNullish(tx2.accessList)) {
    validateTxTypeAndHandleErrors(transactionType0x1Schema, tx2, "0x1");
    return "0x1";
  }
  const givenHardfork = (_a4 = tx2.hardfork) !== null && _a4 !== undefined ? _a4 : (_b = tx2.common) === null || _b === undefined ? undefined : _b.hardfork;
  if (!isNullish(givenHardfork)) {
    const hardforkIndex = Object.keys(HardforksOrdered).indexOf(givenHardfork);
    if (hardforkIndex >= Object.keys(HardforksOrdered).indexOf("london"))
      return !isNullish(tx2.gasPrice) ? "0x0" : "0x2";
    if (hardforkIndex === Object.keys(HardforksOrdered).indexOf("berlin"))
      return "0x0";
  }
  if (!isNullish(tx2.gasPrice)) {
    validateTxTypeAndHandleErrors(transactionType0x0Schema, tx2, "0x0");
    return "0x0";
  }
  return;
};
var detectTransactionType = (transaction, web3Context) => {
  var _a4;
  return ((_a4 = web3Context === null || web3Context === undefined ? undefined : web3Context.transactionTypeParser) !== null && _a4 !== undefined ? _a4 : defaultTransactionTypeParser)(transaction);
};
var detectRawTransactionType = (transaction) => transaction[0] > 127 ? "0x0" : toHex(transaction[0]);

// node_modules/web3-eth/lib/esm/schemas.js
var accessListItemSchema = {
  type: "object",
  properties: {
    address: {
      format: "address"
    },
    storageKeys: {
      type: "array",
      items: {
        format: "bytes32"
      }
    }
  }
};
var accessListSchema = {
  type: "array",
  items: Object.assign({}, accessListItemSchema)
};
var accessListResultSchema = {
  type: "object",
  properties: {
    accessList: Object.assign({}, accessListSchema),
    gasUsed: {
      type: "string"
    }
  }
};
var chainSchema = {
  type: "string",
  enum: ["goerli", "kovan", "mainnet", "rinkeby", "ropsten", "sepolia"]
};
var hardforkSchema = {
  type: "string",
  enum: [
    "arrowGlacier",
    "berlin",
    "byzantium",
    "chainstart",
    "constantinople",
    "dao",
    "homestead",
    "istanbul",
    "london",
    "merge",
    "muirGlacier",
    "petersburg",
    "shanghai",
    "spuriousDragon",
    "tangerineWhistle"
  ]
};
var customChainSchema = {
  type: "object",
  properties: {
    name: {
      format: "string"
    },
    networkId: {
      format: "uint"
    },
    chainId: {
      format: "uint"
    }
  }
};
var transactionSchema = {
  type: "object",
  properties: {
    from: {
      format: "address"
    },
    to: {
      oneOf: [{ format: "address" }, { type: "null" }]
    },
    value: {
      format: "uint"
    },
    gas: {
      format: "uint"
    },
    gasPrice: {
      format: "uint"
    },
    effectiveGasPrice: {
      format: "uint"
    },
    type: {
      format: "uint"
    },
    maxFeePerGas: {
      format: "uint"
    },
    maxPriorityFeePerGas: {
      format: "uint"
    },
    accessList: Object.assign({}, accessListSchema),
    data: {
      format: "bytes"
    },
    input: {
      format: "bytes"
    },
    nonce: {
      format: "uint"
    },
    chain: Object.assign({}, chainSchema),
    hardfork: Object.assign({}, hardforkSchema),
    chainId: {
      format: "uint"
    },
    networkId: {
      format: "uint"
    },
    common: {
      type: "object",
      properties: {
        customChain: Object.assign({}, customChainSchema),
        baseChain: Object.assign({}, chainSchema),
        hardfork: Object.assign({}, hardforkSchema)
      }
    },
    gasLimit: {
      format: "uint"
    },
    v: {
      format: "uint"
    },
    r: {
      format: "bytes32"
    },
    s: {
      format: "bytes32"
    }
  }
};
var transactionInfoSchema = {
  type: "object",
  properties: Object.assign(Object.assign({}, transactionSchema.properties), { blockHash: {
    format: "bytes32"
  }, blockNumber: {
    format: "uint"
  }, hash: {
    format: "bytes32"
  }, transactionIndex: {
    format: "uint"
  }, from: {
    format: "address"
  }, to: {
    oneOf: [{ format: "address" }, { type: "null" }]
  }, value: {
    format: "uint"
  }, gas: {
    format: "uint"
  }, gasPrice: {
    format: "uint"
  }, effectiveGasPrice: {
    format: "uint"
  }, type: {
    format: "uint"
  }, maxFeePerGas: {
    format: "uint"
  }, maxPriorityFeePerGas: {
    format: "uint"
  }, accessList: Object.assign({}, accessListSchema), data: {
    format: "bytes"
  }, input: {
    format: "bytes"
  }, nonce: {
    format: "uint"
  }, gasLimit: {
    format: "uint"
  }, v: {
    format: "uint"
  }, r: {
    format: "bytes32"
  }, s: {
    format: "bytes32"
  } })
};
var blockSchema = {
  type: "object",
  properties: {
    parentHash: {
      format: "bytes32"
    },
    sha3Uncles: {
      format: "bytes32"
    },
    miner: {
      format: "bytes"
    },
    stateRoot: {
      format: "bytes32"
    },
    transactionsRoot: {
      format: "bytes32"
    },
    receiptsRoot: {
      format: "bytes32"
    },
    logsBloom: {
      format: "bytes256"
    },
    difficulty: {
      format: "uint"
    },
    number: {
      format: "uint"
    },
    gasLimit: {
      format: "uint"
    },
    gasUsed: {
      format: "uint"
    },
    timestamp: {
      format: "uint"
    },
    extraData: {
      format: "bytes"
    },
    mixHash: {
      format: "bytes32"
    },
    nonce: {
      format: "uint"
    },
    totalDifficulty: {
      format: "uint"
    },
    baseFeePerGas: {
      format: "uint"
    },
    size: {
      format: "uint"
    },
    transactions: {
      oneOf: [
        {
          type: "array",
          items: Object.assign({}, transactionInfoSchema)
        },
        {
          type: "array",
          items: {
            format: "bytes32"
          }
        }
      ]
    },
    uncles: {
      type: "array",
      items: {
        format: "bytes32"
      }
    },
    hash: {
      format: "bytes32"
    }
  }
};
var withdrawalsSchema = {
  type: "object",
  properties: {
    index: {
      format: "uint"
    },
    validatorIndex: {
      format: "uint"
    },
    address: {
      format: "address"
    },
    amount: {
      format: "uint"
    }
  }
};
var blockHeaderSchema = {
  type: "object",
  properties: {
    author: {
      format: "bytes32"
    },
    hash: {
      format: "bytes32"
    },
    parentHash: {
      format: "bytes32"
    },
    receiptsRoot: {
      format: "bytes32"
    },
    miner: {
      format: "bytes"
    },
    stateRoot: {
      format: "bytes32"
    },
    transactionsRoot: {
      format: "bytes32"
    },
    withdrawalsRoot: {
      format: "bytes32"
    },
    logsBloom: {
      format: "bytes256"
    },
    difficulty: {
      format: "uint"
    },
    totalDifficulty: {
      format: "uint"
    },
    number: {
      format: "uint"
    },
    gasLimit: {
      format: "uint"
    },
    gasUsed: {
      format: "uint"
    },
    timestamp: {
      format: "uint"
    },
    extraData: {
      format: "bytes"
    },
    nonce: {
      format: "uint"
    },
    sha3Uncles: {
      format: "bytes32"
    },
    size: {
      format: "uint"
    },
    baseFeePerGas: {
      format: "uint"
    },
    excessDataGas: {
      format: "uint"
    },
    mixHash: {
      format: "bytes32"
    },
    transactions: {
      type: "array",
      items: {
        format: "bytes32"
      }
    },
    uncles: {
      type: "array",
      items: {
        format: "bytes32"
      }
    },
    withdrawals: {
      type: "array",
      items: Object.assign({}, withdrawalsSchema)
    }
  }
};
var logSchema = {
  type: "object",
  properties: {
    removed: {
      format: "bool"
    },
    logIndex: {
      format: "uint"
    },
    transactionIndex: {
      format: "uint"
    },
    transactionHash: {
      format: "bytes32"
    },
    blockHash: {
      format: "bytes32"
    },
    blockNumber: {
      format: "uint"
    },
    address: {
      format: "address"
    },
    data: {
      format: "bytes"
    },
    topics: {
      type: "array",
      items: {
        format: "bytes32"
      }
    }
  }
};
var syncSchema = {
  type: "object",
  properties: {
    startingBlock: {
      format: "string"
    },
    currentBlock: {
      format: "string"
    },
    highestBlock: {
      format: "string"
    },
    knownStates: {
      format: "string"
    },
    pulledStates: {
      format: "string"
    }
  }
};
var transactionReceiptSchema = {
  type: "object",
  properties: {
    transactionHash: {
      format: "bytes32"
    },
    transactionIndex: {
      format: "uint"
    },
    blockHash: {
      format: "bytes32"
    },
    blockNumber: {
      format: "uint"
    },
    from: {
      format: "address"
    },
    to: {
      format: "address"
    },
    cumulativeGasUsed: {
      format: "uint"
    },
    gasUsed: {
      format: "uint"
    },
    effectiveGasPrice: {
      format: "uint"
    },
    contractAddress: {
      format: "address"
    },
    logs: {
      type: "array",
      items: Object.assign({}, logSchema)
    },
    logsBloom: {
      format: "bytes"
    },
    root: {
      format: "bytes"
    },
    status: {
      format: "uint"
    },
    type: {
      format: "uint"
    }
  }
};
var SignatureObjectSchema = {
  type: "object",
  properties: {
    messageHash: {
      format: "bytes"
    },
    r: {
      format: "bytes32"
    },
    s: {
      format: "bytes32"
    },
    v: {
      format: "bytes"
    },
    message: {
      format: "bytes"
    },
    signature: {
      format: "bytes"
    }
  }
};
var feeHistorySchema = {
  type: "object",
  properties: {
    oldestBlock: {
      format: "uint"
    },
    baseFeePerGas: {
      type: "array",
      items: {
        format: "uint"
      }
    },
    reward: {
      type: "array",
      items: {
        type: "array",
        items: {
          format: "uint"
        }
      }
    },
    gasUsedRatio: {
      type: "array",
      items: {
        type: "number"
      }
    }
  }
};
var storageProofSchema = {
  type: "object",
  properties: {
    key: {
      format: "bytes32"
    },
    value: {
      format: "uint"
    },
    proof: {
      type: "array",
      items: {
        format: "bytes32"
      }
    }
  }
};
var accountSchema = {
  type: "object",
  properties: {
    balance: {
      format: "uint"
    },
    codeHash: {
      format: "bytes32"
    },
    nonce: {
      format: "uint"
    },
    storageHash: {
      format: "bytes32"
    },
    accountProof: {
      type: "array",
      items: {
        format: "bytes32"
      }
    },
    storageProof: {
      type: "array",
      items: Object.assign({}, storageProofSchema)
    }
  }
};

// node_modules/web3-eth/lib/esm/utils/format_transaction.js
function formatTransaction(transaction, returnFormat = DEFAULT_RETURN_FORMAT, options = {
  transactionSchema: transactionInfoSchema,
  fillInputAndData: false
}) {
  var _a4, _b;
  let formattedTransaction = mergeDeep({}, transaction);
  if (!isNullish(transaction === null || transaction === undefined ? undefined : transaction.common)) {
    formattedTransaction.common = Object.assign({}, transaction.common);
    if (!isNullish((_a4 = transaction.common) === null || _a4 === undefined ? undefined : _a4.customChain))
      formattedTransaction.common.customChain = Object.assign({}, transaction.common.customChain);
  }
  formattedTransaction = format((_b = options.transactionSchema) !== null && _b !== undefined ? _b : transactionInfoSchema, formattedTransaction, returnFormat);
  if (!isNullish(formattedTransaction.data) && !isNullish(formattedTransaction.input) && toHex(formattedTransaction.data) !== toHex(formattedTransaction.input))
    throw new TransactionDataAndInputError({
      data: bytesToHex2(formattedTransaction.data),
      input: bytesToHex2(formattedTransaction.input)
    });
  if (options.fillInputAndData) {
    if (!isNullish(formattedTransaction.data)) {
      formattedTransaction.input = formattedTransaction.data;
    } else if (!isNullish(formattedTransaction.input)) {
      formattedTransaction.data = formattedTransaction.input;
    }
  }
  if (!isNullish(formattedTransaction.gasLimit)) {
    formattedTransaction.gas = formattedTransaction.gasLimit;
    delete formattedTransaction.gasLimit;
  }
  return formattedTransaction;
}

// node_modules/web3-eth/lib/esm/utils/decode_signed_transaction.js
function decodeSignedTransaction(encodedSignedTransaction, returnFormat, options = { fillInputAndData: false }) {
  return {
    raw: format({ format: "bytes" }, encodedSignedTransaction, returnFormat),
    tx: formatTransaction(Object.assign(Object.assign({}, TransactionFactory.fromSerializedData(hexToBytes(encodedSignedTransaction)).toJSON()), { hash: bytesToHex2(keccak256Wrapper(hexToBytes(encodedSignedTransaction))), type: detectRawTransactionType(hexToBytes(encodedSignedTransaction)) }), returnFormat, { fillInputAndData: options.fillInputAndData })
  };
}

// node_modules/web3-net/lib/esm/rpc_method_wrappers.js
function getId2(web3Context, returnFormat) {
  return __awaiter18(this, undefined, undefined, function* () {
    const response = yield exports_net_rpc_methods.getId(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getPeerCount2(web3Context, returnFormat) {
  return __awaiter18(this, undefined, undefined, function* () {
    const response = yield exports_net_rpc_methods.getPeerCount(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var isListening2 = (web3Context) => __awaiter18(undefined, undefined, undefined, function* () {
  return exports_net_rpc_methods.isListening(web3Context.requestManager);
});

// node_modules/web3-net/lib/esm/net.js
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Net extends Web3Context {
  getId(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter19(this, undefined, undefined, function* () {
      return getId2(this, returnFormat);
    });
  }
  getPeerCount(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter19(this, undefined, undefined, function* () {
      return getPeerCount2(this, returnFormat);
    });
  }
  isListening() {
    return __awaiter19(this, undefined, undefined, function* () {
      return isListening2(this);
    });
  }
}
// node_modules/web3-eth/lib/esm/constants.js
var ALL_EVENTS = "ALLEVENTS";
var ALL_EVENTS_ABI = {
  name: ALL_EVENTS,
  signature: "",
  type: "event",
  inputs: []
};
var NUMBER_DATA_FORMAT = { bytes: FMT_BYTES.HEX, number: FMT_NUMBER.NUMBER };

// node_modules/web3-eth/lib/esm/utils/get_transaction_gas_pricing.js
var getEip1559GasPricing = function(transaction, web3Context, returnFormat) {
  var _a4, _b, _c;
  return __awaiter20(this, undefined, undefined, function* () {
    const block4 = yield getBlock(web3Context, web3Context.defaultBlock, false, returnFormat);
    if (isNullish(block4.baseFeePerGas))
      throw new Eip1559NotSupportedError;
    if (!isNullish(transaction.gasPrice)) {
      const convertedTransactionGasPrice = format({ format: "uint" }, transaction.gasPrice, returnFormat);
      return {
        maxPriorityFeePerGas: convertedTransactionGasPrice,
        maxFeePerGas: convertedTransactionGasPrice
      };
    }
    return {
      maxPriorityFeePerGas: format({ format: "uint" }, (_a4 = transaction.maxPriorityFeePerGas) !== null && _a4 !== undefined ? _a4 : web3Context.defaultMaxPriorityFeePerGas, returnFormat),
      maxFeePerGas: format({ format: "uint" }, (_b = transaction.maxFeePerGas) !== null && _b !== undefined ? _b : BigInt(block4.baseFeePerGas) * BigInt(2) + BigInt((_c = transaction.maxPriorityFeePerGas) !== null && _c !== undefined ? _c : web3Context.defaultMaxPriorityFeePerGas), returnFormat)
    };
  });
};
function getTransactionGasPricing(transaction, web3Context, returnFormat) {
  return __awaiter20(this, undefined, undefined, function* () {
    const transactionType = getTransactionType(transaction, web3Context);
    if (!isNullish(transactionType)) {
      if (transactionType.startsWith("-"))
        throw new UnsupportedTransactionTypeError(transactionType);
      if (Number(transactionType) < 0 || Number(transactionType) > 127)
        throw new UnsupportedTransactionTypeError(transactionType);
      if (isNullish(transaction.gasPrice) && (transactionType === "0x0" || transactionType === "0x1"))
        return {
          gasPrice: yield getGasPrice2(web3Context, returnFormat),
          maxPriorityFeePerGas: undefined,
          maxFeePerGas: undefined
        };
      if (transactionType === "0x2") {
        return Object.assign({ gasPrice: undefined }, yield getEip1559GasPricing(transaction, web3Context, returnFormat));
      }
    }
    return;
  });
}
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-eth/lib/esm/utils/transaction_builder.js
function defaultTransactionBuilder(options) {
  var _a4, _b;
  return __awaiter21(this, undefined, undefined, function* () {
    let populatedTransaction = format(transactionSchema, options.transaction, DEFAULT_RETURN_FORMAT);
    if (isNullish(populatedTransaction.from)) {
      populatedTransaction.from = getTransactionFromOrToAttr("from", options.web3Context, undefined, options.privateKey);
    }
    if (isNullish(populatedTransaction.nonce)) {
      populatedTransaction.nonce = yield getTransactionNonce(options.web3Context, populatedTransaction.from, ETH_DATA_FORMAT);
    }
    if (isNullish(populatedTransaction.value)) {
      populatedTransaction.value = "0x0";
    }
    if (!isNullish(populatedTransaction.data)) {
      if (!isNullish(populatedTransaction.input) && populatedTransaction.data !== populatedTransaction.input)
        throw new TransactionDataAndInputError({
          data: bytesToHex2(populatedTransaction.data),
          input: bytesToHex2(populatedTransaction.input)
        });
      if (!populatedTransaction.data.startsWith("0x"))
        populatedTransaction.data = `0x${populatedTransaction.data}`;
    } else if (!isNullish(populatedTransaction.input)) {
      if (!populatedTransaction.input.startsWith("0x"))
        populatedTransaction.input = `0x${populatedTransaction.input}`;
    } else {
      populatedTransaction.input = "0x";
    }
    if (isNullish(populatedTransaction.common)) {
      if (options.web3Context.defaultCommon) {
        const common4 = options.web3Context.defaultCommon;
        const chainId = common4.customChain.chainId;
        const networkId = common4.customChain.networkId;
        const name = common4.customChain.name;
        populatedTransaction.common = Object.assign(Object.assign({}, common4), { customChain: { chainId, networkId, name } });
      }
      if (isNullish(populatedTransaction.chain)) {
        populatedTransaction.chain = options.web3Context.defaultChain;
      }
      if (isNullish(populatedTransaction.hardfork)) {
        populatedTransaction.hardfork = options.web3Context.defaultHardfork;
      }
    }
    if (isNullish(populatedTransaction.chainId) && isNullish((_a4 = populatedTransaction.common) === null || _a4 === undefined ? undefined : _a4.customChain.chainId)) {
      populatedTransaction.chainId = yield getChainId2(options.web3Context, ETH_DATA_FORMAT);
    }
    if (isNullish(populatedTransaction.networkId)) {
      populatedTransaction.networkId = (_b = options.web3Context.defaultNetworkId) !== null && _b !== undefined ? _b : yield getId2(options.web3Context, ETH_DATA_FORMAT);
    }
    if (isNullish(populatedTransaction.gasLimit) && !isNullish(populatedTransaction.gas)) {
      populatedTransaction.gasLimit = populatedTransaction.gas;
    }
    populatedTransaction.type = getTransactionType(populatedTransaction, options.web3Context);
    if (isNullish(populatedTransaction.accessList) && (populatedTransaction.type === "0x1" || populatedTransaction.type === "0x2")) {
      populatedTransaction.accessList = [];
    }
    if (options.fillGasPrice)
      populatedTransaction = Object.assign(Object.assign({}, populatedTransaction), yield getTransactionGasPricing(populatedTransaction, options.web3Context, ETH_DATA_FORMAT));
    if (isNullish(populatedTransaction.gas) && isNullish(populatedTransaction.gasLimit) && options.fillGasLimit) {
      const fillGasLimit = yield estimateGas2(options.web3Context, populatedTransaction, "latest", ETH_DATA_FORMAT);
      populatedTransaction = Object.assign(Object.assign({}, populatedTransaction), { gas: format({ format: "uint" }, fillGasLimit, ETH_DATA_FORMAT) });
    }
    return populatedTransaction;
  });
}
var __awaiter21 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getTransactionFromOrToAttr = (attr, web3Context, transaction, privateKey) => {
  if (transaction !== undefined && attr in transaction && transaction[attr] !== undefined) {
    if (typeof transaction[attr] === "string" && isAddress(transaction[attr])) {
      return transaction[attr];
    }
    if (!isHexStrict(transaction[attr]) && isNumber(transaction[attr])) {
      if (web3Context.wallet) {
        const account2 = web3Context.wallet.get(format({ format: "uint" }, transaction[attr], NUMBER_DATA_FORMAT));
        if (!isNullish(account2)) {
          return account2.address;
        }
        throw new LocalWalletNotAvailableError;
      }
      throw new LocalWalletNotAvailableError;
    } else {
      throw attr === "from" ? new InvalidTransactionWithSender(transaction.from) : new InvalidTransactionWithReceiver(transaction.to);
    }
  }
  if (attr === "from") {
    if (!isNullish(privateKey))
      return privateKeyToAddress(privateKey);
    if (!isNullish(web3Context.defaultAccount))
      return web3Context.defaultAccount;
  }
  return;
};
var getTransactionNonce = (web3Context, address6, returnFormat = DEFAULT_RETURN_FORMAT) => __awaiter21(undefined, undefined, undefined, function* () {
  if (isNullish(address6)) {
    throw new UnableToPopulateNonceError;
  }
  return getTransactionCount2(web3Context, address6, web3Context.defaultBlock, returnFormat);
});
var getTransactionType = (transaction, web3Context) => {
  const inferredType = detectTransactionType(transaction, web3Context);
  if (!isNullish(inferredType))
    return inferredType;
  if (!isNullish(web3Context.defaultTransactionType))
    return format({ format: "uint" }, web3Context.defaultTransactionType, ETH_DATA_FORMAT);
  return;
};
var transactionBuilder = (options) => __awaiter21(undefined, undefined, undefined, function* () {
  var _a4;
  return ((_a4 = options.web3Context.transactionBuilder) !== null && _a4 !== undefined ? _a4 : defaultTransactionBuilder)(Object.assign(Object.assign({}, options), { transaction: options.transaction }));
});

// node_modules/web3-eth/lib/esm/utils/reject_if_block_timeout.js
var resolveByPolling = function(web3Context, starterBlockNumber, transactionHash) {
  const pollingInterval = web3Context.transactionPollingInterval;
  const [intervalId, promiseToError] = rejectIfConditionAtInterval(() => __awaiter22(this, undefined, undefined, function* () {
    let lastBlockNumber;
    try {
      lastBlockNumber = yield getBlockNumber2(web3Context, NUMBER_DATA_FORMAT);
    } catch (error) {
      console.warn("An error happen while trying to get the block number", error);
      return;
    }
    const numberOfBlocks = lastBlockNumber - starterBlockNumber;
    if (numberOfBlocks >= web3Context.transactionBlockTimeout) {
      return new TransactionBlockTimeoutError({
        starterBlockNumber,
        numberOfBlocks,
        transactionHash
      });
    }
    return;
  }), pollingInterval);
  const clean = () => {
    clearInterval(intervalId);
  };
  return [promiseToError, { clean }];
};
var resolveBySubscription = function(web3Context, starterBlockNumber, transactionHash) {
  var _a4;
  return __awaiter22(this, undefined, undefined, function* () {
    let needToWatchLater = true;
    let subscription;
    let resourceCleaner;
    function revertToPolling(reject, previousError) {
      if (previousError) {
        console.warn("error happened at subscription. So revert to polling...", previousError);
      }
      resourceCleaner.clean();
      needToWatchLater = false;
      const [promiseToError2, newResourceCleaner] = resolveByPolling(web3Context, starterBlockNumber, transactionHash);
      resourceCleaner.clean = newResourceCleaner.clean;
      promiseToError2.catch((error) => reject(error));
    }
    try {
      subscription = yield (_a4 = web3Context.subscriptionManager) === null || _a4 === undefined ? undefined : _a4.subscribe("newHeads");
      resourceCleaner = {
        clean: () => {
          var _a5;
          if (subscription.id) {
            (_a5 = web3Context.subscriptionManager) === null || _a5 === undefined || _a5.removeSubscription(subscription).then(() => {
            }).catch(() => {
            });
          }
        }
      };
    } catch (error) {
      return resolveByPolling(web3Context, starterBlockNumber, transactionHash);
    }
    const promiseToError = new Promise((_, reject) => {
      try {
        subscription.on("data", (lastBlockHeader) => {
          needToWatchLater = false;
          if (!(lastBlockHeader === null || lastBlockHeader === undefined ? undefined : lastBlockHeader.number)) {
            return;
          }
          const numberOfBlocks = Number(BigInt(lastBlockHeader.number) - BigInt(starterBlockNumber));
          if (numberOfBlocks >= web3Context.transactionBlockTimeout) {
            reject(new TransactionBlockTimeoutError({
              starterBlockNumber,
              numberOfBlocks,
              transactionHash
            }));
          }
        });
        subscription.on("error", (error) => {
          revertToPolling(reject, error);
        });
      } catch (error) {
        revertToPolling(reject, error);
      }
      setTimeout(() => {
        if (needToWatchLater) {
          revertToPolling(reject);
        }
      }, web3Context.blockHeaderTimeout * 1000);
    });
    return [promiseToError, resourceCleaner];
  });
};
function rejectIfBlockTimeout(web3Context, transactionHash) {
  var _a4, _b;
  return __awaiter22(this, undefined, undefined, function* () {
    const { provider } = web3Context.requestManager;
    let callingRes;
    const starterBlockNumber = yield getBlockNumber2(web3Context, NUMBER_DATA_FORMAT);
    if (((_b = (_a4 = provider).supportsSubscriptions) === null || _b === undefined ? undefined : _b.call(_a4)) && web3Context.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout) {
      callingRes = yield resolveBySubscription(web3Context, starterBlockNumber, transactionHash);
    } else {
      callingRes = resolveByPolling(web3Context, starterBlockNumber, transactionHash);
    }
    return callingRes;
  });
}
var __awaiter22 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-eth/lib/esm/utils/try_send_transaction.js
function trySendTransaction(web3Context, sendTransactionFunc, transactionHash) {
  return __awaiter23(this, undefined, undefined, function* () {
    const [timeoutId, rejectOnTimeout] = rejectIfTimeout(web3Context.transactionSendTimeout, new TransactionSendTimeoutError({
      numberOfSeconds: web3Context.transactionSendTimeout / 1000,
      transactionHash
    }));
    const [rejectOnBlockTimeout, blockTimeoutResourceCleaner] = yield rejectIfBlockTimeout(web3Context, transactionHash);
    try {
      return yield Promise.race([
        sendTransactionFunc(),
        rejectOnTimeout,
        rejectOnBlockTimeout
      ]);
    } finally {
      clearTimeout(timeoutId);
      blockTimeoutResourceCleaner.clean();
    }
  });
}
var __awaiter23 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-eth/lib/esm/utils/wait_for_transaction_receipt.js
function waitForTransactionReceipt(web3Context, transactionHash, returnFormat) {
  var _a4;
  return __awaiter24(this, undefined, undefined, function* () {
    const pollingInterval = (_a4 = web3Context.transactionReceiptPollingInterval) !== null && _a4 !== undefined ? _a4 : web3Context.transactionPollingInterval;
    const [awaitableTransactionReceipt, IntervalId] = pollTillDefinedAndReturnIntervalId(() => __awaiter24(this, undefined, undefined, function* () {
      try {
        return getTransactionReceipt2(web3Context, transactionHash, returnFormat);
      } catch (error) {
        console.warn("An error happen while trying to get the transaction receipt", error);
        return;
      }
    }), pollingInterval);
    const [timeoutId, rejectOnTimeout] = rejectIfTimeout(web3Context.transactionPollingTimeout, new TransactionPollingTimeoutError({
      numberOfSeconds: web3Context.transactionPollingTimeout / 1000,
      transactionHash
    }));
    const [rejectOnBlockTimeout, blockTimeoutResourceCleaner] = yield rejectIfBlockTimeout(web3Context, transactionHash);
    try {
      return yield Promise.race([
        awaitableTransactionReceipt,
        rejectOnTimeout,
        rejectOnBlockTimeout
      ]);
    } finally {
      if (timeoutId)
        clearTimeout(timeoutId);
      if (IntervalId)
        clearInterval(IntervalId);
      blockTimeoutResourceCleaner.clean();
    }
  });
}
var __awaiter24 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-eth/lib/esm/utils/watch_transaction_by_polling.js
var __awaiter25 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var watchTransactionByPolling = ({ web3Context, transactionReceipt, transactionPromiEvent, returnFormat }) => {
  var _a4;
  let confirmations = 1;
  const intervalId = setInterval(() => {
    (() => __awaiter25(undefined, undefined, undefined, function* () {
      if (confirmations >= web3Context.transactionConfirmationBlocks)
        clearInterval(intervalId);
      const nextBlock = yield exports_eth_rpc_methods.getBlockByNumber(web3Context.requestManager, numberToHex2(BigInt(transactionReceipt.blockNumber) + BigInt(confirmations)), false);
      if (nextBlock === null || nextBlock === undefined ? undefined : nextBlock.hash) {
        confirmations += 1;
        transactionPromiEvent.emit("confirmation", {
          confirmations: format({ format: "uint" }, confirmations, returnFormat),
          receipt: format(transactionReceiptSchema, transactionReceipt, returnFormat),
          latestBlockHash: format({ format: "bytes32" }, nextBlock.hash, returnFormat)
        });
      }
    }))();
  }, (_a4 = web3Context.transactionReceiptPollingInterval) !== null && _a4 !== undefined ? _a4 : web3Context.transactionPollingInterval);
};

// node_modules/web3-eth/lib/esm/utils/watch_transaction_by_subscription.js
var __awaiter26 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var watchTransactionBySubscription = ({ web3Context, transactionReceipt, transactionPromiEvent, returnFormat }) => {
  let needToWatchLater = true;
  let lastCaughtBlockHash;
  setImmediate(() => {
    var _a4;
    (_a4 = web3Context.subscriptionManager) === null || _a4 === undefined || _a4.subscribe("newHeads").then((subscription) => {
      subscription.on("data", (newBlockHeader) => __awaiter26(undefined, undefined, undefined, function* () {
        var _a5;
        needToWatchLater = false;
        if (!(newBlockHeader === null || newBlockHeader === undefined ? undefined : newBlockHeader.number) || lastCaughtBlockHash === (newBlockHeader === null || newBlockHeader === undefined ? undefined : newBlockHeader.parentHash)) {
          return;
        }
        lastCaughtBlockHash = newBlockHeader === null || newBlockHeader === undefined ? undefined : newBlockHeader.parentHash;
        const confirmations = BigInt(newBlockHeader.number) - BigInt(transactionReceipt.blockNumber) + BigInt(1);
        transactionPromiEvent.emit("confirmation", {
          confirmations: format({ format: "uint" }, confirmations, returnFormat),
          receipt: format(transactionReceiptSchema, transactionReceipt, returnFormat),
          latestBlockHash: format({ format: "bytes32" }, newBlockHeader.parentHash, returnFormat)
        });
        if (confirmations >= web3Context.transactionConfirmationBlocks) {
          yield (_a5 = web3Context.subscriptionManager) === null || _a5 === undefined ? undefined : _a5.removeSubscription(subscription);
        }
      }));
      subscription.on("error", () => __awaiter26(undefined, undefined, undefined, function* () {
        var _b;
        yield (_b = web3Context.subscriptionManager) === null || _b === undefined ? undefined : _b.removeSubscription(subscription);
        needToWatchLater = false;
        watchTransactionByPolling({
          web3Context,
          transactionReceipt,
          transactionPromiEvent,
          returnFormat
        });
      }));
    }).catch(() => {
      needToWatchLater = false;
      watchTransactionByPolling({
        web3Context,
        transactionReceipt,
        transactionPromiEvent,
        returnFormat
      });
    });
  });
  setTimeout(() => {
    if (needToWatchLater) {
      watchTransactionByPolling({
        web3Context,
        transactionReceipt,
        transactionPromiEvent,
        returnFormat
      });
    }
  }, web3Context.blockHeaderTimeout * 1000);
};

// node_modules/web3-eth/lib/esm/utils/watch_transaction_for_confirmations.js
function watchTransactionForConfirmations(web3Context, transactionPromiEvent, transactionReceipt, transactionHash, returnFormat) {
  if (isNullish(transactionReceipt) || isNullish(transactionReceipt.blockHash))
    throw new TransactionMissingReceiptOrBlockHashError({
      receipt: transactionReceipt,
      blockHash: format({ format: "bytes32" }, transactionReceipt === null || transactionReceipt === undefined ? undefined : transactionReceipt.blockHash, returnFormat),
      transactionHash: format({ format: "bytes32" }, transactionHash, returnFormat)
    });
  if (!transactionReceipt.blockNumber)
    throw new TransactionReceiptMissingBlockNumberError({ receipt: transactionReceipt });
  transactionPromiEvent.emit("confirmation", {
    confirmations: format({ format: "uint" }, 1, returnFormat),
    receipt: format(transactionReceiptSchema, transactionReceipt, returnFormat),
    latestBlockHash: format({ format: "bytes32" }, transactionReceipt.blockHash, returnFormat)
  });
  const provider = web3Context.requestManager.provider;
  if (provider && "supportsSubscriptions" in provider && provider.supportsSubscriptions()) {
    watchTransactionBySubscription({
      web3Context,
      transactionReceipt,
      transactionPromiEvent,
      returnFormat
    });
  } else {
    watchTransactionByPolling({
      web3Context,
      transactionReceipt,
      transactionPromiEvent,
      returnFormat
    });
  }
}

// node_modules/web3-eth-abi/lib/esm/utils.js
var isAbiErrorFragment = (item) => !isNullish2(item) && typeof item === "object" && !isNullish2(item.type) && item.type === "error";
var isAbiEventFragment = (item) => !isNullish2(item) && typeof item === "object" && !isNullish2(item.type) && item.type === "event";
var isAbiFunctionFragment = (item) => !isNullish2(item) && typeof item === "object" && !isNullish2(item.type) && item.type === "function";
var isAbiConstructorFragment = (item) => !isNullish2(item) && typeof item === "object" && !isNullish2(item.type) && item.type === "constructor";
var isSimplifiedStructFormat = (type) => typeof type === "object" && typeof type.components === "undefined" && typeof type.name === "undefined";
var mapStructNameAndType = (structName) => structName.includes("[]") ? { type: "tuple[]", name: structName.slice(0, -2) } : { type: "tuple", name: structName };
var mapStructToCoderFormat = (struct) => {
  const components = [];
  for (const key of Object.keys(struct)) {
    const item = struct[key];
    if (typeof item === "object") {
      components.push(Object.assign(Object.assign({}, mapStructNameAndType(key)), { components: mapStructToCoderFormat(item) }));
    } else {
      components.push({
        name: key,
        type: struct[key]
      });
    }
  }
  return components;
};
var flattenTypes = (includeTuple, puts) => {
  const types12 = [];
  puts.forEach((param) => {
    if (typeof param.components === "object") {
      if (!param.type.startsWith("tuple")) {
        throw new AbiError(`Invalid value given "${param.type}". Error: components found but type is not tuple.`);
      }
      const arrayBracket = param.type.indexOf("[");
      const suffix = arrayBracket >= 0 ? param.type.substring(arrayBracket) : "";
      const result = flattenTypes(includeTuple, param.components);
      if (Array.isArray(result) && includeTuple) {
        types12.push(`tuple(${result.join(",")})${suffix}`);
      } else if (!includeTuple) {
        types12.push(`(${result.join(",")})${suffix}`);
      } else {
        types12.push(`(${result.join()})`);
      }
    } else {
      types12.push(param.type);
    }
  });
  return types12;
};
var jsonInterfaceMethodToString = (json) => {
  var _a4, _b, _c, _d;
  if (isAbiErrorFragment(json) || isAbiEventFragment(json) || isAbiFunctionFragment(json)) {
    if ((_a4 = json.name) === null || _a4 === undefined ? undefined : _a4.includes("(")) {
      return json.name;
    }
    return `${(_b = json.name) !== null && _b !== undefined ? _b : ""}(${flattenTypes(false, (_c = json.inputs) !== null && _c !== undefined ? _c : []).join(",")})`;
  }
  return `(${flattenTypes(false, (_d = json.inputs) !== null && _d !== undefined ? _d : []).join(",")})`;
};

// node_modules/web3-eth-abi/lib/esm/api/errors_api.js
var encodeErrorSignature = (functionName) => {
  if (typeof functionName !== "string" && !isAbiErrorFragment(functionName)) {
    throw new AbiError("Invalid parameter value in encodeErrorSignature");
  }
  let name;
  if (functionName && (typeof functionName === "function" || typeof functionName === "object")) {
    name = jsonInterfaceMethodToString(functionName);
  } else {
    name = functionName;
  }
  return sha3Raw(name);
};
// node_modules/web3-eth-abi/lib/esm/api/events_api.js
var encodeEventSignature = (functionName) => {
  if (typeof functionName !== "string" && !isAbiEventFragment(functionName)) {
    throw new AbiError("Invalid parameter value in encodeEventSignature");
  }
  let name;
  if (functionName && (typeof functionName === "function" || typeof functionName === "object")) {
    name = jsonInterfaceMethodToString(functionName);
  } else {
    name = functionName;
  }
  return sha3Raw(name);
};
// node_modules/web3-eth-abi/lib/esm/coders/utils.js
var import_abitype = __toESM(require_dist2(), 1);
function alloc(size = 0) {
  var _a4;
  if (((_a4 = globalThis.Buffer) === null || _a4 === undefined ? undefined : _a4.alloc) !== undefined) {
    const buf = globalThis.Buffer.alloc(size);
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return new Uint8Array(size);
}
function convertExternalAbiParameter(abiParam) {
  var _a4, _b;
  return Object.assign(Object.assign({}, abiParam), { name: (_a4 = abiParam.name) !== null && _a4 !== undefined ? _a4 : "", components: (_b = abiParam.components) === null || _b === undefined ? undefined : _b.map((c) => convertExternalAbiParameter(c)) });
}
function isAbiParameter(param) {
  return !isNullish2(param) && typeof param === "object" && !isNullish2(param.type) && typeof param.type === "string";
}
function toAbiParams(abi2) {
  return abi2.map((input) => {
    var _a4;
    if (isAbiParameter(input)) {
      return input;
    }
    if (typeof input === "string") {
      return convertExternalAbiParameter(import_abitype.parseAbiParameter(input.replace(/tuple/, "")));
    }
    if (isSimplifiedStructFormat(input)) {
      const structName = Object.keys(input)[0];
      const structInfo = mapStructNameAndType(structName);
      structInfo.name = (_a4 = structInfo.name) !== null && _a4 !== undefined ? _a4 : "";
      return Object.assign(Object.assign({}, structInfo), { components: mapStructToCoderFormat(input[structName]) });
    }
    throw new AbiError("Invalid abi");
  });
}
function extractArrayType(param) {
  const arrayParenthesisStart = param.type.lastIndexOf("[");
  const arrayParamType = param.type.substring(0, arrayParenthesisStart);
  const sizeString = param.type.substring(arrayParenthesisStart);
  let size = -1;
  if (sizeString !== "[]") {
    size = Number(sizeString.slice(1, -1));
    if (isNaN(size)) {
      throw new AbiError("Invalid fixed array size", { size: sizeString });
    }
  }
  return {
    param: { type: arrayParamType, name: "", components: param.components },
    size
  };
}
function isDynamic(param) {
  var _a4, _b;
  if (param.type === "string" || param.type === "bytes" || param.type.endsWith("[]"))
    return true;
  if (param.type === "tuple") {
    return (_b = (_a4 = param.components) === null || _a4 === undefined ? undefined : _a4.some(isDynamic)) !== null && _b !== undefined ? _b : false;
  }
  if (param.type.endsWith("]")) {
    return isDynamic(extractArrayType(param).param);
  }
  return false;
}
var WORD_SIZE = 32;

// node_modules/web3-eth-abi/lib/esm/coders/base/address.js
function encodeAddress(param, input) {
  if (typeof input !== "string") {
    throw new AbiError("address type expects string as input type", {
      value: input,
      name: param.name,
      type: param.type
    });
  }
  let address6 = input.toLowerCase();
  if (!address6.startsWith("0x")) {
    address6 = `0x${address6}`;
  }
  if (!isAddress(address6)) {
    throw new AbiError("provided input is not valid address", {
      value: input,
      name: param.name,
      type: param.type
    });
  }
  const addressBytes = exports_utils.hexToUint8Array(address6);
  const encoded = alloc(WORD_SIZE);
  encoded.set(addressBytes, ADDRESS_OFFSET);
  return {
    dynamic: false,
    encoded
  };
}
function decodeAddress(_param, bytes5) {
  const addressBytes = bytes5.subarray(ADDRESS_OFFSET, WORD_SIZE);
  if (addressBytes.length !== ADDRESS_BYTES_COUNT) {
    throw new AbiError("Invalid decoding input, not enough bytes to decode address", { bytes: bytes5 });
  }
  const result = exports_utils.uint8ArrayToHexString(addressBytes);
  return {
    result: toChecksumAddress(result),
    encoded: bytes5.subarray(WORD_SIZE),
    consumed: WORD_SIZE
  };
}
var ADDRESS_BYTES_COUNT = 20;
var ADDRESS_OFFSET = WORD_SIZE - ADDRESS_BYTES_COUNT;

// node_modules/web3-eth-abi/lib/esm/coders/base/numbersLimits.js
var numberLimits = new Map;
var base = BigInt(256);
for (let i = 8;i <= 256; i += 8) {
  numberLimits.set(`uint${i}`, {
    min: BigInt(0),
    max: base - BigInt(1)
  });
  numberLimits.set(`int${i}`, {
    min: -base / BigInt(2),
    max: base / BigInt(2) - BigInt(1)
  });
  base *= BigInt(256);
}
numberLimits.set(`int`, numberLimits.get("int256"));
numberLimits.set(`uint`, numberLimits.get("uint256"));

// node_modules/web3-eth-abi/lib/esm/coders/base/number.js
var bigIntToUint8Array2 = function(value, byteLength = WORD_SIZE) {
  let hexValue;
  if (value < 0) {
    hexValue = (mask + value).toString(16);
  } else {
    hexValue = value.toString(16);
  }
  hexValue = padLeft2(hexValue, byteLength * 2);
  return exports_utils.hexToUint8Array(hexValue);
};
var uint8ArrayToBigInt2 = function(value, max) {
  const hexValue = exports_utils.uint8ArrayToHexString(value);
  const result = BigInt(hexValue);
  if (result <= max)
    return result;
  return result - mask;
};
function encodeNumber(param, input) {
  let value;
  try {
    value = toBigInt(input);
  } catch (e) {
    throw new AbiError("provided input is not number value", {
      type: param.type,
      value: input,
      name: param.name
    });
  }
  const limit = numberLimits.get(param.type);
  if (!limit) {
    throw new AbiError("provided abi contains invalid number datatype", { type: param.type });
  }
  if (value < limit.min) {
    throw new AbiError("provided input is less then minimum for given type", {
      type: param.type,
      value: input,
      name: param.name,
      minimum: limit.min.toString()
    });
  }
  if (value > limit.max) {
    throw new AbiError("provided input is greater then maximum for given type", {
      type: param.type,
      value: input,
      name: param.name,
      maximum: limit.max.toString()
    });
  }
  return {
    dynamic: false,
    encoded: bigIntToUint8Array2(value)
  };
}
function decodeNumber(param, bytes5) {
  if (bytes5.length < WORD_SIZE) {
    throw new AbiError("Not enough bytes left to decode", { param, bytesLeft: bytes5.length });
  }
  const boolBytes = bytes5.subarray(0, WORD_SIZE);
  const limit = numberLimits.get(param.type);
  if (!limit) {
    throw new AbiError("provided abi contains invalid number datatype", { type: param.type });
  }
  const numberResult = uint8ArrayToBigInt2(boolBytes, limit.max);
  if (numberResult < limit.min) {
    throw new AbiError("decoded value is less then minimum for given type", {
      type: param.type,
      value: numberResult,
      name: param.name,
      minimum: limit.min.toString()
    });
  }
  if (numberResult > limit.max) {
    throw new AbiError("decoded value is greater then maximum for given type", {
      type: param.type,
      value: numberResult,
      name: param.name,
      maximum: limit.max.toString()
    });
  }
  return {
    result: numberResult,
    encoded: bytes5.subarray(WORD_SIZE),
    consumed: WORD_SIZE
  };
}
var mask = BigInt(1) << BigInt(256);

// node_modules/web3-eth-abi/lib/esm/coders/base/bool.js
function encodeBoolean(param, input) {
  let value;
  try {
    value = toBool(input);
  } catch (e) {
    if (e instanceof InvalidBooleanError) {
      throw new AbiError("provided input is not valid boolean value", {
        type: param.type,
        value: input,
        name: param.name
      });
    }
  }
  return encodeNumber({ type: "uint8", name: "" }, Number(value));
}
function decodeBool(_param, bytes5) {
  const numberResult = decodeNumber({ type: "uint8", name: "" }, bytes5);
  if (numberResult.result > 1 || numberResult.result < 0) {
    throw new AbiError("Invalid boolean value encoded", {
      boolBytes: bytes5.subarray(0, WORD_SIZE),
      numberResult
    });
  }
  return {
    result: numberResult.result === BigInt(1),
    encoded: numberResult.encoded,
    consumed: WORD_SIZE
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/bytes.js
function encodeBytes(param, input) {
  if (typeof input === "string" && input.length % 2 !== 0) {
    input += "0";
  }
  if (!isBytes3(input)) {
    throw new AbiError("provided input is not valid bytes value", {
      type: param.type,
      value: input,
      name: param.name
    });
  }
  const bytes5 = bytesToUint8Array(input);
  const [, size] = param.type.split("bytes");
  if (size) {
    if (Number(size) > MAX_STATIC_BYTES_COUNT || Number(size) < 1) {
      throw new AbiError("invalid bytes type. Static byte type can have between 1 and 32 bytes", {
        type: param.type
      });
    }
    if (Number(size) < bytes5.length) {
      throw new AbiError("provided input size is different than type size", {
        type: param.type,
        value: input,
        name: param.name
      });
    }
    const encoded2 = alloc(WORD_SIZE);
    encoded2.set(bytes5);
    return {
      dynamic: false,
      encoded: encoded2
    };
  }
  const partsLength = Math.ceil(bytes5.length / WORD_SIZE);
  const encoded = alloc(WORD_SIZE + partsLength * WORD_SIZE);
  encoded.set(encodeNumber({ type: "uint32", name: "" }, bytes5.length).encoded);
  encoded.set(bytes5, WORD_SIZE);
  return {
    dynamic: true,
    encoded
  };
}
function decodeBytes(param, bytes5) {
  const [, sizeString] = param.type.split("bytes");
  let size = Number(sizeString);
  let remainingBytes = bytes5;
  let partsCount = 1;
  let consumed = 0;
  if (!size) {
    const result = decodeNumber({ type: "uint32", name: "" }, remainingBytes);
    size = Number(result.result);
    consumed += result.consumed;
    remainingBytes = result.encoded;
    partsCount = Math.ceil(size / WORD_SIZE);
  }
  if (size > bytes5.length) {
    throw new AbiError("there is not enough data to decode", {
      type: param.type,
      encoded: bytes5,
      size
    });
  }
  return {
    result: bytesToHex2(remainingBytes.subarray(0, size)),
    encoded: remainingBytes.subarray(partsCount * WORD_SIZE),
    consumed: consumed + partsCount * WORD_SIZE
  };
}
var MAX_STATIC_BYTES_COUNT = 32;

// node_modules/web3-eth-abi/lib/esm/coders/base/string.js
function encodeString(_param, input) {
  if (typeof input !== "string") {
    throw new AbiError("invalid input, should be string", { input });
  }
  const bytes6 = utf8ToBytes2(input);
  return encodeBytes({ type: "bytes", name: "" }, bytes6);
}
function decodeString(_param, bytes6) {
  const r = decodeBytes({ type: "bytes", name: "" }, bytes6);
  return {
    result: hexToUtf8(r.result),
    encoded: r.encoded,
    consumed: r.consumed
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/utils.js
function encodeDynamicParams(encodedParams) {
  let staticSize = 0;
  let dynamicSize = 0;
  const staticParams = [];
  const dynamicParams = [];
  for (const encodedParam of encodedParams) {
    if (encodedParam.dynamic) {
      staticSize += WORD_SIZE;
    } else {
      staticSize += encodedParam.encoded.length;
    }
  }
  for (const encodedParam of encodedParams) {
    if (encodedParam.dynamic) {
      staticParams.push(encodeNumber({ type: "uint256", name: "" }, staticSize + dynamicSize));
      dynamicParams.push(encodedParam);
      dynamicSize += encodedParam.encoded.length;
    } else {
      staticParams.push(encodedParam);
    }
  }
  return uint8ArrayConcat(...staticParams.map((p) => p.encoded), ...dynamicParams.map((p) => p.encoded));
}

// node_modules/web3-eth-abi/lib/esm/coders/base/array.js
function encodeArray(param, values) {
  if (!Array.isArray(values)) {
    throw new AbiError("Expected value to be array", { abi: param, values });
  }
  const { size, param: arrayItemParam } = extractArrayType(param);
  const encodedParams = values.map((v) => encodeParamFromAbiParameter(arrayItemParam, v));
  const dynamic = size === -1;
  const dynamicItems = encodedParams.length > 0 && encodedParams[0].dynamic;
  if (!dynamic && values.length !== size) {
    throw new AbiError("Given arguments count doesn't match array length", {
      arrayLength: size,
      argumentsLength: values.length
    });
  }
  if (dynamic || dynamicItems) {
    const encodingResult = encodeDynamicParams(encodedParams);
    if (dynamic) {
      const encodedLength = encodeNumber({ type: "uint256", name: "" }, encodedParams.length).encoded;
      return {
        dynamic: true,
        encoded: encodedParams.length > 0 ? uint8ArrayConcat(encodedLength, encodingResult) : encodedLength
      };
    }
    return {
      dynamic: true,
      encoded: encodingResult
    };
  }
  return {
    dynamic: false,
    encoded: uint8ArrayConcat(...encodedParams.map((p) => p.encoded))
  };
}
function decodeArray(param, bytes6) {
  let { size, param: arrayItemParam } = extractArrayType(param);
  const dynamic = size === -1;
  let consumed = 0;
  const result = [];
  let remaining = bytes6;
  if (dynamic) {
    const lengthResult = decodeNumber({ type: "uint32", name: "" }, bytes6);
    size = Number(lengthResult.result);
    consumed = lengthResult.consumed;
    remaining = lengthResult.encoded;
  }
  const hasDynamicChild = isDynamic(arrayItemParam);
  if (hasDynamicChild) {
    for (let i = 0;i < size; i += 1) {
      const offsetResult = decodeNumber({ type: "uint32", name: "" }, remaining.subarray(i * WORD_SIZE));
      consumed += offsetResult.consumed;
      const decodedChildResult = decodeParamFromAbiParameter(arrayItemParam, remaining.subarray(Number(offsetResult.result)));
      consumed += decodedChildResult.consumed;
      result.push(decodedChildResult.result);
    }
    return {
      result,
      encoded: remaining.subarray(consumed),
      consumed
    };
  }
  for (let i = 0;i < size; i += 1) {
    const decodedChildResult = decodeParamFromAbiParameter(arrayItemParam, bytes6.subarray(consumed));
    consumed += decodedChildResult.consumed;
    result.push(decodedChildResult.result);
  }
  return {
    result,
    encoded: bytes6.subarray(consumed),
    consumed
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/index.js
function encodeParamFromAbiParameter(param, value) {
  if (param.type === "string") {
    return encodeString(param, value);
  }
  if (param.type === "bool") {
    return encodeBoolean(param, value);
  }
  if (param.type === "address") {
    return encodeAddress(param, value);
  }
  if (param.type === "tuple") {
    return encodeTuple(param, value);
  }
  if (param.type.endsWith("]")) {
    return encodeArray(param, value);
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(param, value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    return encodeNumber(param, value);
  }
  throw new AbiError("Unsupported", {
    param,
    value
  });
}
function decodeParamFromAbiParameter(param, bytes7) {
  if (param.type === "string") {
    return decodeString(param, bytes7);
  }
  if (param.type === "bool") {
    return decodeBool(param, bytes7);
  }
  if (param.type === "address") {
    return decodeAddress(param, bytes7);
  }
  if (param.type === "tuple") {
    return decodeTuple(param, bytes7);
  }
  if (param.type.endsWith("]")) {
    return decodeArray(param, bytes7);
  }
  if (param.type.startsWith("bytes")) {
    return decodeBytes(param, bytes7);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    return decodeNumber(param, bytes7);
  }
  throw new AbiError("Unsupported", {
    param,
    bytes: bytes7
  });
}

// node_modules/web3-eth-abi/lib/esm/coders/base/tuple.js
function encodeTuple(param, input) {
  var _a4, _b, _c;
  let dynamic = false;
  if (!Array.isArray(input) && typeof input !== "object") {
    throw new AbiError("param must be either Array or Object", {
      param,
      input
    });
  }
  const narrowedInput = input;
  const encoded = [];
  for (let i = 0;i < ((_b = (_a4 = param.components) === null || _a4 === undefined ? undefined : _a4.length) !== null && _b !== undefined ? _b : 0); i += 1) {
    const paramComponent = param.components[i];
    let result;
    if (Array.isArray(narrowedInput)) {
      if (i >= narrowedInput.length) {
        throw new AbiError("input param length missmatch", {
          param,
          input
        });
      }
      result = encodeParamFromAbiParameter(paramComponent, narrowedInput[i]);
    } else {
      const paramInput = narrowedInput[(_c = paramComponent.name) !== null && _c !== undefined ? _c : ""];
      if (paramInput === undefined || paramInput === null) {
        throw new AbiError("missing input defined in abi", {
          param,
          input,
          paramName: paramComponent.name
        });
      }
      result = encodeParamFromAbiParameter(paramComponent, paramInput);
    }
    if (result.dynamic) {
      dynamic = true;
    }
    encoded.push(result);
  }
  if (dynamic) {
    return {
      dynamic: true,
      encoded: encodeDynamicParams(encoded)
    };
  }
  return {
    dynamic: false,
    encoded: uint8ArrayConcat(...encoded.map((e) => e.encoded))
  };
}
function decodeTuple(param, bytes7) {
  const result = {
    __length__: 0
  };
  let consumed = 0;
  if (!param.components) {
    return {
      result,
      encoded: bytes7,
      consumed
    };
  }
  let dynamicConsumed = 0;
  for (const [index, childParam] of param.components.entries()) {
    let decodedResult;
    if (isDynamic(childParam)) {
      const offsetResult = decodeNumber({ type: "uint32", name: "" }, bytes7.subarray(consumed));
      decodedResult = decodeParamFromAbiParameter(childParam, bytes7.subarray(Number(offsetResult.result)));
      consumed += offsetResult.consumed;
      dynamicConsumed += decodedResult.consumed;
    } else {
      decodedResult = decodeParamFromAbiParameter(childParam, bytes7.subarray(consumed));
      consumed += decodedResult.consumed;
    }
    result.__length__ += 1;
    result[index] = decodedResult.result;
    if (childParam.name && childParam.name !== "") {
      result[childParam.name] = decodedResult.result;
    }
  }
  return {
    encoded: bytes7.subarray(consumed + dynamicConsumed),
    result,
    consumed: consumed + dynamicConsumed
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/decode.js
function decodeParameters(abis, bytes7, _loose) {
  const abiParams = toAbiParams(abis);
  const bytesArray = exports_utils.hexToUint8Array(bytes7);
  return decodeTuple({ type: "tuple", name: "", components: abiParams }, bytesArray).result;
}

// node_modules/web3-eth-abi/lib/esm/coders/encode.js
var inferParamsAbi = function(params) {
  const abi2 = [];
  params.forEach((param) => {
    if (Array.isArray(param)) {
      const inferredParams = inferParamsAbi(param);
      abi2.push({
        type: "tuple",
        components: inferredParams,
        name: ""
      });
    } else {
      abi2.push({ type: toHex(param, true) });
    }
  });
  return abi2;
};
function encodeParameters(abi2, params) {
  if ((abi2 === null || abi2 === undefined ? undefined : abi2.length) !== params.length) {
    throw new AbiError("Invalid number of values received for given ABI", {
      expected: abi2 === null || abi2 === undefined ? undefined : abi2.length,
      received: params.length
    });
  }
  const abiParams = toAbiParams(abi2);
  return exports_utils.uint8ArrayToHexString(encodeTuple({ type: "tuple", name: "", components: abiParams }, params).encoded);
}
function inferTypesAndEncodeParameters(params) {
  try {
    const abiParams = inferParamsAbi(params);
    return exports_utils.uint8ArrayToHexString(encodeTuple({ type: "tuple", name: "", components: abiParams }, params).encoded);
  } catch (e) {
    throw new AbiError("Could not infer types from given params", {
      params
    });
  }
}

// node_modules/web3-eth-abi/lib/esm/api/parameters_api.js
var encodeParameter = (abi2, param) => encodeParameters([abi2], [param]);
var decodeParametersWith = (abis, bytes7, loose) => {
  try {
    if (abis.length > 0 && (!bytes7 || bytes7 === "0x" || bytes7 === "0X")) {
      throw new AbiError("Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.");
    }
    return decodeParameters(abis, `0x${bytes7.replace(/0x/i, "")}`, loose);
  } catch (err) {
    throw new AbiError(`Parameter decoding error: ${err.message}`, {
      internalErr: err
    });
  }
};
var decodeParameters2 = (abi2, bytes7) => decodeParametersWith(abi2, bytes7, false);
var decodeParameter = (abi2, bytes7) => decodeParameters2([abi2], bytes7)["0"];

// node_modules/web3-eth-abi/lib/esm/api/functions_api.js
var encodeFunctionSignature = (functionName) => {
  if (typeof functionName !== "string" && !isAbiFunctionFragment(functionName)) {
    throw new AbiError("Invalid parameter value in encodeFunctionSignature");
  }
  let name;
  if (functionName && (typeof functionName === "function" || typeof functionName === "object")) {
    name = jsonInterfaceMethodToString(functionName);
  } else {
    name = functionName;
  }
  return sha3Raw(name).slice(0, 10);
};
var encodeFunctionCall = (jsonInterface, params) => {
  var _a4;
  if (!isAbiFunctionFragment(jsonInterface)) {
    throw new AbiError("Invalid parameter value in encodeFunctionCall");
  }
  return `${encodeFunctionSignature(jsonInterface)}${encodeParameters((_a4 = jsonInterface.inputs) !== null && _a4 !== undefined ? _a4 : [], params !== null && params !== undefined ? params : []).replace("0x", "")}`;
};
// node_modules/web3-eth-abi/lib/esm/api/logs_api.js
var STATIC_TYPES = ["bool", "string", "int", "uint", "address", "fixed", "ufixed"];
var _decodeParameter = (inputType, clonedTopic) => inputType === "string" ? clonedTopic : decodeParameter(inputType, clonedTopic);
var decodeLog = (inputs, data, topics) => {
  const clonedTopics = Array.isArray(topics) ? topics : [topics];
  const indexedInputs = {};
  const nonIndexedInputs = {};
  for (const [i, input] of inputs.entries()) {
    if (input.indexed) {
      indexedInputs[i] = input;
    } else {
      nonIndexedInputs[i] = input;
    }
  }
  const decodedNonIndexedInputs = data ? decodeParametersWith(Object.values(nonIndexedInputs), data, true) : { __length__: 0 };
  const offset = clonedTopics.length - Object.keys(indexedInputs).length;
  const decodedIndexedInputs = Object.values(indexedInputs).map((input, index) => STATIC_TYPES.some((s) => input.type.startsWith(s)) ? _decodeParameter(input.type, clonedTopics[index + offset]) : clonedTopics[index + offset]);
  const returnValues = { __length__: 0 };
  let indexedCounter = 0;
  let nonIndexedCounter = 0;
  for (const [i, res] of inputs.entries()) {
    returnValues[i] = res.type === "string" ? "" : undefined;
    if (indexedInputs[i]) {
      returnValues[i] = decodedIndexedInputs[indexedCounter];
      indexedCounter += 1;
    }
    if (nonIndexedInputs[i]) {
      returnValues[i] = decodedNonIndexedInputs[String(nonIndexedCounter)];
      nonIndexedCounter += 1;
    }
    if (res.name) {
      returnValues[res.name] = returnValues[i];
    }
    returnValues.__length__ += 1;
  }
  return returnValues;
};
// node_modules/web3-eth-abi/lib/esm/decode_contract_error_data.js
var decodeContractErrorData = (errorsAbi, error) => {
  if (error === null || error === undefined ? undefined : error.data) {
    let errorName;
    let errorSignature;
    let errorArgs;
    try {
      const errorSha = error.data.slice(0, 10);
      const errorAbi = errorsAbi.find((abi2) => encodeErrorSignature(abi2).startsWith(errorSha));
      if (errorAbi === null || errorAbi === undefined ? undefined : errorAbi.inputs) {
        errorName = errorAbi.name;
        errorSignature = jsonInterfaceMethodToString(errorAbi);
        errorArgs = decodeParameters2([...errorAbi.inputs], error.data.substring(10));
      }
    } catch (err) {
      console.error(err);
    }
    if (errorName) {
      error.setDecodedProperties(errorName, errorSignature, errorArgs);
    }
  }
};
// node_modules/web3-eth/lib/esm/utils/get_revert_reason.js
function getRevertReason(web3Context, transaction, contractAbi, returnFormat = DEFAULT_RETURN_FORMAT) {
  return __awaiter27(this, undefined, undefined, function* () {
    try {
      yield call2(web3Context, transaction, web3Context.defaultBlock, returnFormat);
      return;
    } catch (error) {
      return parseTransactionError(error, contractAbi);
    }
  });
}
var __awaiter27 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var parseTransactionError = (error, contractAbi) => {
  var _a4, _b, _c, _d, _e;
  if (error instanceof ContractExecutionError && error.cause instanceof Eip838ExecutionError) {
    if (contractAbi !== undefined) {
      const errorsAbi = contractAbi.filter((abi2) => isAbiErrorFragment(abi2));
      decodeContractErrorData(errorsAbi, error.cause);
      return {
        reason: error.cause.message,
        signature: (_a4 = error.cause.data) === null || _a4 === undefined ? undefined : _a4.slice(0, 10),
        data: (_b = error.cause.data) === null || _b === undefined ? undefined : _b.substring(10),
        customErrorName: error.cause.errorName,
        customErrorDecodedSignature: error.cause.errorSignature,
        customErrorArguments: error.cause.errorArgs
      };
    }
    return {
      reason: error.cause.message,
      signature: (_c = error.cause.data) === null || _c === undefined ? undefined : _c.slice(0, 10),
      data: (_d = error.cause.data) === null || _d === undefined ? undefined : _d.substring(10)
    };
  }
  if (error instanceof InvalidResponseError && !Array.isArray((_e = error.cause) === null || _e === undefined ? undefined : _e.errors) && error.cause !== undefined) {
    return error.cause.message;
  }
  throw error;
};

// node_modules/web3-eth/lib/esm/utils/get_transaction_error.js
function getTransactionError(web3Context, transactionFormatted, transactionReceiptFormatted, receivedError, contractAbi, knownReason) {
  return __awaiter28(this, undefined, undefined, function* () {
    let _reason = knownReason;
    if (_reason === undefined) {
      if (receivedError !== undefined) {
        _reason = parseTransactionError(receivedError);
      } else if (web3Context.handleRevert && transactionFormatted !== undefined) {
        _reason = yield getRevertReason(web3Context, transactionFormatted, contractAbi);
      }
    }
    let error;
    if (_reason === undefined) {
      error = new TransactionRevertedWithoutReasonError(transactionReceiptFormatted);
    } else if (typeof _reason === "string") {
      error = new TransactionRevertInstructionError(_reason, undefined, transactionReceiptFormatted);
    } else if (_reason.customErrorName !== undefined && _reason.customErrorDecodedSignature !== undefined && _reason.customErrorArguments !== undefined) {
      const reasonWithCustomError = _reason;
      error = new TransactionRevertWithCustomError(reasonWithCustomError.reason, reasonWithCustomError.customErrorName, reasonWithCustomError.customErrorDecodedSignature, reasonWithCustomError.customErrorArguments, reasonWithCustomError.signature, transactionReceiptFormatted, reasonWithCustomError.data);
    } else {
      error = new TransactionRevertInstructionError(_reason.reason, _reason.signature, transactionReceiptFormatted, _reason.data);
    }
    return error;
  });
}
var __awaiter28 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-eth/lib/esm/utils/decoding.js
var decodeEventABI = (event, data, jsonInterface, returnFormat = DEFAULT_RETURN_FORMAT) => {
  var _a4, _b, _c, _d, _e;
  let modifiedEvent = Object.assign({}, event);
  const result = format(logSchema, data, returnFormat);
  if ([ALL_EVENTS, "allEvents"].includes(modifiedEvent.name)) {
    const matchedEvent = jsonInterface.find((j) => j.signature === data.topics[0]);
    if (matchedEvent) {
      modifiedEvent = matchedEvent;
    } else {
      modifiedEvent = { anonymous: true };
    }
  }
  modifiedEvent.inputs = (_b = (_a4 = modifiedEvent.inputs) !== null && _a4 !== undefined ? _a4 : event.inputs) !== null && _b !== undefined ? _b : [];
  if (!modifiedEvent.anonymous) {
    let indexedInputs = 0;
    ((_c = modifiedEvent.inputs) !== null && _c !== undefined ? _c : []).forEach((input) => {
      if (input.indexed) {
        indexedInputs += 1;
      }
    });
    if (indexedInputs > 0 && (data === null || data === undefined ? undefined : data.topics) && (data === null || data === undefined ? undefined : data.topics.length) !== indexedInputs + 1) {
      modifiedEvent = Object.assign(Object.assign({}, modifiedEvent), { anonymous: true, inputs: [] });
    }
  }
  const argTopics = modifiedEvent.anonymous ? data.topics : ((_d = data.topics) !== null && _d !== undefined ? _d : []).slice(1);
  return Object.assign(Object.assign({}, result), { returnValues: decodeLog([...(_e = modifiedEvent.inputs) !== null && _e !== undefined ? _e : []], data.data, argTopics), event: modifiedEvent.name, signature: modifiedEvent.anonymous || !data.topics || data.topics.length === 0 || !data.topics[0] ? undefined : data.topics[0], raw: {
    data: data.data,
    topics: data.topics
  } });
};

// node_modules/web3-eth/lib/esm/utils/send_tx_helper.js
var __awaiter29 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class SendTxHelper {
  constructor({ options, web3Context, promiEvent, returnFormat }) {
    this.options = {
      checkRevertBeforeSending: true
    };
    this.options = options;
    this.web3Context = web3Context;
    this.promiEvent = promiEvent;
    this.returnFormat = returnFormat;
  }
  getReceiptWithEvents(data) {
    var _a4, _b;
    const result = Object.assign({}, data !== null && data !== undefined ? data : {});
    if (((_a4 = this.options) === null || _a4 === undefined ? undefined : _a4.contractAbi) && result.logs && result.logs.length > 0) {
      result.events = {};
      for (const log of result.logs) {
        const event = decodeEventABI(ALL_EVENTS_ABI, log, (_b = this.options) === null || _b === undefined ? undefined : _b.contractAbi, this.returnFormat);
        if (event.event) {
          result.events[event.event] = event;
        }
      }
    }
    return result;
  }
  checkRevertBeforeSending(tx2) {
    return __awaiter29(this, undefined, undefined, function* () {
      if (this.options.checkRevertBeforeSending !== false) {
        const reason = yield getRevertReason(this.web3Context, tx2, this.options.contractAbi);
        if (reason !== undefined) {
          throw yield getTransactionError(this.web3Context, tx2, undefined, undefined, this.options.contractAbi, reason);
        }
      }
    });
  }
  emitSending(tx2) {
    if (this.promiEvent.listenerCount("sending") > 0) {
      this.promiEvent.emit("sending", tx2);
    }
  }
  populateGasPrice({ transactionFormatted, transaction }) {
    var _a4;
    return __awaiter29(this, undefined, undefined, function* () {
      let result = transactionFormatted;
      if (!((_a4 = this.options) === null || _a4 === undefined ? undefined : _a4.ignoreGasPricing) && isNullish(transactionFormatted.gasPrice) && (isNullish(transaction.maxPriorityFeePerGas) || isNullish(transaction.maxFeePerGas))) {
        result = Object.assign(Object.assign({}, transactionFormatted), yield getTransactionGasPricing(transactionFormatted, this.web3Context, ETH_DATA_FORMAT));
      }
      return result;
    });
  }
  signAndSend({ wallet: wallet2, tx: tx2 }) {
    return __awaiter29(this, undefined, undefined, function* () {
      if (wallet2) {
        const signedTransaction = yield wallet2.signTransaction(tx2);
        return trySendTransaction(this.web3Context, () => __awaiter29(this, undefined, undefined, function* () {
          return exports_eth_rpc_methods.sendRawTransaction(this.web3Context.requestManager, signedTransaction.rawTransaction);
        }), signedTransaction.transactionHash);
      }
      return trySendTransaction(this.web3Context, () => __awaiter29(this, undefined, undefined, function* () {
        return exports_eth_rpc_methods.sendTransaction(this.web3Context.requestManager, tx2);
      }));
    });
  }
  emitSent(tx2) {
    if (this.promiEvent.listenerCount("sent") > 0) {
      this.promiEvent.emit("sent", tx2);
    }
  }
  emitTransactionHash(hash3) {
    if (this.promiEvent.listenerCount("transactionHash") > 0) {
      this.promiEvent.emit("transactionHash", hash3);
    }
  }
  emitReceipt(receipt) {
    if (this.promiEvent.listenerCount("receipt") > 0) {
      this.promiEvent.emit("receipt", receipt);
    }
  }
  handleError({ error, tx: tx2 }) {
    var _a4;
    return __awaiter29(this, undefined, undefined, function* () {
      let _error = error;
      if (_error instanceof ContractExecutionError && this.web3Context.handleRevert) {
        _error = yield getTransactionError(this.web3Context, tx2, undefined, undefined, (_a4 = this.options) === null || _a4 === undefined ? undefined : _a4.contractAbi);
      }
      if ((_error instanceof InvalidResponseError || _error instanceof ContractExecutionError || _error instanceof TransactionRevertWithCustomError || _error instanceof TransactionRevertedWithoutReasonError || _error instanceof TransactionRevertInstructionError || _error instanceof TransactionPollingTimeoutError) && this.promiEvent.listenerCount("error") > 0) {
        this.promiEvent.emit("error", _error);
      }
      return _error;
    });
  }
  emitConfirmation({ receipt, transactionHash }) {
    if (this.promiEvent.listenerCount("confirmation") > 0) {
      watchTransactionForConfirmations(this.web3Context, this.promiEvent, receipt, transactionHash, this.returnFormat);
    }
  }
  handleResolve({ receipt, tx: tx2 }) {
    var _a4, _b, _c;
    return __awaiter29(this, undefined, undefined, function* () {
      if ((_a4 = this.options) === null || _a4 === undefined ? undefined : _a4.transactionResolver) {
        return (_b = this.options) === null || _b === undefined ? undefined : _b.transactionResolver(receipt);
      }
      if (receipt.status === BigInt(0)) {
        const error = yield getTransactionError(this.web3Context, tx2, receipt, undefined, (_c = this.options) === null || _c === undefined ? undefined : _c.contractAbi);
        if (this.promiEvent.listenerCount("error") > 0) {
          this.promiEvent.emit("error", error);
        }
        throw error;
      } else {
        return receipt;
      }
    });
  }
}

// node_modules/web3-eth/lib/esm/rpc_method_wrappers.js
function getHashRate2(web3Context, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.getHashRate(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getGasPrice2(web3Context, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.getGasPrice(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getMaxPriorityFeePerGas2(web3Context, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.getMaxPriorityFeePerGas(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getBlockNumber2(web3Context, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.getBlockNumber(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getBalance2(web3Context, address7, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.getBalance(web3Context.requestManager, address7, blockNumberFormatted);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getStorageAt2(web3Context, address7, storageSlot, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const storageSlotFormatted = format({ format: "uint" }, storageSlot, ETH_DATA_FORMAT);
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.getStorageAt(web3Context.requestManager, address7, storageSlotFormatted, blockNumberFormatted);
    return format({ format: "bytes" }, response, returnFormat);
  });
}
function getCode2(web3Context, address7, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.getCode(web3Context.requestManager, address7, blockNumberFormatted);
    return format({ format: "bytes" }, response, returnFormat);
  });
}
function getBlock(web3Context, block4 = web3Context.defaultBlock, hydrated = false, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    let response;
    if (isBytes3(block4)) {
      const blockHashFormatted = format({ format: "bytes32" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getBlockByHash(web3Context.requestManager, blockHashFormatted, hydrated);
    } else {
      const blockNumberFormatted = isBlockTag(block4) ? block4 : format({ format: "uint" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getBlockByNumber(web3Context.requestManager, blockNumberFormatted, hydrated);
    }
    return format(blockSchema, response, returnFormat);
  });
}
function getBlockTransactionCount(web3Context, block4 = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    let response;
    if (isBytes3(block4)) {
      const blockHashFormatted = format({ format: "bytes32" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getBlockTransactionCountByHash(web3Context.requestManager, blockHashFormatted);
    } else {
      const blockNumberFormatted = isBlockTag(block4) ? block4 : format({ format: "uint" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getBlockTransactionCountByNumber(web3Context.requestManager, blockNumberFormatted);
    }
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getBlockUncleCount(web3Context, block4 = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    let response;
    if (isBytes3(block4)) {
      const blockHashFormatted = format({ format: "bytes32" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getUncleCountByBlockHash(web3Context.requestManager, blockHashFormatted);
    } else {
      const blockNumberFormatted = isBlockTag(block4) ? block4 : format({ format: "uint" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getUncleCountByBlockNumber(web3Context.requestManager, blockNumberFormatted);
    }
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getUncle(web3Context, block4 = web3Context.defaultBlock, uncleIndex, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const uncleIndexFormatted = format({ format: "uint" }, uncleIndex, ETH_DATA_FORMAT);
    let response;
    if (isBytes3(block4)) {
      const blockHashFormatted = format({ format: "bytes32" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getUncleByBlockHashAndIndex(web3Context.requestManager, blockHashFormatted, uncleIndexFormatted);
    } else {
      const blockNumberFormatted = isBlockTag(block4) ? block4 : format({ format: "uint" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getUncleByBlockNumberAndIndex(web3Context.requestManager, blockNumberFormatted, uncleIndexFormatted);
    }
    return format(blockSchema, response, returnFormat);
  });
}
function getTransaction(web3Context, transactionHash, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const transactionHashFormatted = format({ format: "bytes32" }, transactionHash, DEFAULT_RETURN_FORMAT);
    const response = yield exports_eth_rpc_methods.getTransactionByHash(web3Context.requestManager, transactionHashFormatted);
    return isNullish(response) ? response : formatTransaction(response, returnFormat, { fillInputAndData: true });
  });
}
function getPendingTransactions2(web3Context, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.getPendingTransactions(web3Context.requestManager);
    return response.map((transaction) => formatTransaction(transaction, returnFormat, {
      fillInputAndData: true
    }));
  });
}
function getTransactionFromBlock(web3Context, block4 = web3Context.defaultBlock, transactionIndex, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const transactionIndexFormatted = format({ format: "uint" }, transactionIndex, ETH_DATA_FORMAT);
    let response;
    if (isBytes3(block4)) {
      const blockHashFormatted = format({ format: "bytes32" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getTransactionByBlockHashAndIndex(web3Context.requestManager, blockHashFormatted, transactionIndexFormatted);
    } else {
      const blockNumberFormatted = isBlockTag(block4) ? block4 : format({ format: "uint" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getTransactionByBlockNumberAndIndex(web3Context.requestManager, blockNumberFormatted, transactionIndexFormatted);
    }
    return isNullish(response) ? response : formatTransaction(response, returnFormat, { fillInputAndData: true });
  });
}
function getTransactionReceipt2(web3Context, transactionHash, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const transactionHashFormatted = format({ format: "bytes32" }, transactionHash, DEFAULT_RETURN_FORMAT);
    const response = yield exports_eth_rpc_methods.getTransactionReceipt(web3Context.requestManager, transactionHashFormatted);
    return isNullish(response) ? response : format(transactionReceiptSchema, response, returnFormat);
  });
}
function getTransactionCount2(web3Context, address7, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.getTransactionCount(web3Context.requestManager, address7, blockNumberFormatted);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function sendTransaction3(web3Context, transaction, returnFormat, options = { checkRevertBeforeSending: true }) {
  const promiEvent = new Web3PromiEvent((resolve, reject) => {
    setImmediate(() => {
      (() => __awaiter30(this, undefined, undefined, function* () {
        const sendTxHelper = new SendTxHelper({
          web3Context,
          promiEvent,
          options,
          returnFormat
        });
        let transactionFormatted = formatTransaction(Object.assign(Object.assign({}, transaction), { from: getTransactionFromOrToAttr("from", web3Context, transaction), to: getTransactionFromOrToAttr("to", web3Context, transaction) }), ETH_DATA_FORMAT);
        try {
          transactionFormatted = yield sendTxHelper.populateGasPrice({
            transaction,
            transactionFormatted
          });
          yield sendTxHelper.checkRevertBeforeSending(transactionFormatted);
          sendTxHelper.emitSending(transactionFormatted);
          let wallet2;
          if (web3Context.wallet && !isNullish(transactionFormatted.from)) {
            wallet2 = web3Context.wallet.get(transactionFormatted.from);
          }
          const transactionHash = yield sendTxHelper.signAndSend({
            wallet: wallet2,
            tx: transactionFormatted
          });
          const transactionHashFormatted = format({ format: "bytes32" }, transactionHash, returnFormat);
          sendTxHelper.emitSent(transactionFormatted);
          sendTxHelper.emitTransactionHash(transactionHashFormatted);
          const transactionReceipt = yield waitForTransactionReceipt(web3Context, transactionHash, returnFormat);
          const transactionReceiptFormatted = sendTxHelper.getReceiptWithEvents(format(transactionReceiptSchema, transactionReceipt, returnFormat));
          sendTxHelper.emitReceipt(transactionReceiptFormatted);
          resolve(yield sendTxHelper.handleResolve({
            receipt: transactionReceiptFormatted,
            tx: transactionFormatted
          }));
          sendTxHelper.emitConfirmation({
            receipt: transactionReceiptFormatted,
            transactionHash
          });
        } catch (error) {
          reject(yield sendTxHelper.handleError({
            error,
            tx: transactionFormatted
          }));
        }
      }))();
    });
  });
  return promiEvent;
}
function sendSignedTransaction(web3Context, signedTransaction, returnFormat, options = { checkRevertBeforeSending: true }) {
  const promiEvent = new Web3PromiEvent((resolve, reject) => {
    setImmediate(() => {
      (() => __awaiter30(this, undefined, undefined, function* () {
        const sendTxHelper = new SendTxHelper({
          web3Context,
          promiEvent,
          options,
          returnFormat
        });
        const signedTransactionFormattedHex = format({ format: "bytes" }, signedTransaction, ETH_DATA_FORMAT);
        const unSerializedTransaction = TransactionFactory.fromSerializedData(bytesToUint8Array(hexToBytes(signedTransactionFormattedHex)));
        const unSerializedTransactionWithFrom = Object.assign(Object.assign({}, unSerializedTransaction.toJSON()), {
          from: unSerializedTransaction.getSenderAddress().toString()
        });
        try {
          const { v, r, s } = unSerializedTransactionWithFrom, txWithoutSigParams = __rest(unSerializedTransactionWithFrom, ["v", "r", "s"]);
          yield sendTxHelper.checkRevertBeforeSending(txWithoutSigParams);
          sendTxHelper.emitSending(signedTransactionFormattedHex);
          const transactionHash = yield trySendTransaction(web3Context, () => __awaiter30(this, undefined, undefined, function* () {
            return exports_eth_rpc_methods.sendRawTransaction(web3Context.requestManager, signedTransactionFormattedHex);
          }));
          sendTxHelper.emitSent(signedTransactionFormattedHex);
          const transactionHashFormatted = format({ format: "bytes32" }, transactionHash, returnFormat);
          sendTxHelper.emitTransactionHash(transactionHashFormatted);
          const transactionReceipt = yield waitForTransactionReceipt(web3Context, transactionHash, returnFormat);
          const transactionReceiptFormatted = sendTxHelper.getReceiptWithEvents(format(transactionReceiptSchema, transactionReceipt, returnFormat));
          sendTxHelper.emitReceipt(transactionReceiptFormatted);
          resolve(yield sendTxHelper.handleResolve({
            receipt: transactionReceiptFormatted,
            tx: unSerializedTransactionWithFrom
          }));
          sendTxHelper.emitConfirmation({
            receipt: transactionReceiptFormatted,
            transactionHash
          });
        } catch (error) {
          reject(yield sendTxHelper.handleError({
            error,
            tx: unSerializedTransactionWithFrom
          }));
        }
      }))();
    });
  });
  return promiEvent;
}
function sign4(web3Context, message, addressOrIndex, returnFormat) {
  var _a4;
  return __awaiter30(this, undefined, undefined, function* () {
    const messageFormatted = format({ format: "bytes" }, message, DEFAULT_RETURN_FORMAT);
    if ((_a4 = web3Context.wallet) === null || _a4 === undefined ? undefined : _a4.get(addressOrIndex)) {
      const wallet2 = web3Context.wallet.get(addressOrIndex);
      const signed = wallet2.sign(messageFormatted);
      return format(SignatureObjectSchema, signed, returnFormat);
    }
    if (typeof addressOrIndex === "number") {
      throw new SignatureError(message, 'RPC method "eth_sign" does not support index signatures');
    }
    const response = yield exports_eth_rpc_methods.sign(web3Context.requestManager, addressOrIndex, messageFormatted);
    return format({ format: "bytes" }, response, returnFormat);
  });
}
function signTransaction4(web3Context, transaction, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.signTransaction(web3Context.requestManager, formatTransaction(transaction, ETH_DATA_FORMAT));
    return isString(response) ? decodeSignedTransaction(response, returnFormat, {
      fillInputAndData: true
    }) : {
      raw: format({ format: "bytes" }, response.raw, returnFormat),
      tx: formatTransaction(response.tx, returnFormat, {
        fillInputAndData: true
      })
    };
  });
}
function call2(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.call(web3Context.requestManager, formatTransaction(transaction, ETH_DATA_FORMAT), blockNumberFormatted);
    return format({ format: "bytes" }, response, returnFormat);
  });
}
function estimateGas2(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const transactionFormatted = formatTransaction(transaction, ETH_DATA_FORMAT);
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.estimateGas(web3Context.requestManager, transactionFormatted, blockNumberFormatted);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getLogs2(web3Context, filter3, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    let { toBlock, fromBlock } = filter3;
    if (!isNullish(toBlock)) {
      if (typeof toBlock === "number" || typeof toBlock === "bigint") {
        toBlock = numberToHex2(toBlock);
      }
    }
    if (!isNullish(fromBlock)) {
      if (typeof fromBlock === "number" || typeof fromBlock === "bigint") {
        fromBlock = numberToHex2(fromBlock);
      }
    }
    const formattedFilter = Object.assign(Object.assign({}, filter3), { fromBlock, toBlock });
    const response = yield exports_eth_rpc_methods.getLogs(web3Context.requestManager, formattedFilter);
    const result = response.map((res) => {
      if (typeof res === "string") {
        return res;
      }
      return format(logSchema, res, returnFormat);
    });
    return result;
  });
}
function getChainId2(web3Context, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.getChainId(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getProof2(web3Context, address7, storageKeys, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const storageKeysFormatted = storageKeys.map((storageKey) => format({ format: "bytes" }, storageKey, ETH_DATA_FORMAT));
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.getProof(web3Context.requestManager, address7, storageKeysFormatted, blockNumberFormatted);
    return format(accountSchema, response, returnFormat);
  });
}
function getFeeHistory2(web3Context, blockCount, newestBlock = web3Context.defaultBlock, rewardPercentiles, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const blockCountFormatted = format({ format: "uint" }, blockCount, ETH_DATA_FORMAT);
    const newestBlockFormatted = isBlockTag(newestBlock) ? newestBlock : format({ format: "uint" }, newestBlock, ETH_DATA_FORMAT);
    const rewardPercentilesFormatted = format({
      type: "array",
      items: {
        format: "uint"
      }
    }, rewardPercentiles, NUMBER_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.getFeeHistory(web3Context.requestManager, blockCountFormatted, newestBlockFormatted, rewardPercentilesFormatted);
    return format(feeHistorySchema, response, returnFormat);
  });
}
function createAccessList2(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.createAccessList(web3Context.requestManager, formatTransaction(transaction, ETH_DATA_FORMAT), blockNumberFormatted);
    return format(accessListResultSchema, response, returnFormat);
  });
}
function signTypedData2(web3Context, address7, typedData, useLegacy, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.signTypedData(web3Context.requestManager, address7, typedData, useLegacy);
    return format({ format: "bytes" }, response, returnFormat);
  });
}
var __awaiter30 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var isSyncing = (web3Context) => __awaiter30(undefined, undefined, undefined, function* () {
  return exports_eth_rpc_methods.getSyncing(web3Context.requestManager);
});

// node_modules/web3-eth/lib/esm/web3_subscriptions.js
class LogsSubscription extends Web3Subscription {
  _buildSubscriptionParams() {
    return ["logs", this.args];
  }
  formatSubscriptionResult(data) {
    return format(logSchema, data, super.returnFormat);
  }
}

class NewPendingTransactionsSubscription extends Web3Subscription {
  _buildSubscriptionParams() {
    return ["newPendingTransactions"];
  }
  formatSubscriptionResult(data) {
    return format({ format: "string" }, data, super.returnFormat);
  }
}

class NewHeadsSubscription extends Web3Subscription {
  _buildSubscriptionParams() {
    return ["newHeads"];
  }
  formatSubscriptionResult(data) {
    return format(blockHeaderSchema, data, super.returnFormat);
  }
}

class SyncingSubscription extends Web3Subscription {
  _buildSubscriptionParams() {
    return ["syncing"];
  }
  _processSubscriptionResult(data) {
    if (typeof data === "boolean") {
      this.emit("changed", data);
    } else {
      const mappedData = Object.fromEntries(Object.entries(data.status).map(([key, value]) => [
        key.charAt(0).toLowerCase() + key.substring(1),
        value
      ]));
      this.emit("changed", data.syncing);
      this.emit("data", format(syncSchema, mappedData, super.returnFormat));
    }
  }
}

// node_modules/web3-eth/lib/esm/web3_eth.js
var __awaiter31 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var registeredSubscriptions = {
  logs: LogsSubscription,
  newPendingTransactions: NewPendingTransactionsSubscription,
  newHeads: NewHeadsSubscription,
  syncing: SyncingSubscription,
  pendingTransactions: NewPendingTransactionsSubscription,
  newBlockHeaders: NewHeadsSubscription
};

class Web3Eth extends Web3Context {
  constructor(providerOrContext) {
    if (typeof providerOrContext === "string" || isSupportedProvider(providerOrContext)) {
      super({
        provider: providerOrContext,
        registeredSubscriptions
      });
      return;
    }
    if (providerOrContext.registeredSubscriptions) {
      super(providerOrContext);
      return;
    }
    super(Object.assign(Object.assign({}, providerOrContext), { registeredSubscriptions }));
    this.getFeeData = this.calculateFeeData;
  }
  getProtocolVersion() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.getProtocolVersion(this.requestManager);
    });
  }
  isSyncing() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.getSyncing(this.requestManager);
    });
  }
  getCoinbase() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.getCoinbase(this.requestManager);
    });
  }
  isMining() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.getMining(this.requestManager);
    });
  }
  getHashrate(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return this.getHashRate(returnFormat);
    });
  }
  getHashRate(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getHashRate2(this, returnFormat);
    });
  }
  getGasPrice(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getGasPrice2(this, returnFormat);
    });
  }
  getMaxPriorityFeePerGas(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getMaxPriorityFeePerGas2(this, returnFormat);
    });
  }
  calculateFeeData(baseFeePerGasFactor = BigInt(2), alternativeMaxPriorityFeePerGas = ethUnitMap.Gwei) {
    var _a4;
    return __awaiter31(this, undefined, undefined, function* () {
      const block4 = yield this.getBlock(undefined, false);
      const baseFeePerGas = (_a4 = block4 === null || block4 === undefined ? undefined : block4.baseFeePerGas) !== null && _a4 !== undefined ? _a4 : undefined;
      let gasPrice;
      try {
        gasPrice = yield this.getGasPrice();
      } catch (error) {
      }
      let maxPriorityFeePerGas;
      try {
        maxPriorityFeePerGas = yield this.getMaxPriorityFeePerGas();
      } catch (error) {
      }
      let maxFeePerGas;
      if (baseFeePerGas) {
        maxPriorityFeePerGas = maxPriorityFeePerGas !== null && maxPriorityFeePerGas !== undefined ? maxPriorityFeePerGas : alternativeMaxPriorityFeePerGas;
        maxFeePerGas = baseFeePerGas * baseFeePerGasFactor + maxPriorityFeePerGas;
      }
      return { gasPrice, maxFeePerGas, maxPriorityFeePerGas, baseFeePerGas };
    });
  }
  getAccounts() {
    var _a4;
    return __awaiter31(this, undefined, undefined, function* () {
      const hexAddresses = (_a4 = yield exports_eth_rpc_methods.getAccounts(this.requestManager)) !== null && _a4 !== undefined ? _a4 : [];
      return hexAddresses.map((address7) => toChecksumAddress(address7));
    });
  }
  getBlockNumber(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getBlockNumber2(this, returnFormat);
    });
  }
  getBalance(address7, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getBalance2(this, address7, blockNumber, returnFormat);
    });
  }
  getStorageAt(address7, storageSlot, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getStorageAt2(this, address7, storageSlot, blockNumber, returnFormat);
    });
  }
  getCode(address7, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getCode2(this, address7, blockNumber, returnFormat);
    });
  }
  getBlock(block4 = this.defaultBlock, hydrated = false, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getBlock(this, block4, hydrated, returnFormat);
    });
  }
  getBlockTransactionCount(block4 = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getBlockTransactionCount(this, block4, returnFormat);
    });
  }
  getBlockUncleCount(block4 = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getBlockUncleCount(this, block4, returnFormat);
    });
  }
  getUncle(block4 = this.defaultBlock, uncleIndex, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getUncle(this, block4, uncleIndex, returnFormat);
    });
  }
  getTransaction(transactionHash, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      const response = yield getTransaction(this, transactionHash, returnFormat);
      if (!response)
        throw new TransactionNotFound;
      return response;
    });
  }
  getPendingTransactions(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getPendingTransactions2(this, returnFormat);
    });
  }
  getTransactionFromBlock(block4 = this.defaultBlock, transactionIndex, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getTransactionFromBlock(this, block4, transactionIndex, returnFormat);
    });
  }
  getTransactionReceipt(transactionHash, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      const response = yield getTransactionReceipt2(this, transactionHash, returnFormat);
      if (!response)
        throw new TransactionNotFound;
      return response;
    });
  }
  getTransactionCount(address7, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getTransactionCount2(this, address7, blockNumber, returnFormat);
    });
  }
  sendTransaction(transaction, returnFormat = DEFAULT_RETURN_FORMAT, options) {
    return sendTransaction3(this, transaction, returnFormat, options);
  }
  sendSignedTransaction(transaction, returnFormat = DEFAULT_RETURN_FORMAT, options) {
    return sendSignedTransaction(this, transaction, returnFormat, options);
  }
  sign(message, addressOrIndex, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return sign4(this, message, addressOrIndex, returnFormat);
    });
  }
  signTransaction(transaction, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return signTransaction4(this, transaction, returnFormat);
    });
  }
  call(transaction, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return call2(this, transaction, blockNumber, returnFormat);
    });
  }
  estimateGas(transaction, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return estimateGas2(this, transaction, blockNumber, returnFormat);
    });
  }
  getPastLogs(filter3, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getLogs2(this, filter3, returnFormat);
    });
  }
  getWork() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.getWork(this.requestManager);
    });
  }
  submitWork(nonce, hash3, digest) {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.submitWork(this.requestManager, nonce, hash3, digest);
    });
  }
  requestAccounts() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.requestAccounts(this.requestManager);
    });
  }
  getChainId(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getChainId2(this, returnFormat);
    });
  }
  getNodeInfo() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.getNodeInfo(this.requestManager);
    });
  }
  getProof(address7, storageKeys, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getProof2(this, address7, storageKeys, blockNumber, returnFormat);
    });
  }
  getFeeHistory(blockCount, newestBlock = this.defaultBlock, rewardPercentiles, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getFeeHistory2(this, blockCount, newestBlock, rewardPercentiles, returnFormat);
    });
  }
  createAccessList(transaction, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return createAccessList2(this, transaction, blockNumber, returnFormat);
    });
  }
  signTypedData(address7, typedData, useLegacy = false, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return signTypedData2(this, address7, typedData, useLegacy, returnFormat);
    });
  }
  subscribe(name, args, returnFormat = DEFAULT_RETURN_FORMAT) {
    var _a4;
    return __awaiter31(this, undefined, undefined, function* () {
      const subscription = yield (_a4 = this.subscriptionManager) === null || _a4 === undefined ? undefined : _a4.subscribe(name, args, returnFormat);
      if (subscription instanceof LogsSubscription && name === "logs" && typeof args === "object" && !isNullish2(args.fromBlock) && Number.isFinite(Number(args.fromBlock))) {
        setImmediate(() => {
          this.getPastLogs(args).then((logs) => {
            for (const log of logs) {
              subscription._processSubscriptionResult(log);
            }
          }).catch((e) => {
            subscription._processSubscriptionError(e);
          });
        });
      }
      return subscription;
    });
  }
  static shouldClearSubscription({ sub }) {
    return !(sub instanceof SyncingSubscription);
  }
  clearSubscriptions(notClearSyncing = false) {
    var _a4;
    return (_a4 = this.subscriptionManager) === null || _a4 === undefined ? undefined : _a4.unsubscribe(notClearSyncing ? Web3Eth.shouldClearSubscription : undefined);
  }
}
// node_modules/web3-eth/lib/esm/validation.js
var validateCustomChainInfo = (transaction) => {
  if (!isNullish(transaction.common)) {
    if (isNullish(transaction.common.customChain))
      throw new MissingCustomChainError;
    if (isNullish(transaction.common.customChain.chainId))
      throw new MissingCustomChainIdError;
    if (!isNullish(transaction.chainId) && transaction.chainId !== transaction.common.customChain.chainId)
      throw new ChainIdMismatchError({
        txChainId: transaction.chainId,
        customChainId: transaction.common.customChain.chainId
      });
  }
};
var validateChainInfo = (transaction) => {
  if (!isNullish(transaction.common) && !isNullish(transaction.chain) && !isNullish(transaction.hardfork)) {
    throw new CommonOrChainAndHardforkError;
  }
  if (!isNullish(transaction.chain) && isNullish(transaction.hardfork) || !isNullish(transaction.hardfork) && isNullish(transaction.chain))
    throw new MissingChainOrHardforkError({
      chain: transaction.chain,
      hardfork: transaction.hardfork
    });
};
var validateBaseChain = (transaction) => {
  if (!isNullish(transaction.common)) {
    if (!isNullish(transaction.common.baseChain)) {
      if (!isNullish(transaction.chain) && transaction.chain !== transaction.common.baseChain) {
        throw new ChainMismatchError({
          txChain: transaction.chain,
          baseChain: transaction.common.baseChain
        });
      }
    }
  }
};
var validateHardfork = (transaction) => {
  if (!isNullish(transaction.common)) {
    if (!isNullish(transaction.common.hardfork)) {
      if (!isNullish(transaction.hardfork) && transaction.hardfork !== transaction.common.hardfork) {
        throw new HardforkMismatchError({
          txHardfork: transaction.hardfork,
          commonHardfork: transaction.common.hardfork
        });
      }
    }
  }
};
var validateLegacyGas = (transaction) => {
  if (isNullish(transaction.gas) || !isUInt(transaction.gas) || isNullish(transaction.gasPrice) || !isUInt(transaction.gasPrice))
    throw new InvalidGasOrGasPrice({
      gas: transaction.gas,
      gasPrice: transaction.gasPrice
    });
  if (!isNullish(transaction.maxFeePerGas) || !isNullish(transaction.maxPriorityFeePerGas))
    throw new UnsupportedFeeMarketError({
      maxFeePerGas: transaction.maxFeePerGas,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
    });
};
var validateFeeMarketGas = (transaction) => {
  if (!isNullish(transaction.gasPrice) && transaction.type === "0x2")
    throw new Eip1559GasPriceError(transaction.gasPrice);
  if (transaction.type === "0x0" || transaction.type === "0x1")
    throw new UnsupportedFeeMarketError({
      maxFeePerGas: transaction.maxFeePerGas,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
    });
  if (isNullish(transaction.maxFeePerGas) || !isUInt(transaction.maxFeePerGas) || isNullish(transaction.maxPriorityFeePerGas) || !isUInt(transaction.maxPriorityFeePerGas))
    throw new InvalidMaxPriorityFeePerGasOrMaxFeePerGas({
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
      maxFeePerGas: transaction.maxFeePerGas
    });
};
var validateGas = (transaction) => {
  const gasPresent = !isNullish(transaction.gas) || !isNullish(transaction.gasLimit);
  const legacyGasPresent = gasPresent && !isNullish(transaction.gasPrice);
  const feeMarketGasPresent = gasPresent && !isNullish(transaction.maxPriorityFeePerGas) && !isNullish(transaction.maxFeePerGas);
  if (!legacyGasPresent && !feeMarketGasPresent)
    throw new MissingGasError({
      gas: transaction.gas,
      gasPrice: transaction.gasPrice,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
      maxFeePerGas: transaction.maxFeePerGas
    });
  if (legacyGasPresent && feeMarketGasPresent)
    throw new TransactionGasMismatchError({
      gas: transaction.gas,
      gasPrice: transaction.gasPrice,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
      maxFeePerGas: transaction.maxFeePerGas
    });
  (legacyGasPresent ? validateLegacyGas : validateFeeMarketGas)(transaction);
  (!isNullish(transaction.type) && transaction.type > "0x1" ? validateFeeMarketGas : validateLegacyGas)(transaction);
};
var validateTransactionForSigning = (transaction, overrideMethod) => {
  if (!isNullish(overrideMethod)) {
    overrideMethod(transaction);
    return;
  }
  if (typeof transaction !== "object" || isNullish(transaction))
    throw new InvalidTransactionObjectError(transaction);
  validateCustomChainInfo(transaction);
  validateChainInfo(transaction);
  validateBaseChain(transaction);
  validateHardfork(transaction);
  const formattedTransaction = formatTransaction(transaction, ETH_DATA_FORMAT);
  validateGas(formattedTransaction);
  if (isNullish(formattedTransaction.nonce) || isNullish(formattedTransaction.chainId) || formattedTransaction.nonce.startsWith("-") || formattedTransaction.chainId.startsWith("-"))
    throw new InvalidNonceOrChainIdError({
      nonce: transaction.nonce,
      chainId: transaction.chainId
    });
};
// node_modules/web3-eth/lib/esm/utils/prepare_transaction_for_signing.js
var __awaiter32 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getEthereumjsTxDataFromTransaction = (transaction) => {
  var _a4, _b;
  return {
    nonce: transaction.nonce,
    gasPrice: transaction.gasPrice,
    gasLimit: (_a4 = transaction.gasLimit) !== null && _a4 !== undefined ? _a4 : transaction.gas,
    to: transaction.to,
    value: transaction.value,
    data: (_b = transaction.data) !== null && _b !== undefined ? _b : transaction.input,
    type: transaction.type,
    chainId: transaction.chainId,
    accessList: transaction.accessList,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
    maxFeePerGas: transaction.maxFeePerGas
  };
};
var getEthereumjsTransactionOptions = (transaction, web3Context) => {
  var _a4, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  const hasTransactionSigningOptions = !isNullish(transaction.chain) && !isNullish(transaction.hardfork) || !isNullish(transaction.common);
  let common4;
  if (!hasTransactionSigningOptions) {
    if (web3Context.defaultCommon) {
      common4 = Object.assign({}, web3Context.defaultCommon);
      if (isNullish(common4.hardfork))
        common4.hardfork = (_a4 = transaction.hardfork) !== null && _a4 !== undefined ? _a4 : web3Context.defaultHardfork;
      if (isNullish(common4.baseChain))
        common4.baseChain = web3Context.defaultChain;
    } else {
      common4 = Common.custom({
        name: "custom-network",
        chainId: toNumber(transaction.chainId),
        networkId: !isNullish(transaction.networkId) ? toNumber(transaction.networkId) : undefined,
        defaultHardfork: (_b = transaction.hardfork) !== null && _b !== undefined ? _b : web3Context.defaultHardfork
      }, {
        baseChain: web3Context.defaultChain
      });
    }
  } else {
    const name = (_f = (_e = (_d = (_c = transaction === null || transaction === undefined ? undefined : transaction.common) === null || _c === undefined ? undefined : _c.customChain) === null || _d === undefined ? undefined : _d.name) !== null && _e !== undefined ? _e : transaction.chain) !== null && _f !== undefined ? _f : "custom-network";
    const chainId = toNumber((_j = (_h = (_g = transaction === null || transaction === undefined ? undefined : transaction.common) === null || _g === undefined ? undefined : _g.customChain) === null || _h === undefined ? undefined : _h.chainId) !== null && _j !== undefined ? _j : transaction === null || transaction === undefined ? undefined : transaction.chainId);
    const networkId = toNumber((_m = (_l = (_k = transaction === null || transaction === undefined ? undefined : transaction.common) === null || _k === undefined ? undefined : _k.customChain) === null || _l === undefined ? undefined : _l.networkId) !== null && _m !== undefined ? _m : transaction === null || transaction === undefined ? undefined : transaction.networkId);
    const defaultHardfork = (_q = (_p = (_o = transaction === null || transaction === undefined ? undefined : transaction.common) === null || _o === undefined ? undefined : _o.hardfork) !== null && _p !== undefined ? _p : transaction === null || transaction === undefined ? undefined : transaction.hardfork) !== null && _q !== undefined ? _q : web3Context.defaultHardfork;
    const baseChain = (_t = (_s = (_r = transaction.common) === null || _r === undefined ? undefined : _r.baseChain) !== null && _s !== undefined ? _s : transaction.chain) !== null && _t !== undefined ? _t : web3Context.defaultChain;
    if (chainId && networkId && name) {
      common4 = Common.custom({
        name,
        chainId,
        networkId,
        defaultHardfork
      }, {
        baseChain
      });
    }
  }
  return { common: common4 };
};
var prepareTransactionForSigning = (transaction, web3Context, privateKey, fillGasPrice = false, fillGasLimit = true) => __awaiter32(undefined, undefined, undefined, function* () {
  const populatedTransaction = yield transactionBuilder({
    transaction,
    web3Context,
    privateKey,
    fillGasPrice,
    fillGasLimit
  });
  const formattedTransaction = formatTransaction(populatedTransaction, ETH_DATA_FORMAT);
  validateTransactionForSigning(formattedTransaction);
  return TransactionFactory.fromTxData(getEthereumjsTxDataFromTransaction(formattedTransaction), getEthereumjsTransactionOptions(formattedTransaction, web3Context));
});
// node_modules/web3-eth-contract/lib/esm/encoding.js
var encodeEventABI = ({ address: address7 }, event, options) => {
  var _a4, _b;
  const topics = options === null || options === undefined ? undefined : options.topics;
  const filter3 = (_a4 = options === null || options === undefined ? undefined : options.filter) !== null && _a4 !== undefined ? _a4 : {};
  const opts = {};
  if (!isNullish2(options === null || options === undefined ? undefined : options.fromBlock)) {
    opts.fromBlock = format(blockSchema.properties.number, options === null || options === undefined ? undefined : options.fromBlock, {
      number: FMT_NUMBER.HEX,
      bytes: FMT_BYTES.HEX
    });
  }
  if (!isNullish2(options === null || options === undefined ? undefined : options.toBlock)) {
    opts.toBlock = format(blockSchema.properties.number, options === null || options === undefined ? undefined : options.toBlock, {
      number: FMT_NUMBER.HEX,
      bytes: FMT_BYTES.HEX
    });
  }
  if (topics && Array.isArray(topics)) {
    opts.topics = [...topics];
  } else {
    opts.topics = [];
    if (event && !event.anonymous && ![ALL_EVENTS, "allEvents"].includes(event.name)) {
      opts.topics.push((_b = event.signature) !== null && _b !== undefined ? _b : encodeEventSignature(jsonInterfaceMethodToString(event)));
    }
    if (![ALL_EVENTS, "allEvents"].includes(event.name) && event.inputs) {
      for (const input of event.inputs) {
        if (!input.indexed) {
          continue;
        }
        const value = filter3[input.name];
        if (!value) {
          opts.topics.push(null);
          continue;
        }
        if (Array.isArray(value)) {
          opts.topics.push(value.map((v) => encodeParameter(input.type, v)));
        } else if (input.type === "string") {
          opts.topics.push(keccak256Wrapper(value));
        } else {
          opts.topics.push(encodeParameter(input.type, value));
        }
      }
    }
  }
  if (!opts.topics.length)
    delete opts.topics;
  if (address7) {
    opts.address = address7.toLowerCase();
  }
  return opts;
};
var encodeMethodABI = (abi2, args, deployData) => {
  const inputLength = Array.isArray(abi2.inputs) ? abi2.inputs.length : 0;
  if (abi2.inputs && inputLength !== args.length) {
    throw new Web3ContractError(`The number of arguments is not matching the methods required number. You need to pass ${inputLength} arguments.`);
  }
  let params;
  if (abi2.inputs) {
    params = encodeParameters(Array.isArray(abi2.inputs) ? abi2.inputs : [], args).replace("0x", "");
  } else {
    params = inferTypesAndEncodeParameters(args).replace("0x", "");
  }
  if (isAbiConstructorFragment(abi2)) {
    if (!deployData)
      throw new Web3ContractError("The contract has no contract data option set. This is necessary to append the constructor parameters.");
    if (!deployData.startsWith("0x")) {
      return `0x${deployData}${params}`;
    }
    return `${deployData}${params}`;
  }
  return `${encodeFunctionSignature(abi2)}${params}`;
};
var decodeMethodReturn = (abi2, returnValues) => {
  if (abi2.type === "constructor") {
    return returnValues;
  }
  if (!returnValues) {
    return null;
  }
  const value = returnValues.length >= 2 ? returnValues.slice(2) : returnValues;
  if (!abi2.outputs) {
    return null;
  }
  const result = decodeParameters2([...abi2.outputs], value);
  if (result.__length__ === 1) {
    return result[0];
  }
  return result;
};

// node_modules/web3-eth-contract/lib/esm/log_subscription.js
class LogsSubscription2 extends Web3Subscription {
  constructor(args, options) {
    super(args, options);
    this.address = args.address;
    this.topics = args.topics;
    this.abi = args.abi;
    this.jsonInterface = args.jsonInterface;
  }
  _buildSubscriptionParams() {
    return ["logs", { address: this.address, topics: this.topics }];
  }
  formatSubscriptionResult(data) {
    return decodeEventABI(this.abi, data, this.jsonInterface, super.returnFormat);
  }
}

// node_modules/web3-eth-contract/lib/esm/utils.js
var dataInputEncodeMethodHelper = (txParams, abi2, params, dataInputFill) => {
  var _a4, _b;
  const tx2 = {};
  if (!isNullish2(txParams.data) || dataInputFill === "both") {
    tx2.data = encodeMethodABI(abi2, params, (_a4 = txParams.data) !== null && _a4 !== undefined ? _a4 : txParams.input);
  }
  if (!isNullish2(txParams.input) || dataInputFill === "both") {
    tx2.input = encodeMethodABI(abi2, params, (_b = txParams.input) !== null && _b !== undefined ? _b : txParams.data);
  }
  if (isNullish2(tx2.input) && isNullish2(tx2.data)) {
    tx2[dataInputFill] = encodeMethodABI(abi2, params);
  }
  return { data: tx2.data, input: tx2.input };
};
var getSendTxParams = ({ abi: abi2, params, options, contractOptions }) => {
  var _a4, _b, _c;
  const deploymentCall = (_c = (_b = (_a4 = options === null || options === undefined ? undefined : options.input) !== null && _a4 !== undefined ? _a4 : options === null || options === undefined ? undefined : options.data) !== null && _b !== undefined ? _b : contractOptions.input) !== null && _c !== undefined ? _c : contractOptions.data;
  if (!deploymentCall && !(options === null || options === undefined ? undefined : options.to) && !contractOptions.address) {
    throw new Web3ContractError("Contract address not specified");
  }
  if (!(options === null || options === undefined ? undefined : options.from) && !contractOptions.from) {
    throw new Web3ContractError('Contract "from" address not specified');
  }
  let txParams = mergeDeep({
    to: contractOptions.address,
    gas: contractOptions.gas,
    gasPrice: contractOptions.gasPrice,
    from: contractOptions.from,
    input: contractOptions.input,
    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,
    maxFeePerGas: contractOptions.maxFeePerGas,
    data: contractOptions.data
  }, options);
  const dataInput = dataInputEncodeMethodHelper(txParams, abi2, params, options === null || options === undefined ? undefined : options.dataInputFill);
  txParams = Object.assign(Object.assign({}, txParams), { data: dataInput.data, input: dataInput.input });
  return txParams;
};
var getEthTxCallParams = ({ abi: abi2, params, options, contractOptions }) => {
  if (!(options === null || options === undefined ? undefined : options.to) && !contractOptions.address) {
    throw new Web3ContractError("Contract address not specified");
  }
  let txParams = mergeDeep({
    to: contractOptions.address,
    gas: contractOptions.gas,
    gasPrice: contractOptions.gasPrice,
    from: contractOptions.from,
    input: contractOptions.input,
    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,
    maxFeePerGas: contractOptions.maxFeePerGas,
    data: contractOptions.data
  }, options);
  const dataInput = dataInputEncodeMethodHelper(txParams, abi2, params, options === null || options === undefined ? undefined : options.dataInputFill);
  txParams = Object.assign(Object.assign({}, txParams), { data: dataInput.data, input: dataInput.input });
  return txParams;
};
var getEstimateGasParams = ({ abi: abi2, params, options, contractOptions }) => {
  let txParams = mergeDeep({
    to: contractOptions.address,
    gas: contractOptions.gas,
    gasPrice: contractOptions.gasPrice,
    from: contractOptions.from,
    input: contractOptions.input,
    data: contractOptions.data
  }, options);
  const dataInput = dataInputEncodeMethodHelper(txParams, abi2, params, options === null || options === undefined ? undefined : options.dataInputFill);
  txParams = Object.assign(Object.assign({}, txParams), { data: dataInput.data, input: dataInput.input });
  return txParams;
};
var isWeb3ContractContext = (options) => typeof options === "object" && !isNullish2(options) && Object.keys(options).length !== 0 && !isContractInitOptions(options);
var getCreateAccessListParams = ({ abi: abi2, params, options, contractOptions }) => {
  if (!(options === null || options === undefined ? undefined : options.to) && !contractOptions.address) {
    throw new Web3ContractError("Contract address not specified");
  }
  if (!(options === null || options === undefined ? undefined : options.from) && !contractOptions.from) {
    throw new Web3ContractError('Contract "from" address not specified');
  }
  let txParams = mergeDeep({
    to: contractOptions.address,
    gas: contractOptions.gas,
    gasPrice: contractOptions.gasPrice,
    from: contractOptions.from,
    input: contractOptions.input,
    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,
    maxFeePerGas: contractOptions.maxFeePerGas,
    data: contractOptions.data
  }, options);
  const dataInput = dataInputEncodeMethodHelper(txParams, abi2, params, options === null || options === undefined ? undefined : options.dataInputFill);
  txParams = Object.assign(Object.assign({}, txParams), { data: dataInput.data, input: dataInput.input });
  return txParams;
};

// node_modules/web3-eth-contract/lib/esm/contract.js
var __awaiter33 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var contractSubscriptions = {
  logs: LogsSubscription2,
  newHeads: NewHeadsSubscription,
  newBlockHeaders: NewHeadsSubscription
};

class Contract extends Web3Context {
  constructor(jsonInterface, addressOrOptionsOrContext, optionsOrContextOrReturnFormat, contextOrReturnFormat, returnFormat) {
    var _a4, _b, _c;
    const options = isContractInitOptions(addressOrOptionsOrContext) ? addressOrOptionsOrContext : isContractInitOptions(optionsOrContextOrReturnFormat) ? optionsOrContextOrReturnFormat : undefined;
    let contractContext;
    if (isWeb3ContractContext(addressOrOptionsOrContext)) {
      contractContext = addressOrOptionsOrContext;
    } else if (isWeb3ContractContext(optionsOrContextOrReturnFormat)) {
      contractContext = optionsOrContextOrReturnFormat;
    } else {
      contractContext = contextOrReturnFormat;
    }
    let provider;
    if (typeof addressOrOptionsOrContext === "object" && "provider" in addressOrOptionsOrContext) {
      provider = addressOrOptionsOrContext.provider;
    } else if (typeof optionsOrContextOrReturnFormat === "object" && "provider" in optionsOrContextOrReturnFormat) {
      provider = optionsOrContextOrReturnFormat.provider;
    } else if (typeof contextOrReturnFormat === "object" && "provider" in contextOrReturnFormat) {
      provider = contextOrReturnFormat.provider;
    } else {
      provider = Contract.givenProvider;
    }
    super(Object.assign(Object.assign({}, contractContext), { provider, registeredSubscriptions: contractSubscriptions }));
    this.syncWithContext = false;
    this._functions = {};
    if (contractContext === null || contractContext === undefined ? undefined : contractContext.wallet) {
      this._wallet = contractContext.wallet;
    }
    if (contractContext === null || contractContext === undefined ? undefined : contractContext.accountProvider) {
      this._accountProvider = contractContext.accountProvider;
    }
    if (!isNullish(options) && !isNullish(options.data) && !isNullish(options.input) && this.config.contractDataInputFill !== "both")
      throw new ContractTransactionDataAndInputError({
        data: options.data,
        input: options.input
      });
    this._overloadedMethodAbis = new Map;
    const returnDataFormat = isDataFormat(contextOrReturnFormat) ? contextOrReturnFormat : isDataFormat(optionsOrContextOrReturnFormat) ? optionsOrContextOrReturnFormat : returnFormat !== null && returnFormat !== undefined ? returnFormat : DEFAULT_RETURN_FORMAT;
    const address7 = typeof addressOrOptionsOrContext === "string" ? addressOrOptionsOrContext : undefined;
    this.config.contractDataInputFill = (_a4 = options === null || options === undefined ? undefined : options.dataInputFill) !== null && _a4 !== undefined ? _a4 : this.config.contractDataInputFill;
    this._parseAndSetJsonInterface(jsonInterface, returnDataFormat);
    if (!isNullish(address7)) {
      this._parseAndSetAddress(address7, returnDataFormat);
    }
    this.options = {
      address: address7,
      jsonInterface: this._jsonInterface,
      gas: (_b = options === null || options === undefined ? undefined : options.gas) !== null && _b !== undefined ? _b : options === null || options === undefined ? undefined : options.gasLimit,
      gasPrice: options === null || options === undefined ? undefined : options.gasPrice,
      from: options === null || options === undefined ? undefined : options.from,
      input: options === null || options === undefined ? undefined : options.input,
      data: options === null || options === undefined ? undefined : options.data
    };
    this.syncWithContext = (_c = options === null || options === undefined ? undefined : options.syncWithContext) !== null && _c !== undefined ? _c : false;
    if (contractContext instanceof Web3Context) {
      this.subscribeToContextEvents(contractContext);
    }
    Object.defineProperty(this.options, "address", {
      set: (value) => this._parseAndSetAddress(value, returnDataFormat),
      get: () => this._address
    });
    Object.defineProperty(this.options, "jsonInterface", {
      set: (value) => this._parseAndSetJsonInterface(value, returnDataFormat),
      get: () => this._jsonInterface
    });
    if (contractContext instanceof Web3Context) {
      contractContext.on(Web3ConfigEvent.CONFIG_CHANGE, (event) => {
        this.setConfig({ [event.name]: event.newValue });
      });
    }
  }
  get events() {
    return this._events;
  }
  get methods() {
    return this._methods;
  }
  clone() {
    let newContract;
    if (this.options.address) {
      newContract = new Contract([...this._jsonInterface, ...this._errorsInterface], this.options.address, {
        gas: this.options.gas,
        gasPrice: this.options.gasPrice,
        from: this.options.from,
        input: this.options.input,
        data: this.options.data,
        provider: this.currentProvider,
        syncWithContext: this.syncWithContext,
        dataInputFill: this.config.contractDataInputFill
      }, this.getContextObject());
    } else {
      newContract = new Contract([...this._jsonInterface, ...this._errorsInterface], {
        gas: this.options.gas,
        gasPrice: this.options.gasPrice,
        from: this.options.from,
        input: this.options.input,
        data: this.options.data,
        provider: this.currentProvider,
        syncWithContext: this.syncWithContext,
        dataInputFill: this.config.contractDataInputFill
      }, this.getContextObject());
    }
    if (this.context)
      newContract.subscribeToContextEvents(this.context);
    return newContract;
  }
  deploy(deployOptions) {
    var _a4, _b, _c;
    let abi2 = this._jsonInterface.find((j) => j.type === "constructor");
    if (!abi2) {
      abi2 = {
        type: "constructor",
        stateMutability: ""
      };
    }
    const _input = format({ format: "bytes" }, (_a4 = deployOptions === null || deployOptions === undefined ? undefined : deployOptions.input) !== null && _a4 !== undefined ? _a4 : this.options.input, DEFAULT_RETURN_FORMAT);
    const _data = format({ format: "bytes" }, (_b = deployOptions === null || deployOptions === undefined ? undefined : deployOptions.data) !== null && _b !== undefined ? _b : this.options.data, DEFAULT_RETURN_FORMAT);
    if ((!_input || _input.trim() === "0x") && (!_data || _data.trim() === "0x")) {
      throw new Web3ContractError("contract creation without any data provided.");
    }
    const args = (_c = deployOptions === null || deployOptions === undefined ? undefined : deployOptions.arguments) !== null && _c !== undefined ? _c : [];
    const contractOptions = Object.assign(Object.assign({}, this.options), { input: _input, data: _data });
    const deployData = _input !== null && _input !== undefined ? _input : _data;
    return {
      arguments: args,
      send: (options) => {
        const modifiedOptions = Object.assign({}, options);
        return this._contractMethodDeploySend(abi2, args, modifiedOptions, contractOptions);
      },
      estimateGas: (options, returnFormat = DEFAULT_RETURN_FORMAT) => __awaiter33(this, undefined, undefined, function* () {
        const modifiedOptions = Object.assign({}, options);
        return this._contractMethodEstimateGas({
          abi: abi2,
          params: args,
          returnFormat,
          options: modifiedOptions,
          contractOptions
        });
      }),
      encodeABI: () => encodeMethodABI(abi2, args, format({ format: "bytes" }, deployData, DEFAULT_RETURN_FORMAT))
    };
  }
  getPastEvents(param1, param2, param3) {
    var _a4;
    return __awaiter33(this, undefined, undefined, function* () {
      const eventName = typeof param1 === "string" ? param1 : ALL_EVENTS;
      const options = typeof param1 !== "string" && !isDataFormat(param1) ? param1 : !isDataFormat(param2) ? param2 : {};
      const returnFormat = isDataFormat(param1) ? param1 : isDataFormat(param2) ? param2 : param3 !== null && param3 !== undefined ? param3 : DEFAULT_RETURN_FORMAT;
      const abi2 = eventName === "allEvents" || eventName === ALL_EVENTS ? ALL_EVENTS_ABI : this._jsonInterface.find((j) => ("name" in j) && j.name === eventName);
      if (!abi2) {
        throw new Web3ContractError(`Event ${eventName} not found.`);
      }
      const { fromBlock, toBlock, topics, address: address7 } = encodeEventABI(this.options, abi2, options !== null && options !== undefined ? options : {});
      const logs = yield getLogs2(this, { fromBlock, toBlock, topics, address: address7 }, returnFormat);
      const decodedLogs = logs ? logs.map((log) => typeof log === "string" ? log : decodeEventABI(abi2, log, this._jsonInterface, returnFormat)) : [];
      const filter3 = (_a4 = options === null || options === undefined ? undefined : options.filter) !== null && _a4 !== undefined ? _a4 : {};
      const filterKeys = Object.keys(filter3);
      if (filterKeys.length > 0) {
        return decodedLogs.filter((log) => {
          if (typeof log === "string")
            return true;
          return filterKeys.every((key) => {
            var _a5;
            if (Array.isArray(filter3[key])) {
              return filter3[key].some((v) => String(log.returnValues[key]).toUpperCase() === String(v).toUpperCase());
            }
            const inputAbi = (_a5 = abi2.inputs) === null || _a5 === undefined ? undefined : _a5.filter((input) => input.name === key)[0];
            if ((inputAbi === null || inputAbi === undefined ? undefined : inputAbi.indexed) && inputAbi.type === "string") {
              const hashedIndexedString = keccak256Wrapper(filter3[key]);
              if (hashedIndexedString === String(log.returnValues[key]))
                return true;
            }
            return String(log.returnValues[key]).toUpperCase() === String(filter3[key]).toUpperCase();
          });
        });
      }
      return decodedLogs;
    });
  }
  _parseAndSetAddress(value, returnFormat = DEFAULT_RETURN_FORMAT) {
    this._address = value ? toChecksumAddress(format({ format: "address" }, value, returnFormat)) : value;
  }
  _parseAndSetJsonInterface(abis, returnFormat = DEFAULT_RETURN_FORMAT) {
    var _a4, _b, _c, _d, _e;
    this._functions = {};
    this._methods = {};
    this._events = {};
    let result = [];
    const functionsAbi = abis.filter((abi2) => abi2.type !== "error");
    const errorsAbi = abis.filter((abi2) => isAbiErrorFragment(abi2));
    for (const a of functionsAbi) {
      const abi2 = Object.assign(Object.assign({}, a), { signature: "" });
      if (isAbiFunctionFragment(abi2)) {
        const methodName = jsonInterfaceMethodToString(abi2);
        const methodSignature = encodeFunctionSignature(methodName);
        abi2.signature = methodSignature;
        abi2.constant = (_b = (_a4 = abi2.stateMutability === "view") !== null && _a4 !== undefined ? _a4 : abi2.stateMutability === "pure") !== null && _b !== undefined ? _b : abi2.constant;
        abi2.payable = (_c = abi2.stateMutability === "payable") !== null && _c !== undefined ? _c : abi2.payable;
        this._overloadedMethodAbis.set(abi2.name, [
          ...(_d = this._overloadedMethodAbis.get(abi2.name)) !== null && _d !== undefined ? _d : [],
          abi2
        ]);
        const abiFragment = (_e = this._overloadedMethodAbis.get(abi2.name)) !== null && _e !== undefined ? _e : [];
        const contractMethod = this._createContractMethod(abiFragment, errorsAbi);
        this._functions[methodName] = {
          signature: methodSignature,
          method: contractMethod
        };
        this._methods[abi2.name] = this._functions[methodName].method;
        this._methods[methodName] = this._functions[methodName].method;
        this._methods[methodSignature] = this._functions[methodName].method;
      } else if (isAbiEventFragment(abi2)) {
        const eventName = jsonInterfaceMethodToString(abi2);
        const eventSignature = encodeEventSignature(eventName);
        const event = this._createContractEvent(abi2, returnFormat);
        abi2.signature = eventSignature;
        if (!(eventName in this._events) || abi2.name === "bound") {
          this._events[eventName] = event;
        }
        this._events[abi2.name] = event;
        this._events[eventSignature] = event;
      }
      result = [...result, abi2];
    }
    this._events.allEvents = this._createContractEvent(ALL_EVENTS_ABI, returnFormat);
    this._jsonInterface = [...result];
    this._errorsInterface = errorsAbi;
  }
  _getAbiParams(abi2, params) {
    var _a4;
    try {
      return exports_utils.transformJsonDataToAbiFormat((_a4 = abi2.inputs) !== null && _a4 !== undefined ? _a4 : [], params);
    } catch (error) {
      throw new Web3ContractError(`Invalid parameters for method ${abi2.name}: ${error.message}`);
    }
  }
  _createContractMethod(abiArr, errorsAbis) {
    const abi2 = abiArr[abiArr.length - 1];
    return (...params) => {
      var _a4, _b;
      let abiParams;
      const abis = (_a4 = this._overloadedMethodAbis.get(abi2.name)) !== null && _a4 !== undefined ? _a4 : [];
      let methodAbi = abis[0];
      const internalErrorsAbis = errorsAbis;
      const arrayOfAbis = abis.filter((_abi) => {
        var _a5;
        return ((_a5 = _abi.inputs) !== null && _a5 !== undefined ? _a5 : []).length === params.length;
      });
      if (abis.length === 1 || arrayOfAbis.length === 0) {
        abiParams = this._getAbiParams(methodAbi, params);
        validator2.validate((_b = abi2.inputs) !== null && _b !== undefined ? _b : [], abiParams);
      } else {
        const errors5 = [];
        for (const _abi of arrayOfAbis) {
          try {
            abiParams = this._getAbiParams(_abi, params);
            validator2.validate(_abi.inputs, abiParams);
            methodAbi = _abi;
            break;
          } catch (e) {
            errors5.push(e);
          }
        }
        if (errors5.length === arrayOfAbis.length) {
          throw new Web3ValidatorError(errors5);
        }
      }
      const methods = {
        arguments: abiParams,
        call: (options, block4) => __awaiter33(this, undefined, undefined, function* () {
          return this._contractMethodCall(methodAbi, abiParams, internalErrorsAbis, options, block4);
        }),
        send: (options) => this._contractMethodSend(methodAbi, abiParams, internalErrorsAbis, options),
        estimateGas: (options, returnFormat = DEFAULT_RETURN_FORMAT) => __awaiter33(this, undefined, undefined, function* () {
          return this._contractMethodEstimateGas({
            abi: methodAbi,
            params: abiParams,
            returnFormat,
            options
          });
        }),
        encodeABI: () => encodeMethodABI(methodAbi, abiParams),
        createAccessList: (options, block4) => __awaiter33(this, undefined, undefined, function* () {
          return this._contractMethodCreateAccessList(methodAbi, abiParams, internalErrorsAbis, options, block4);
        })
      };
      if (methodAbi.stateMutability === "payable") {
        return methods;
      }
      return methods;
    };
  }
  _contractMethodCall(abi2, params, errorsAbi, options, block4) {
    var _a4;
    return __awaiter33(this, undefined, undefined, function* () {
      const tx2 = getEthTxCallParams({
        abi: abi2,
        params,
        options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
        contractOptions: Object.assign(Object.assign({}, this.options), { from: (_a4 = this.options.from) !== null && _a4 !== undefined ? _a4 : this.config.defaultAccount })
      });
      try {
        const result = yield call2(this, tx2, block4, DEFAULT_RETURN_FORMAT);
        return decodeMethodReturn(abi2, result);
      } catch (error) {
        if (error instanceof ContractExecutionError) {
          decodeContractErrorData(errorsAbi, error.cause);
        }
        throw error;
      }
    });
  }
  _contractMethodCreateAccessList(abi2, params, errorsAbi, options, block4) {
    var _a4;
    return __awaiter33(this, undefined, undefined, function* () {
      const tx2 = getCreateAccessListParams({
        abi: abi2,
        params,
        options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
        contractOptions: Object.assign(Object.assign({}, this.options), { from: (_a4 = this.options.from) !== null && _a4 !== undefined ? _a4 : this.config.defaultAccount })
      });
      try {
        return createAccessList2(this, tx2, block4, DEFAULT_RETURN_FORMAT);
      } catch (error) {
        if (error instanceof ContractExecutionError) {
          decodeContractErrorData(errorsAbi, error.cause);
        }
        throw error;
      }
    });
  }
  _contractMethodSend(abi2, params, errorsAbi, options, contractOptions) {
    var _a4, _b;
    let modifiedContractOptions = contractOptions !== null && contractOptions !== undefined ? contractOptions : this.options;
    modifiedContractOptions = Object.assign(Object.assign({}, modifiedContractOptions), { input: undefined, from: (_b = (_a4 = modifiedContractOptions.from) !== null && _a4 !== undefined ? _a4 : this.defaultAccount) !== null && _b !== undefined ? _b : undefined });
    const tx2 = getSendTxParams({
      abi: abi2,
      params,
      options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
      contractOptions: modifiedContractOptions
    });
    const transactionToSend = sendTransaction3(this, tx2, DEFAULT_RETURN_FORMAT, {
      checkRevertBeforeSending: false,
      contractAbi: this._jsonInterface
    });
    transactionToSend.on("error", (error) => {
      if (error instanceof ContractExecutionError) {
        decodeContractErrorData(errorsAbi, error.cause);
      }
    });
    return transactionToSend;
  }
  _contractMethodDeploySend(abi2, params, options, contractOptions) {
    var _a4, _b;
    let modifiedContractOptions = contractOptions !== null && contractOptions !== undefined ? contractOptions : this.options;
    modifiedContractOptions = Object.assign(Object.assign({}, modifiedContractOptions), { from: (_b = (_a4 = modifiedContractOptions.from) !== null && _a4 !== undefined ? _a4 : this.defaultAccount) !== null && _b !== undefined ? _b : undefined });
    const tx2 = getSendTxParams({
      abi: abi2,
      params,
      options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
      contractOptions: modifiedContractOptions
    });
    return sendTransaction3(this, tx2, DEFAULT_RETURN_FORMAT, {
      transactionResolver: (receipt) => {
        if (receipt.status === BigInt(0)) {
          throw new Web3ContractError("code couldn't be stored", receipt);
        }
        const newContract = this.clone();
        newContract.options.address = receipt.contractAddress;
        return newContract;
      },
      contractAbi: this._jsonInterface,
      checkRevertBeforeSending: false
    });
  }
  _contractMethodEstimateGas({ abi: abi2, params, returnFormat, options, contractOptions }) {
    return __awaiter33(this, undefined, undefined, function* () {
      const tx2 = getEstimateGasParams({
        abi: abi2,
        params,
        options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
        contractOptions: contractOptions !== null && contractOptions !== undefined ? contractOptions : this.options
      });
      return estimateGas2(this, tx2, BlockTags.LATEST, returnFormat);
    });
  }
  _createContractEvent(abi2, returnFormat = DEFAULT_RETURN_FORMAT) {
    return (...params) => {
      var _a4;
      const { topics, fromBlock } = encodeEventABI(this.options, abi2, params[0]);
      const sub = new LogsSubscription2({
        address: this.options.address,
        topics,
        abi: abi2,
        jsonInterface: this._jsonInterface
      }, {
        subscriptionManager: this.subscriptionManager,
        returnFormat
      });
      if (!isNullish(fromBlock)) {
        this.getPastEvents(abi2.name, { fromBlock, topics }, returnFormat).then((logs) => {
          if (logs) {
            logs.forEach((log) => sub.emit("data", log));
          }
        }).catch((error) => {
          sub.emit("error", new SubscriptionError("Failed to get past events.", error));
        });
      }
      (_a4 = this.subscriptionManager) === null || _a4 === undefined || _a4.addSubscription(sub).catch((error) => {
        sub.emit("error", new SubscriptionError("Failed to subscribe.", error));
      });
      return sub;
    };
  }
  subscribeToContextEvents(context) {
    const contractThis = this;
    this.context = context;
    if (contractThis.syncWithContext) {
      context.on(Web3ConfigEvent.CONFIG_CHANGE, (event) => {
        contractThis.setConfig({ [event.name]: event.newValue });
      });
    }
  }
}

// node_modules/web3-eth-contract/lib/esm/index.js
var esm_default = Contract;

// node_modules/web3-eth-ens/lib/esm/config.js
var interfaceIds = {
  addr: "0x3b3b57de",
  name: "0x691f3431",
  abi: "0x2203ab56",
  pubkey: "0xc8690233",
  text: "0x59d1d43c",
  contenthash: "0xbc1c58d1"
};
var methodsInInterface = {
  setAddr: "addr",
  addr: "addr",
  setPubkey: "pubkey",
  pubkey: "pubkey",
  setContenthash: "contenthash",
  contenthash: "contenthash"
};
var registryAddresses = {
  main: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  goerli: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
};
var networkIds = {
  "0x1": "main",
  "0x5": "goerli"
};

// node_modules/web3-eth-ens/lib/esm/abi/ens/ENSRegistry.js
var ENSRegistryAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "label",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "NewOwner",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "resolver",
        type: "address"
      }
    ],
    name: "NewResolver",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "recordExists",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "resolver",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "ttl",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/web3-eth-ens/lib/esm/abi/ens/PublicResolver.js
var PublicResolverAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "a",
        type: "address"
      }
    ],
    name: "AddrChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "coinType",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "newAddress",
        type: "bytes"
      }
    ],
    name: "AddressChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "hash",
        type: "bytes"
      }
    ],
    name: "ContenthashChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "name",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "resource",
        type: "uint16"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "record",
        type: "bytes"
      }
    ],
    name: "DNSRecordChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "name",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "resource",
        type: "uint16"
      }
    ],
    name: "DNSRecordDeleted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "DNSZoneCleared",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "lastzonehash",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "zonehash",
        type: "bytes"
      }
    ],
    name: "DNSZonehashChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes4",
        name: "interfaceID",
        type: "bytes4"
      },
      {
        indexed: false,
        internalType: "address",
        name: "implementer",
        type: "address"
      }
    ],
    name: "InterfaceChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "string",
        name: "name",
        type: "string"
      }
    ],
    name: "NameChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "x",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "y",
        type: "bytes32"
      }
    ],
    name: "PubkeyChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "string",
        name: "indexedKey",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "key",
        type: "string"
      }
    ],
    name: "TextChanged",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "contentTypes",
        type: "uint256"
      }
    ],
    name: "ABI",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "addr",
    outputs: [
      {
        internalType: "address payable",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "coinType",
        type: "uint256"
      }
    ],
    name: "addr",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "contenthash",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "name",
        type: "bytes32"
      },
      {
        internalType: "uint16",
        name: "resource",
        type: "uint16"
      }
    ],
    name: "dnsRecord",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "name",
        type: "bytes32"
      }
    ],
    name: "hasDNSRecords",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes4",
        name: "interfaceID",
        type: "bytes4"
      }
    ],
    name: "interfaceImplementer",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "pubkey",
    outputs: [
      {
        internalType: "bytes32",
        name: "x",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "y",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceID",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "key",
        type: "string"
      }
    ],
    name: "text",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "zonehash",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "a",
        type: "address"
      }
    ],
    name: "setAddr",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@adraffy/ens-normalize/dist/index.mjs
var decode_arithmetic = function(bytes7) {
  let pos = 0;
  function u16() {
    return bytes7[pos++] << 8 | bytes7[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1;i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes7[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N = 31;
  const FULL = 2 ** N;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0;i < N; i++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b = b << 1 & MASK | 1;
    }
    while (a & ~b & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b = (b ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes7[pos_payload++] << 16 | bytes7[pos_payload++] << 8 | bytes7[pos_payload++]);
      case 2:
        return offset + 256 + (bytes7[pos_payload++] << 8 | bytes7[pos_payload++]);
      case 1:
        return offset + bytes7[pos_payload++];
      default:
        return x - 1;
    }
  });
};
var read_payload = function(v) {
  let pos = 0;
  return () => v[pos++];
};
var read_compressed_payload = function(s) {
  return read_payload(decode_arithmetic(unsafe_atob(s)));
};
var unsafe_atob = function(s) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
  let n = s.length;
  let ret = new Uint8Array(6 * n >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0;i < n; i++) {
    carry = carry << 6 | lookup[s.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
};
var signed = function(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
};
var read_deltas = function(n, next) {
  let v = Array(n);
  for (let i = 0, x = 0;i < n; i++)
    v[i] = x += signed(next());
  return v;
};
var read_sorted = function(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n = next();
    if (!n)
      break;
    prev += x;
    for (let i = 0;i < n; i++) {
      ret.push(prev + i);
    }
    prev += n + 1;
  }
  return ret;
};
var read_sorted_arrays = function(next) {
  return read_array_while(() => {
    let v = read_sorted(next);
    if (v.length)
      return v;
  });
};
var read_mapped = function(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0)
      break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0)
      break;
    ret.push(read_replacement_table(w, next));
  }
  return ret.flat();
};
var read_array_while = function(next) {
  let v = [];
  while (true) {
    let x = next(v.length);
    if (!x)
      break;
    v.push(x);
  }
  return v;
};
var read_transposed = function(n, w, next) {
  let m = Array(n).fill().map(() => []);
  for (let i = 0;i < w; i++) {
    read_deltas(n, next).forEach((x, j) => m[j].push(x));
  }
  return m;
};
var read_linear_table = function(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return m.flatMap((v, i) => {
    let [x, ...ys] = v;
    return Array(vN[i]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  });
};
var read_replacement_table = function(w, next) {
  let n = 1 + next();
  let m = read_transposed(n, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
};
var read_trie = function(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode2([]), []);
  return ret;
  function decode2(Q) {
    let S = next();
    let B = read_array_while(() => {
      let cps = read_sorted(next).map((i) => sorted[i]);
      if (cps.length)
        return decode2(cps);
    });
    return { S, B, Q };
  }
  function expand({ S, B }, cps, saved) {
    if (S & 4 && saved === cps[cps.length - 1])
      return;
    if (S & 2)
      saved = cps[cps.length - 1];
    if (S & 1)
      ret.push(cps);
    for (let br of B) {
      for (let cp of br.Q) {
        expand(br, [...cps, cp], saved);
      }
    }
  }
};
var hex_cp = function(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
};
var quote_cp = function(cp) {
  return `{${hex_cp(cp)}}`;
};
var explode_cp = function(s) {
  let cps = [];
  for (let pos = 0, len = s.length;pos < len; ) {
    let cp = s.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
};
var str_from_cps = function(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk)
    return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0;i < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
  }
  return buf.join("");
};
var compare_arrays = function(a, b) {
  let n = a.length;
  let c = n - b.length;
  for (let i = 0;c == 0 && i < n; i++)
    c = a[i] - b[i];
  return c;
};
var unpack_cc = function(packed) {
  return packed >> 24 & 255;
};
var unpack_cp = function(packed) {
  return packed & 16777215;
};
var init$1 = function() {
  let r = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r));
  DECOMP = new Map;
  RECOMP = new Map;
  for (let [cp, cps] of read_mapped(r)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a, b] = cps;
      let bucket = RECOMP.get(a);
      if (!bucket) {
        bucket = new Map;
        RECOMP.set(a, bucket);
      }
      bucket.set(b, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
};
var is_hangul = function(cp) {
  return cp >= S0 && cp < S1;
};
var compose_pair = function(a, b) {
  if (a >= L0 && a < L1 && b >= V0 && b < V1) {
    return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
  } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {
    return a + (b - T0);
  } else {
    let recomp = RECOMP.get(a);
    if (recomp) {
      recomp = recomp.get(b);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
};
var decomposed = function(cps) {
  if (!SHIFTED_RANK)
    init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add2(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add2(L0 + l_index);
        add2(V0 + v_index);
        if (t_index > 0)
          add2(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add2(cp);
        }
      }
      if (!buf.length)
        break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i = 1;i < ret.length; i++) {
      let cc = unpack_cc(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j)
          break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc)
          break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
};
var composed_from_decomposed = function(v) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
};
var nfd = function(cps) {
  return decomposed(cps).map(unpack_cp);
};
var nfc = function(cps) {
  return composed_from_decomposed(decomposed(cps));
};
var group_has_cp = function(g, cp) {
  return g.P.has(cp) || g.Q.has(cp);
};
var init = function() {
  if (MAPPED)
    return;
  let r = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set, v) => v.forEach((x) => set.add(x));
  MAPPED = new Map(read_mapped(r));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i) => CM[i]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  NFC_CHECK = read_sorted_set();
  let chunks = read_sorted_arrays(r);
  let unrestricted = r();
  const read_chunked = () => {
    let set = new Set;
    read_sorted_array().forEach((i) => set_add_many(set, chunks[i]));
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS = read_array_while((i) => {
    let N = read_array_while(r).map((x) => x + 96);
    if (N.length) {
      let R = i >= unrestricted;
      N[0] -= 32;
      N = str_from_cps(N);
      if (R)
        N = `Restricted[${N}]`;
      let P = read_chunked();
      let Q = read_chunked();
      let M = !r();
      return { N, P, Q, M, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = new Map;
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a - b);
  wholes.forEach((cp, i) => {
    let d = r();
    let w = wholes[i] = d ? wholes[i - d] : { V: [], M: new Map };
    w.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V) {
      let gs = GROUPS.filter((g) => group_has_cp(g, cp));
      let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
      if (!rec) {
        rec = { G: new Set, V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs);
    }
    let union = recs.flatMap((x) => Array_from(x.G));
    for (let { G, V: V2 } of recs) {
      let complement = new Set(union.filter((g) => !G.has(g)));
      for (let cp of V2) {
        M.set(cp, complement);
      }
    }
  }
  VALID = new Set;
  let multi = new Set;
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g of GROUPS) {
    for (let cp of g.P)
      add_to_union(cp);
    for (let cp of g.Q)
      add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r).map((v) => Emoji.from(v)).sort(compare_arrays);
  EMOJI_ROOT = new Map;
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = new Map;
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x of prev) {
      x.V = cps;
    }
  }
};
var quoted_cp = function(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
};
var bidi_qq = function(s) {
  return `"${s}"\u200E`;
};
var check_label_extension = function(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
};
var check_leading_underscore = function(cps) {
  const UNDERSCORE = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE);i > 0; ) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
};
var check_fenced = function(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev)
    throw error_placement(`leading ${prev}`);
  let n = cps.length;
  let last = -1;
  for (let i = 1;i < n; i++) {
    cp = cps[i];
    let match = FENCED.get(cp);
    if (match) {
      if (last == i)
        throw error_placement(`${prev} + ${match}`);
      last = i + 1;
      prev = match;
    }
  }
  if (last == n)
    throw error_placement(`trailing ${prev}`);
};
var safe_str_from_cps = function(cps, max = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0]))
    buf.push("\u25CC");
  if (cps.length > max) {
    max >>= 1;
    cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
  }
  let prev = 0;
  let n = cps.length;
  for (let i = 0;i < n; i++) {
    let cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n)));
  return buf.join("");
};
var is_combining_mark = function(cp) {
  init();
  return CM.has(cp);
};
var should_escape = function(cp) {
  init();
  return ESCAPE.has(cp);
};
var ens_normalize = function(name) {
  return flatten(split2(name, nfc, filter_fe0f));
};
var split2 = function(name, nf, ef) {
  if (!name)
    return [];
  init();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type = "ASCII";
      } else {
        let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
        if (!chars.length) {
          type = "Emoji";
        } else {
          if (CM.has(norm[0]))
            throw error_placement("leading combining mark");
          for (let i = 1;i < token_count; i++) {
            let cps = tokens[i];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g] = determine_group(unique);
          check_group(g, chars);
          check_whole(g, unique);
          type = g.N;
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
};
var check_whole = function(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH)
      return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g) => set.has(g)) : Array_from(set);
      if (!maker.length)
        return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g of maker) {
      if (shared.every((cp) => group_has_cp(g, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
      }
    }
  }
};
var determine_group = function(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g) => group_has_cp(g, cp));
    if (!gs.length) {
      if (!GROUPS.some((g) => group_has_cp(g, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1)
      break;
  }
  return groups;
};
var flatten = function(split3) {
  return split3.map(({ input, error, output: output2 }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split3.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
    }
    return str_from_cps(output2);
  }).join(STOP_CH);
};
var error_disallowed = function(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
};
var error_group_member = function(g, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g2) => g2.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g.N} + ${quoted}`);
};
var error_placement = function(where) {
  return new Error(`illegal placement: ${where}`);
};
var check_group = function(g, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g, cp)) {
      throw error_group_member(g, cp);
    }
  }
  if (g.M) {
    let decomposed2 = nfd(cps);
    for (let i = 1, e = decomposed2.length;i < e; i++) {
      if (NSM.has(decomposed2[i])) {
        let j = i + 1;
        for (let cp;j < e && NSM.has(cp = decomposed2[j]); j++) {
          for (let k = i;k < j; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j - i > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
        }
        i = j;
      }
    }
  }
};
var tokens_from_str = function(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
};
var filter_fe0f = function(cps) {
  return cps.filter((cp) => cp != FE0F);
};
var consume_emoji_reversed = function(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node)
      break;
    let { V } = node;
    if (V) {
      emoji = V;
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
};
var COMPRESSED$1 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
var FENCED = new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
var NSM_MAX = 4;
var COMPRESSED = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
var S0 = 44032;
var L0 = 4352;
var V0 = 4449;
var T0 = 4519;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var N_COUNT = V_COUNT * T_COUNT;
var S_COUNT = L_COUNT * N_COUNT;
var S1 = S0 + S_COUNT;
var L1 = L0 + L_COUNT;
var V1 = V0 + V_COUNT;
var T1 = T0 + T_COUNT;
var SHIFTED_RANK;
var EXCLUSIONS;
var DECOMP;
var RECOMP;
var HYPHEN = 45;
var STOP_CH = ".";
var FE0F = 65039;
var UNIQUE_PH = 1;
var Array_from = (x) => Array.from(x);

class Emoji extends Array {
  get is_emoji() {
    return true;
  }
}
var MAPPED;
var IGNORED;
var CM;
var NSM;
var ESCAPE;
var NFC_CHECK;
var GROUPS;
var WHOLE_VALID;
var WHOLE_MAP;
var VALID;
var EMOJI_LIST;
var EMOJI_ROOT;

// node_modules/web3-eth-ens/lib/esm/utils.js
var normalize = (name) => ens_normalize(name);
var namehash = (inputName) => {
  let node = "";
  for (let i = 0;i < 32; i += 1) {
    node += "00";
  }
  if (inputName) {
    const name = normalize(inputName);
    const labels = name.split(".");
    for (let i = labels.length - 1;i >= 0; i -= 1) {
      const labelSha = sha3Raw(labels[i]).slice(2);
      node = sha3Raw(`0x${node}${labelSha}`).slice(2);
    }
  }
  return `0x${node}`;
};

// node_modules/web3-eth-ens/lib/esm/registry.js
var __awaiter34 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Registry {
  constructor(context, customRegistryAddress) {
    this.contract = new Contract(ENSRegistryAbi, customRegistryAddress !== null && customRegistryAddress !== undefined ? customRegistryAddress : registryAddresses.main, context);
    this.context = context;
  }
  getOwner(name) {
    return __awaiter34(this, undefined, undefined, function* () {
      try {
        const result = this.contract.methods.owner(namehash(name)).call();
        return result;
      } catch (error) {
        throw new Error;
      }
    });
  }
  getTTL(name) {
    return __awaiter34(this, undefined, undefined, function* () {
      try {
        return this.contract.methods.ttl(namehash(name)).call();
      } catch (error) {
        throw new Error;
      }
    });
  }
  recordExists(name) {
    return __awaiter34(this, undefined, undefined, function* () {
      try {
        const promise = this.contract.methods.recordExists(namehash(name)).call();
        return promise;
      } catch (error) {
        throw new Error;
      }
    });
  }
  getResolver(name) {
    return __awaiter34(this, undefined, undefined, function* () {
      try {
        return this.contract.methods.resolver(namehash(name)).call().then((address7) => {
          if (typeof address7 === "string") {
            const contract3 = new Contract(PublicResolverAbi, address7, this.context);
            return contract3;
          }
          throw new Error;
        });
      } catch (error) {
        throw new Error;
      }
    });
  }
  get events() {
    return this.contract.events;
  }
}

// node_modules/web3-eth-ens/lib/esm/resolver.js
var __awaiter35 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Resolver {
  constructor(registry) {
    this.registry = registry;
  }
  getResolverContractAdapter(ENSName) {
    return __awaiter35(this, undefined, undefined, function* () {
      return this.registry.getResolver(ENSName);
    });
  }
  checkInterfaceSupport(resolverContract, methodName) {
    var _a4, _b;
    return __awaiter35(this, undefined, undefined, function* () {
      if (isNullish2(interfaceIds[methodName]))
        throw new ResolverMethodMissingError((_a4 = resolverContract.options.address) !== null && _a4 !== undefined ? _a4 : "", methodName);
      const supported = yield resolverContract.methods.supportsInterface(interfaceIds[methodName]).call();
      if (!supported)
        throw new ResolverMethodMissingError((_b = resolverContract.options.address) !== null && _b !== undefined ? _b : "", methodName);
    });
  }
  supportsInterface(ENSName, interfaceId) {
    var _a4;
    return __awaiter35(this, undefined, undefined, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      let interfaceIdParam = interfaceId;
      if (!isHexStrict(interfaceIdParam)) {
        interfaceIdParam = (_a4 = sha32(interfaceId)) !== null && _a4 !== undefined ? _a4 : "";
        if (interfaceId === "")
          throw new Error("Invalid interface Id");
        interfaceIdParam = interfaceIdParam.slice(0, 10);
      }
      return resolverContract.methods.supportsInterface(interfaceIdParam).call();
    });
  }
  getAddress(ENSName, coinType = 60) {
    return __awaiter35(this, undefined, undefined, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      yield this.checkInterfaceSupport(resolverContract, methodsInInterface.addr);
      return resolverContract.methods.addr(namehash(ENSName), coinType).call();
    });
  }
  getPubkey(ENSName) {
    return __awaiter35(this, undefined, undefined, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      yield this.checkInterfaceSupport(resolverContract, methodsInInterface.pubkey);
      return resolverContract.methods.pubkey(namehash(ENSName)).call();
    });
  }
  getContenthash(ENSName) {
    return __awaiter35(this, undefined, undefined, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      yield this.checkInterfaceSupport(resolverContract, methodsInInterface.contenthash);
      return resolverContract.methods.contenthash(namehash(ENSName)).call();
    });
  }
  setAddress(ENSName, address7, txConfig) {
    return __awaiter35(this, undefined, undefined, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      yield this.checkInterfaceSupport(resolverContract, methodsInInterface.setAddr);
      return resolverContract.methods.setAddr(namehash(ENSName), address7).send(txConfig);
    });
  }
}

// node_modules/web3-eth-ens/lib/esm/ens.js
var __awaiter36 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class ENS extends Web3Context {
  constructor(registryAddr, provider) {
    super(provider !== null && provider !== undefined ? provider : "");
    this.registryAddress = registryAddr !== null && registryAddr !== undefined ? registryAddr : registryAddresses.main;
    this._registry = new Registry(this.getContextObject(), registryAddr);
    this._resolver = new Resolver(this._registry);
  }
  getResolver(name) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._registry.getResolver(name);
    });
  }
  recordExists(name) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._registry.recordExists(name);
    });
  }
  getTTL(name) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._registry.getTTL(name);
    });
  }
  getOwner(name) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._registry.getOwner(name);
    });
  }
  getAddress(ENSName, coinType = 60) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._resolver.getAddress(ENSName, coinType);
    });
  }
  getPubkey(ENSName) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._resolver.getPubkey(ENSName);
    });
  }
  getContenthash(ENSName) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._resolver.getContenthash(ENSName);
    });
  }
  checkNetwork() {
    return __awaiter36(this, undefined, undefined, function* () {
      const now = Date.now() / 1000;
      if (!this._lastSyncCheck || now - this._lastSyncCheck > 3600) {
        const syncInfo = yield isSyncing(this);
        if (!(typeof syncInfo === "boolean" && !syncInfo)) {
          throw new ENSNetworkNotSyncedError;
        }
        this._lastSyncCheck = now;
      }
      if (this._detectedAddress) {
        return this._detectedAddress;
      }
      const networkType = yield getId2(this, Object.assign(Object.assign({}, DEFAULT_RETURN_FORMAT), { number: FMT_NUMBER.HEX }));
      const addr = registryAddresses[networkIds[networkType]];
      if (typeof addr === "undefined") {
        throw new ENSUnsupportedNetworkError(networkType);
      }
      this._detectedAddress = addr;
      return this._detectedAddress;
    });
  }
  supportsInterface(ENSName, interfaceId) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._resolver.supportsInterface(ENSName, interfaceId);
    });
  }
  get events() {
    return this._registry.events;
  }
  setAddress(name, address7, txConfig) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._resolver.setAddress(name, address7, txConfig);
    });
  }
}
// node_modules/web3-eth-personal/lib/esm/rpc_method_wrappers.js
var __awaiter37 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getAccounts3 = (requestManager) => __awaiter37(undefined, undefined, undefined, function* () {
  const result = yield exports_personal_rpc_methods.getAccounts(requestManager);
  return result.map(toChecksumAddress);
});
var newAccount2 = (requestManager, password) => __awaiter37(undefined, undefined, undefined, function* () {
  validator2.validate(["string"], [password]);
  const result = yield exports_personal_rpc_methods.newAccount(requestManager, password);
  return toChecksumAddress(result);
});
var unlockAccount2 = (requestManager, address7, password, unlockDuration) => __awaiter37(undefined, undefined, undefined, function* () {
  validator2.validate(["address", "string", "uint"], [address7, password, unlockDuration]);
  return exports_personal_rpc_methods.unlockAccount(requestManager, address7, password, unlockDuration);
});
var lockAccount2 = (requestManager, address7) => __awaiter37(undefined, undefined, undefined, function* () {
  validator2.validate(["address"], [address7]);
  return exports_personal_rpc_methods.lockAccount(requestManager, address7);
});
var importRawKey2 = (requestManager, keyData, passphrase) => __awaiter37(undefined, undefined, undefined, function* () {
  validator2.validate(["string", "string"], [keyData, passphrase]);
  return exports_personal_rpc_methods.importRawKey(requestManager, keyData, passphrase);
});
var sendTransaction4 = (requestManager, tx2, passphrase) => __awaiter37(undefined, undefined, undefined, function* () {
  const formattedTx = formatTransaction(tx2, ETH_DATA_FORMAT);
  return exports_personal_rpc_methods.sendTransaction(requestManager, formattedTx, passphrase);
});
var signTransaction5 = (requestManager, tx2, passphrase) => __awaiter37(undefined, undefined, undefined, function* () {
  const formattedTx = formatTransaction(tx2, ETH_DATA_FORMAT);
  return exports_personal_rpc_methods.signTransaction(requestManager, formattedTx, passphrase);
});
var sign5 = (requestManager, data, address7, passphrase) => __awaiter37(undefined, undefined, undefined, function* () {
  validator2.validate(["string", "address", "string"], [data, address7, passphrase]);
  const dataToSign = isHexStrict(data) ? data : utf8ToHex(data);
  return exports_personal_rpc_methods.sign(requestManager, dataToSign, address7, passphrase);
});
var ecRecover2 = (requestManager, signedData, signature) => __awaiter37(undefined, undefined, undefined, function* () {
  validator2.validate(["string", "string"], [signedData, signature]);
  const signedDataString = isHexStrict(signedData) ? signedData : utf8ToHex(signedData);
  return exports_personal_rpc_methods.ecRecover(requestManager, signedDataString, signature);
});

// node_modules/web3-eth-personal/lib/esm/personal.js
var __awaiter38 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Personal extends Web3Context {
  getAccounts() {
    return __awaiter38(this, undefined, undefined, function* () {
      return getAccounts3(this.requestManager);
    });
  }
  newAccount(password) {
    return __awaiter38(this, undefined, undefined, function* () {
      return newAccount2(this.requestManager, password);
    });
  }
  unlockAccount(address7, password, unlockDuration) {
    return __awaiter38(this, undefined, undefined, function* () {
      return unlockAccount2(this.requestManager, address7, password, unlockDuration);
    });
  }
  lockAccount(address7) {
    return __awaiter38(this, undefined, undefined, function* () {
      return lockAccount2(this.requestManager, address7);
    });
  }
  importRawKey(keyData, passphrase) {
    return __awaiter38(this, undefined, undefined, function* () {
      return importRawKey2(this.requestManager, keyData, passphrase);
    });
  }
  sendTransaction(tx2, passphrase) {
    return __awaiter38(this, undefined, undefined, function* () {
      return sendTransaction4(this.requestManager, tx2, passphrase);
    });
  }
  signTransaction(tx2, passphrase) {
    return __awaiter38(this, undefined, undefined, function* () {
      return signTransaction5(this.requestManager, tx2, passphrase);
    });
  }
  sign(data, address7, passphrase) {
    return __awaiter38(this, undefined, undefined, function* () {
      return sign5(this.requestManager, data, address7, passphrase);
    });
  }
  ecRecover(signedData, signature) {
    return __awaiter38(this, undefined, undefined, function* () {
      return ecRecover2(this.requestManager, signedData, signature);
    });
  }
}
// node_modules/web3/lib/esm/abi.js
var abi_default = {
  encodeEventSignature,
  encodeFunctionCall,
  encodeFunctionSignature,
  encodeParameter,
  encodeParameters,
  decodeParameter,
  decodeParameters: decodeParameters2,
  decodeLog
};

// node_modules/web3/lib/esm/accounts.js
var __awaiter39 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var initAccountsForContext = (context) => {
  const signTransactionWithContext = (transaction, privateKey) => __awaiter39(undefined, undefined, undefined, function* () {
    const tx2 = yield prepareTransactionForSigning(transaction, context);
    const privateKeyBytes = format({ format: "bytes" }, privateKey, ETH_DATA_FORMAT);
    return signTransaction(tx2, privateKeyBytes);
  });
  const privateKeyToAccountWithContext = (privateKey) => {
    const account2 = privateKeyToAccount(privateKey);
    return Object.assign(Object.assign({}, account2), { signTransaction: (transaction) => __awaiter39(undefined, undefined, undefined, function* () {
      return signTransactionWithContext(transaction, account2.privateKey);
    }) });
  };
  const decryptWithContext = (keystore, password, options) => __awaiter39(undefined, undefined, undefined, function* () {
    var _a4;
    const account2 = yield decrypt2(keystore, password, (_a4 = options === null || options === undefined ? undefined : options.nonStrict) !== null && _a4 !== undefined ? _a4 : true);
    return Object.assign(Object.assign({}, account2), { signTransaction: (transaction) => __awaiter39(undefined, undefined, undefined, function* () {
      return signTransactionWithContext(transaction, account2.privateKey);
    }) });
  });
  const createWithContext = () => {
    const account2 = create();
    return Object.assign(Object.assign({}, account2), { signTransaction: (transaction) => __awaiter39(undefined, undefined, undefined, function* () {
      return signTransactionWithContext(transaction, account2.privateKey);
    }) });
  };
  const wallet2 = new Wallet({
    create: createWithContext,
    privateKeyToAccount: privateKeyToAccountWithContext,
    decrypt: decryptWithContext
  });
  return {
    signTransaction: signTransactionWithContext,
    create: createWithContext,
    privateKeyToAccount: privateKeyToAccountWithContext,
    decrypt: decryptWithContext,
    recoverTransaction,
    hashMessage,
    sign,
    recover,
    encrypt: encrypt2,
    wallet: wallet2,
    privateKeyToAddress,
    parseAndValidatePrivateKey,
    privateKeyToPublicKey
  };
};

// node_modules/web3/lib/esm/version.js
var Web3PkgInfo = { version: "4.6.0" };

// node_modules/web3/lib/esm/web3_eip6963.js
var __awaiter40 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Eip6963EventName;
(function(Eip6963EventName2) {
  Eip6963EventName2["eip6963announceProvider"] = "eip6963:announceProvider";
  Eip6963EventName2["eip6963requestProvider"] = "eip6963:requestProvider";
})(Eip6963EventName || (Eip6963EventName = {}));
var eip6963ProvidersMap = new Map;
var web3ProvidersMapUpdated = "web3:providersMapUpdated";
var requestEIP6963Providers = () => __awaiter40(undefined, undefined, undefined, function* () {
  return new Promise((resolve, reject) => {
    if (typeof window === "undefined") {
      reject(new Error("window object not available, EIP-6963 is intended to be used within a browser"));
    }
    window.addEventListener(Eip6963EventName.eip6963announceProvider, (event) => {
      eip6963ProvidersMap.set(event.detail.info.uuid, event.detail);
      const newEvent = new CustomEvent(web3ProvidersMapUpdated, { detail: eip6963ProvidersMap });
      window.dispatchEvent(newEvent);
      resolve(eip6963ProvidersMap);
    });
    window.dispatchEvent(new Event(Eip6963EventName.eip6963requestProvider));
  });
});
var onNewProviderDiscovered = (callback) => {
  if (typeof window === "undefined") {
    throw new Error("window object not available, EIP-6963 is intended to be used within a browser");
  }
  window.addEventListener(web3ProvidersMapUpdated, callback);
};

// node_modules/web3/lib/esm/web3.js
class Web3 extends Web3Context {
  constructor(providerOrContext) {
    var _a4;
    if (isNullish2(providerOrContext) || typeof providerOrContext === "string" && providerOrContext.trim() === "" || typeof providerOrContext !== "string" && !isSupportedProvider(providerOrContext) && !providerOrContext.provider) {
      console.warn("NOTE: web3.js is running without provider. You need to pass a provider in order to interact with the network!");
    }
    let contextInitOptions = {};
    if (typeof providerOrContext === "string" || isSupportedProvider(providerOrContext)) {
      contextInitOptions.provider = providerOrContext;
    } else if (providerOrContext) {
      contextInitOptions = providerOrContext;
    } else {
      contextInitOptions = {};
    }
    contextInitOptions.registeredSubscriptions = Object.assign(Object.assign({}, registeredSubscriptions), (_a4 = contextInitOptions.registeredSubscriptions) !== null && _a4 !== undefined ? _a4 : {});
    super(contextInitOptions);
    const accounts2 = initAccountsForContext(this);
    this._wallet = accounts2.wallet;
    this._accountProvider = accounts2;
    this.utils = exports_esm;
    const self2 = this;

    class ContractBuilder extends esm_default {
      constructor(jsonInterface, addressOrOptionsOrContext, optionsOrContextOrReturnFormat, contextOrReturnFormat, returnFormat) {
        if (isContractInitOptions(addressOrOptionsOrContext) && isContractInitOptions(optionsOrContextOrReturnFormat)) {
          throw new InvalidMethodParamsError("Should not provide options at both 2nd and 3rd parameters");
        }
        let address7;
        let options = {};
        let context;
        let dataFormat = DEFAULT_RETURN_FORMAT;
        if (!isNullish2(addressOrOptionsOrContext) && typeof addressOrOptionsOrContext !== "object" && typeof addressOrOptionsOrContext !== "string") {
          throw new InvalidMethodParamsError;
        }
        if (typeof addressOrOptionsOrContext === "string") {
          address7 = addressOrOptionsOrContext;
        }
        if (isContractInitOptions(addressOrOptionsOrContext)) {
          options = addressOrOptionsOrContext;
        } else if (isContractInitOptions(optionsOrContextOrReturnFormat)) {
          options = optionsOrContextOrReturnFormat;
        } else {
          options = {};
        }
        if (addressOrOptionsOrContext instanceof Web3Context) {
          context = addressOrOptionsOrContext;
        } else if (optionsOrContextOrReturnFormat instanceof Web3Context) {
          context = optionsOrContextOrReturnFormat;
        } else if (contextOrReturnFormat instanceof Web3Context) {
          context = contextOrReturnFormat;
        } else {
          context = self2.getContextObject();
        }
        if (returnFormat) {
          dataFormat = returnFormat;
        } else if (isDataFormat(optionsOrContextOrReturnFormat)) {
          dataFormat = optionsOrContextOrReturnFormat;
        } else if (isDataFormat(contextOrReturnFormat)) {
          dataFormat = contextOrReturnFormat;
        }
        super(jsonInterface, address7, options, context, dataFormat);
        super.subscribeToContextEvents(self2);
      }
    }
    const eth2 = self2.use(Web3Eth);
    this.eth = Object.assign(eth2, {
      ens: self2.use(ENS, registryAddresses.main),
      Iban,
      net: self2.use(Net),
      personal: self2.use(Personal),
      Contract: ContractBuilder,
      abi: abi_default,
      accounts: accounts2
    });
  }
}
Web3.version = Web3PkgInfo.version;
Web3.utils = exports_esm;
Web3.requestEIP6963Providers = requestEIP6963Providers;
Web3.onNewProviderDiscovered = onNewProviderDiscovered;
Web3.modules = {
  Web3Eth,
  Iban,
  Net,
  ENS,
  Personal
};
var web3_default = Web3;
// node_modules/web3/lib/esm/index.js
var esm_default2 = web3_default;

// src/chain/chain.ts
class BaseChain {
}

// src/notify.ts
var client4 = __toESM(require_default2(), 1);

// src/constants.ts
var WRAPPED_NATIVE = [
  "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
  "so11111111111111111111111111111111111111112"
];
var TOKEN_TRANSFER_HASH = esm_default2.utils.sha3("Transfer(address,address,uint256)");
var V3_ROUTER = "0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad";
var V3_EXECUTE = esm_default2.utils.sha3("execute(bytes,bytes[],uint256)").slice(0, 10);
var V2_ROUTER = [
  "0x7a250d5630b4cf539739df2c5dacb4c659f2488d",
  "0x10ed43c718714eb63d5aa57b78b54704e256024e",
  "0x1b02da8cb0d097eb8d57a175b88c7d8b47997506"
];
var V2_SWAP_EXACT_TOKENS_FOR_TOKENS = esm_default2.utils.sha3("swapExactTokensForTokens(uint256,uint256,address[],address,uint256)").slice(0, 10);
var V2_SWAP_TOKENS_FOR_EXACT_TOKENS = esm_default2.utils.sha3("swapTokensForExactTokens(uint256,uint256,address[],address,uint256)").slice(0, 10);
var V2_SWAP_TOKENS_FOR_EXACT_ETH = esm_default2.utils.sha3("swapTokensForExactETH(uint256,uint256,address[],address,uint256)").slice(0, 10);
var V2_SWAP_EXACT_TOKENS_FOR_ETH = esm_default2.utils.sha3("swapExactTokensForETH(uint256,uint256,address[],address,uint256)").slice(0, 10);
var V2_SWAP_EXACT_TOKENS_FOR_ETH_FEE = esm_default2.utils.sha3("swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)").slice(0, 10);
var V2_SWAP_EXACT_TOKENS_FOR_TOKENS_FEE = esm_default2.utils.sha3("swapExactTokensForTokens(uint256,uint256,address[],address,uint256)").slice(0, 10);
var V2_SWAP_EXACT_ETH_FOR_TOKENS = esm_default2.utils.sha3("swapExactETHForTokens(uint256,address[],address,uint256)").slice(0, 10);
var V2_SWAP_ETH_FOR_EXACT_TOKENS = esm_default2.utils.sha3("swapETHForExactTokens(uint256,address[],address,uint256)").slice(0, 10);
var V2_SWAP_EXACT_ETH_FOR_TOKENS_FEE = esm_default2.utils.sha3("swapExactETHForTokensSupportingFeeOnTransferTokens(uint256,address[],address,uint256)").slice(0, 10);

// prisma/db.ts
var client = __toESM(require_default2(), 1);
var prisma = new client.PrismaClient({});

// bot.ts
var import_telegraf = __toESM(require_lib(), 1);
var bot = new import_telegraf.Telegraf("6663381418:AAHCHkezD1uj7tXFomkLds4CN-WH7Q3w3jU");

// node_modules/decimal.js/decimal.mjs
var digitsToString = function(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1;i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (;w % 10 === 0; )
    w /= 10;
  return str + w;
};
var checkInt32 = function(i, min, max) {
  if (i !== ~~i || i < min || i > max) {
    throw Error(invalidArgument + i);
  }
};
var checkRoundingDigits = function(d, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0];k >= 10; k /= 10)
    --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0)
        rd = rd / 100 | 0;
      else if (i == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0)
        rd = rd / 1000 | 0;
      else if (i == 1)
        rd = rd / 100 | 0;
      else if (i == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
};
var convertBase = function(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str.length;
  for (;i < strL; ) {
    for (arrL = arr.length;arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0;j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === undefined)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
};
var cosine = function(Ctor, x) {
  var k, len, y;
  if (x.isZero())
    return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i = k;i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
};
var finalise = function(x, sd, rm, isTruncated) {
  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out:
    if (sd != null) {
      xd = x.d;
      if (!xd)
        return x;
      for (digits = 1, k = xd[0];k >= 10; k /= 10)
        digits++;
      i = sd - digits;
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (;k++ <= xdi; )
              xd.push(0);
            w = rd = 0;
            digits = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];
          for (digits = 1;k >= 10; k /= 10)
            digits++;
          i %= LOG_BASE;
          j = i - LOG_BASE + digits;
          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== undefined || (j < 0 ? w : w % mathpow(10, digits - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (;; ) {
          if (xdi == 0) {
            for (i = 1, j = xd[0];j >= 10; j /= 10)
              i++;
            j = xd[0] += k;
            for (k = 1;j >= 10; j /= 10)
              k++;
            if (i != k) {
              x.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i = xd.length;xd[--i] === 0; )
        xd.pop();
    }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
};
var finiteToString = function(x, isExp, sd) {
  if (!x.isFinite())
    return nonFiniteToString(x);
  var k, e = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return str;
};
var getBase10Exponent = function(digits, e) {
  var w = digits[0];
  for (e *= LOG_BASE;w >= 10; w /= 10)
    e++;
  return e;
};
var getLn10 = function(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
};
var getPi = function(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
};
var getPrecision = function(digits) {
  var w = digits.length - 1, len = w * LOG_BASE + 1;
  w = digits[w];
  if (w) {
    for (;w % 10 == 0; w /= 10)
      len--;
    for (w = digits[0];w >= 10; w /= 10)
      len++;
  }
  return len;
};
var getZeroString = function(k) {
  var zs = "";
  for (;k--; )
    zs += "0";
  return zs;
};
var intPow = function(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (;; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k))
        isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
};
var isOdd = function(n) {
  return n.d[n.d.length - 1] & 1;
};
var maxOrMin = function(Ctor, args, ltgt) {
  var y, x = new Ctor(args[0]), i = 0;
  for (;++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    } else if (x[ltgt](y)) {
      x = y;
    }
  }
  return x;
};
var naturalExponential = function(x, sd) {
  var denominator, guard, j, pow3, sum, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow3 = sum = new Ctor(1);
  Ctor.precision = wpr;
  for (;; ) {
    pow3 = finalise(pow3.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum.plus(divide(pow3, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      j = k;
      while (j--)
        sum = finalise(sum.times(sum), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow3 = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum;
      }
    }
    sum = t;
  }
};
var naturalLogarithm = function(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x.e) < 1500000000000000) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (;; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      sum = sum.times(2);
      if (e !== 0)
        sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum = divide(sum, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum;
      }
    }
    sum = t;
    denominator += 2;
  }
};
var nonFiniteToString = function(x) {
  return String(x.s * x.s / 0);
};
var parseDecimal = function(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0;str.charCodeAt(i) === 48; i++)
    ;
  for (len = str.length;str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0)
      i += LOG_BASE;
    if (i < len) {
      if (i)
        x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE;i < len; )
        x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (;i--; )
      str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
};
var parseOther = function(x, str) {
  var base3, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str))
      return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex3.test(str)) {
    base3 = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base3 = 2;
  } else if (isOctal.test(str)) {
    base3 = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base3), i, i * 2);
  }
  xd = convertBase(str, base3, BASE);
  xe = xd.length - 1;
  for (i = xe;xd[i] === 0; --i)
    xd.pop();
  if (i < 0)
    return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat)
    x = divide(x, divisor, len * 4);
  if (p)
    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal2.pow(2, p));
  external = true;
  return x;
};
var sine = function(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (;k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
};
var taylorSeries = function(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (;; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== undefined) {
      for (j = k;t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
    i++;
  }
  external = true;
  t.d.length = k + 1;
  return t;
};
var tinyPow = function(b, e) {
  var n = b;
  while (--e)
    n *= b;
  return n;
};
var toLessThanHalfPi = function(Ctor, x) {
  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
};
var toStringBinary = function(x, baseOut, sd, rm) {
  var base3, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== undefined;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf(".");
    if (isExp) {
      base3 = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base3 = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base3);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base3);
    e = len = xd.length;
    for (;xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base3);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base3 / 2;
      roundUp = roundUp || xd[sd + 1] !== undefined;
      roundUp = rm < 4 ? (i !== undefined || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (;++xd[--sd] > base3 - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length;!xd[len - 1]; --len)
        ;
      for (i = 0, str = "";i < len; i++)
        str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len;len % i; len++)
              str += "0";
            xd = convertBase(str, base3, baseOut);
            for (len = xd.length;!xd[len - 1]; --len)
              ;
            for (i = 1, str = "1.";i < len; i++)
              str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (;++e; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len)
          for (e -= len;e--; )
            str += "0";
        else if (e < len)
          str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
};
var truncate = function(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
};
var abs = function(x) {
  return new this(x).abs();
};
var acos = function(x) {
  return new this(x).acos();
};
var acosh = function(x) {
  return new this(x).acosh();
};
var add2 = function(x, y) {
  return new this(x).plus(y);
};
var asin = function(x) {
  return new this(x).asin();
};
var asinh = function(x) {
  return new this(x).asinh();
};
var atan = function(x) {
  return new this(x).atan();
};
var atanh = function(x) {
  return new this(x).atanh();
};
var atan2 = function(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
};
var cbrt = function(x) {
  return new this(x).cbrt();
};
var ceil = function(x) {
  return finalise(x = new this(x), x.e + 1, 2);
};
var clamp = function(x, min, max) {
  return new this(x).clamp(min, max);
};
var config6 = function(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0;i < ps.length; i += 3) {
    if (p = ps[i], useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== undefined) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults)
    this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== undefined) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
};
var cos = function(x) {
  return new this(x).cos();
};
var cosh = function(x) {
  return new this(x).cosh();
};
var clone = function(obj) {
  var i, p, ps;
  function Decimal2(v) {
    var e, i2, t, x = this;
    if (!(x instanceof Decimal2))
      return new Decimal2(v);
    x.constructor = Decimal2;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal2.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal2.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v;i2 >= 10; i2 /= 10)
          e++;
        if (external) {
          if (e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }
        return;
      } else if (v * 0 !== 0) {
        if (!v)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    } else if (t !== "string") {
      throw Error(invalidArgument + v);
    }
    if ((i2 = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      if (i2 === 43)
        v = v.slice(1);
      x.s = 1;
    }
    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config6;
  Decimal2.clone = clone;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs;
  Decimal2.acos = acos;
  Decimal2.acosh = acosh;
  Decimal2.add = add2;
  Decimal2.asin = asin;
  Decimal2.asinh = asinh;
  Decimal2.atan = atan;
  Decimal2.atanh = atanh;
  Decimal2.atan2 = atan2;
  Decimal2.cbrt = cbrt;
  Decimal2.ceil = ceil;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos;
  Decimal2.cosh = cosh;
  Decimal2.div = div;
  Decimal2.exp = exp;
  Decimal2.floor = floor;
  Decimal2.hypot = hypot;
  Decimal2.ln = ln;
  Decimal2.log = log;
  Decimal2.log10 = log10;
  Decimal2.log2 = log2;
  Decimal2.max = max;
  Decimal2.min = min;
  Decimal2.mod = mod2;
  Decimal2.mul = mul;
  Decimal2.pow = pow3;
  Decimal2.random = random4;
  Decimal2.round = round;
  Decimal2.sign = sign6;
  Decimal2.sin = sin;
  Decimal2.sinh = sinh;
  Decimal2.sqrt = sqrt;
  Decimal2.sub = sub;
  Decimal2.sum = sum;
  Decimal2.tan = tan;
  Decimal2.tanh = tanh;
  Decimal2.trunc = trunc;
  if (obj === undefined)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0;i < ps.length; )
        if (!obj.hasOwnProperty(p = ps[i++]))
          obj[p] = this[p];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
};
var div = function(x, y) {
  return new this(x).div(y);
};
var exp = function(x) {
  return new this(x).exp();
};
var floor = function(x) {
  return finalise(x = new this(x), x.e + 1, 3);
};
var hypot = function() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0;i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
};
var isDecimalInstance = function(obj) {
  return obj instanceof Decimal2 || obj && obj.toStringTag === tag || false;
};
var ln = function(x) {
  return new this(x).ln();
};
var log = function(x, y) {
  return new this(x).log(y);
};
var log2 = function(x) {
  return new this(x).log(2);
};
var log10 = function(x) {
  return new this(x).log(10);
};
var max = function() {
  return maxOrMin(this, arguments, "lt");
};
var min = function() {
  return maxOrMin(this, arguments, "gt");
};
var mod2 = function(x, y) {
  return new this(x).mod(y);
};
var mul = function(x, y) {
  return new this(x).mul(y);
};
var pow3 = function(x, y) {
  return new this(x).pow(y);
};
var random4 = function(sd) {
  var d, e, k, n, i = 0, r = new this(1), rd = [];
  if (sd === undefined)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (;i < k; )
      rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (;i < k; ) {
      n = d[i];
      if (n >= 4290000000) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (;i < k; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 2140000000) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }
  for (;rd[i] === 0; i--)
    rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (;rd[0] === 0; e -= LOG_BASE)
      rd.shift();
    for (k = 1, n = rd[0];n >= 10; n /= 10)
      k++;
    if (k < LOG_BASE)
      e -= LOG_BASE - k;
  }
  r.e = e;
  r.d = rd;
  return r;
};
var round = function(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
};
var sign6 = function(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
};
var sin = function(x) {
  return new this(x).sin();
};
var sinh = function(x) {
  return new this(x).sinh();
};
var sqrt = function(x) {
  return new this(x).sqrt();
};
var sub = function(x, y) {
  return new this(x).sub(y);
};
var sum = function() {
  var i = 0, args = arguments, x = new this(args[i]);
  external = false;
  for (;x.s && ++i < args.length; )
    x = x.plus(args[i]);
  external = true;
  return finalise(x, this.precision, this.rounding);
};
var tan = function(x) {
  return new this(x).tan();
};
var tanh = function(x) {
  return new this(x).tanh();
};
var trunc = function(x) {
  return finalise(x = new this(x), x.e + 1, 1);
};
/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var EXP_LIMIT = 9000000000000000;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  precision: 20,
  rounding: 4,
  modulo: 1,
  toExpNeg: -7,
  toExpPos: 21,
  minE: -EXP_LIMIT,
  maxE: EXP_LIMIT,
  crypto: false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex3 = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0)
    x.s = 1;
  return finalise(x);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min2, max2) {
  var k, x = this, Ctor = x.constructor;
  min2 = new Ctor(min2);
  max2 = new Ctor(max2);
  if (!min2.s || !max2.s)
    return new Ctor(NaN);
  if (min2.gt(max2))
    throw Error(invalidArgument + max2);
  k = x.cmp(min2);
  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
};
P.comparedTo = P.cmp = function(y) {
  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x.e !== y.e)
    return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL;i < j; ++i) {
    if (xd[i] !== yd[i])
      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d)
    return new Ctor(NaN);
  if (!x.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;
    if (s = (e - n.length + 1) % 3)
      n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (;; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.decimalPlaces = P.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w)
      for (;w % 10 == 0; w /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite())
    return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero())
    return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i = k, d8 = new Ctor(8);
  for (;i--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (;k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(x.s);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return halfPi.minus(x);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1))
    return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.e >= 0)
    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1)
    return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero())
    return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseTangent = P.atan = function() {
  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i = k;i; --i)
    x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (;i !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== undefined)
      for (i = j;r.d[i] === t.d[i] && i--; )
        ;
  }
  if (k)
    r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base3) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base3 == null) {
    base3 = new Ctor(10);
    isBase10 = true;
  } else {
    base3 = new Ctor(base3);
    d = base3.d;
    if (base3.s < 0 || !d || !d[0] || base3.eq(1))
      return new Ctor(NaN);
    isBase10 = base3.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0];k % 10 === 0; )
        k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base3, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base3, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 100000000000000) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P.minus = P.sub = function(y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (x.d)
      y.s = -y.s;
    else
      y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y.s = -y.s;
    else if (xd[0])
      y = new Ctor(x);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k;i--; )
      d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0;i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len;i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length;i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i;j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (;xd[--len] === 0; )
    xd.pop();
  for (;xd[0] === 0; xd.shift())
    --e;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.modulo = P.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0])
    return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P.plus = P.add = function(y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (!x.d)
      y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (;i--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0;i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length;xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.precision = P.sd = function(z2) {
  var k, x = this;
  if (z2 !== undefined && z2 !== !!z2 && z2 !== 1 && z2 !== 0)
    throw Error(invalidArgument + z2);
  if (x.d) {
    k = getPrecision(x.d);
    if (z2 && x.e + 1 > k)
      k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e) % 2 == 0)
      n += "0";
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (;; ) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.tangent = P.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P.times = P.mul = function(y) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL;i--; )
    r.push(0);
  for (i = ydL;--i >= 0; ) {
    carry = 0;
    for (k = xdL + i;k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (;!r[--rL]; )
    r.pop();
  if (carry)
    ++e;
  else
    r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === undefined)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === undefined)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === undefined) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === undefined) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd)
    return new Ctor(x);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1))
      throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e > 0 ? d : n1 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;
  for (;; ) {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d)
      return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === undefined) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d)
      return y.s ? x : y;
    if (!y.d) {
      if (y.s)
        y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y) {
  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0])
    return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1))
    return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1))
    return finalise(x, pr, rm);
  e = mathfloor(y.e / LOG_BASE);
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e < y.d.length - 1)
      return new Ctor(NaN);
    if ((y.d[e] & 1) == 0)
      s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
    return new Ctor(e > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 100000000000000) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === undefined) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === undefined) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
var divide = function() {
  function multiplyInteger(x, k, base3) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice();i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % base3 | 0;
      carry = temp / base3 | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  function compare(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0;i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract(a, b, aL, base3) {
    var i = 0;
    for (;aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base3 + a[aL] - b[aL];
    }
    for (;!a[0] && a.length > 1; )
      a.shift();
  }
  return function(x, y, pr, rm, dp, base3) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign7 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign7 * 0 : sign7 / 0);
    }
    if (base3) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base3 = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign7);
    qd = q.d = [];
    for (i = 0;yd[i] == (xd[i] || 0); i++)
      ;
    if (yd[i] > (xd[i] || 0))
      e--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (;(i < xL || k) && sd--; i++) {
          t = k * base3 + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i < xL;
      } else {
        k = base3 / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base3);
          xd = multiplyInteger(xd, k, base3);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (;remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base3 / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base3 + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base3)
                k = base3 - 1;
              prod = multiplyInteger(yd, k, base3);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base3);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract(rem, prod, remL, base3);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract(rem, yL < remL ? yz : yd, remL, base3);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== undefined) && sd--);
        more = rem[0] !== undefined;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {
      for (i = 1, k = qd[0];k >= 10; k /= 10)
        i++;
      q.e = i + e * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal2 = P.constructor = clone(DEFAULTS);
LN10 = new Decimal2(LN10);
PI = new Decimal2(PI);

// src/utils/getToken.ts
var client3 = __toESM(require_default2(), 1);

// node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = new Set;
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS;
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max2) => !isPosInt(max2) ? null : max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

class ZeroArray extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
}

class Stack {
  heap;
  length;
  static #constructing = false;
  static create(max2) {
    const HeapCls = getUintArray(max2);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s = new Stack(max2, HeapCls);
    Stack.#constructing = false;
    return s;
  }
  constructor(max2, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max2);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}

class LRUCache {
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  ttl;
  ttlResolution;
  ttlAutopurge;
  updateAgeOnGet;
  updateAgeOnHas;
  allowStale;
  noDisposeOnSet;
  noUpdateTTL;
  maxEntrySize;
  sizeCalculation;
  noDeleteOnFetchRejection;
  noDeleteOnStaleGet;
  allowStaleOnFetchAbort;
  allowStaleOnFetchRejection;
  ignoreFetchAbort;
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  static unsafeExposeInternals(c) {
    return {
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  get max() {
    return this.#max;
  }
  get maxSize() {
    return this.#maxSize;
  }
  get calculatedSize() {
    return this.#calculatedSize;
  }
  get size() {
    return this.#size;
  }
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get dispose() {
    return this.#dispose;
  }
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max2 !== 0 && !isPosInt(max2)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max2 ? getUintArray(max2) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max2);
    }
    this.#max = max2;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = new Map;
    this.#keyList = new Array(max2).fill(undefined);
    this.#valList = new Array(max2).fill(undefined);
    this.#next = new UintArray(max2);
    this.#prev = new UintArray(max2);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max2);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = undefined;
      this.#disposed = undefined;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.delete(this.#keyList[index]);
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === undefined) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      const s = starts[index];
      const t = ttls[index];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
  }
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  [Symbol.toStringTag] = "LRUCache";
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      if (fn(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.delete(this.#keyList[i]);
        deleted = true;
      }
    }
    return deleted;
  }
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === undefined)
      return;
    const v = this.#valList[i];
    const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === undefined)
      return;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined || key === undefined)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  set(k, v, setOptions = {}) {
    if (v === undefined) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k);
      return this;
    }
    let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
    if (index === undefined) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== undefined && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== undefined)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== undefined) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = undefined;
      this.#valList[head] = undefined;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index === undefined || !allowStale && this.#isStale(index)) {
      return;
    }
    const v = this.#valList[index];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index, options, context) {
    const v = index === undefined ? undefined : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC;
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== undefined;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index] === p) {
        if (v2 === undefined) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.delete(k);
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === undefined;
        if (del) {
          this.delete(k);
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== undefined) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === undefined ? undefined : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(undefined);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: undefined
    });
    if (index === undefined) {
      this.set(k, bf, { ...fetchOpts.options, status: undefined });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === undefined) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== undefined;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options, context);
      const hasStale = p.__staleWhileFetching !== undefined;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : undefined;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== undefined) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : undefined;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  delete(k) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        deleted = true;
        if (this.#size === 1) {
          this.clear();
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, "delete");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, "delete"]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = undefined;
          this.#valList[index] = undefined;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  clear() {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "delete");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "delete"]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(undefined);
    this.#keyList.fill(undefined);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
}

// data/erc20.json
var erc20_default = [
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_spender",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      },
      {
        name: "_spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    payable: true,
    stateMutability: "payable",
    type: "fallback"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  }
];

// node_modules/@solana/web3.js/lib/index.esm.js
import {Buffer as Buffer2} from "buffer";

// node_modules/@noble/curves/esm/abstract/edwards.js
var validateOpts2 = function(curve3) {
  const opts = validateBasic(curve3);
  validateObject(curve3, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
};
function twistedEdwards(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes3, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n6 << BigInt(nByteLength * 8) - _1n7;
  const modP = Fp2.create;
  const uvRatio = CURVE.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp2.sqrt(u * Fp2.inv(v)) };
    } catch (e) {
      return { isValid: false, value: _0n7 };
    }
  });
  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes7) => bytes7);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  const inBig = (n) => typeof n === "bigint" && _0n7 < n;
  const inRange = (n, max2) => inBig(n) && inBig(max2) && n < max2;
  const in0MaskRange = (n) => n === _0n7 || inRange(n, MASK);
  function assertInRange(n, max2) {
    if (inRange(n, max2))
      return n;
    throw new Error(`Expected valid scalar < ${max2}, got ${typeof n} ${n}`);
  }
  function assertGE0(n) {
    return n === _0n7 ? n : assertInRange(n, CURVE_ORDER);
  }
  const pointPrecomputes = new Map;
  function isPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ExtendedPoint expected");
  }

  class Point2 {
    constructor(ex, ey, ez, et) {
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et;
      if (!in0MaskRange(ex))
        throw new Error("x required");
      if (!in0MaskRange(ey))
        throw new Error("y required");
      if (!in0MaskRange(ez))
        throw new Error("z required");
      if (!in0MaskRange(et))
        throw new Error("t required");
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point2)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      if (!in0MaskRange(x) || !in0MaskRange(y))
        throw new Error("invalid affine point");
      return new Point2(x, y, _1n7, modP(x * y));
    }
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.ez));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    assertValidity() {
      const { a, d } = CURVE;
      if (this.is0())
        throw new Error("bad point: ZERO");
      const { ex: X, ey: Y, ez: Z, et: T } = this;
      const X2 = modP(X * X);
      const Y2 = modP(Y * Y);
      const Z2 = modP(Z * Z);
      const Z4 = modP(Z2 * Z2);
      const aX2 = modP(X2 * a);
      const left = modP(Z2 * modP(aX2 + Y2));
      const right = modP(Z4 + modP(d * modP(X2 * Y2)));
      if (left !== right)
        throw new Error("bad point: equation left != right (1)");
      const XY = modP(X * Y);
      const ZT = modP(Z * T);
      if (XY !== ZT)
        throw new Error("bad point: equation left != right (2)");
    }
    equals(other) {
      isPoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    negate() {
      return new Point2(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n6 * modP(Z1 * Z1));
      const D = modP(a * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G2 = D + B;
      const F = G2 - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point2(X3, Y3, Z3, T3);
    }
    add(other) {
      isPoint(other);
      const { a, d } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T12 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
      if (a === BigInt(-1)) {
        const A2 = modP((Y1 - X1) * (Y2 + X2));
        const B2 = modP((Y1 + X1) * (Y2 - X2));
        const F2 = modP(B2 - A2);
        if (F2 === _0n7)
          return this.double();
        const C2 = modP(Z1 * _2n6 * T2);
        const D2 = modP(T12 * _2n6 * Z2);
        const E2 = D2 + C2;
        const G3 = B2 + A2;
        const H2 = D2 - C2;
        const X32 = modP(E2 * F2);
        const Y32 = modP(G3 * H2);
        const T32 = modP(E2 * H2);
        const Z32 = modP(F2 * G3);
        return new Point2(X32, Y32, Z32, T32);
      }
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T12 * d * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G2 = D + C;
      const H = modP(B - a * A);
      const X3 = modP(E * F);
      const Y3 = modP(G2 * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G2);
      return new Point2(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, Point2.normalizeZ);
    }
    multiply(scalar) {
      const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));
      return Point2.normalizeZ([p, f])[0];
    }
    multiplyUnsafe(scalar) {
      let n = assertGE0(scalar);
      if (n === _0n7)
        return I;
      if (this.equals(I) || n === _1n7)
        return this;
      if (this.equals(G))
        return this.wNAF(n).p;
      return wnaf.unsafeLadder(this, n);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    toAffine(iz) {
      const { ex: x, ey: y, ez: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? _8n2 : Fp2.inv(z2);
      const ax = modP(x * iz);
      const ay = modP(y * iz);
      const zz = modP(z2 * iz);
      if (is0)
        return { x: _0n7, y: _1n7 };
      if (zz !== _1n7)
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n7)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    static fromHex(hex, zip215 = false) {
      const { d, a } = CURVE;
      const len = Fp2.BYTES;
      hex = ensureBytes("pointHex", hex, len);
      const normed = hex.slice();
      const lastByte = hex[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      if (y === _0n7) {
      } else {
        if (zip215)
          assertInRange(y, MASK);
        else
          assertInRange(y, Fp2.ORDER);
      }
      const y2 = modP(y * y);
      const u = modP(y2 - _1n7);
      const v = modP(d * y2 - a);
      let { isValid: isValid2, value: x } = uvRatio(u, v);
      if (!isValid2)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n7) === _1n7;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n7 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point2.fromAffine({ x, y });
    }
    static fromPrivateKey(privKey) {
      return getExtendedPublicKey(privKey).point;
    }
    toRawBytes() {
      const { x, y } = this.toAffine();
      const bytes7 = numberToBytesLE(y, Fp2.BYTES);
      bytes7[bytes7.length - 1] |= x & _1n7 ? 128 : 0;
      return bytes7;
    }
    toHex() {
      return bytesToHex3(this.toRawBytes());
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, _1n7, modP(CURVE.Gx * CURVE.Gy));
  Point2.ZERO = new Point2(_0n7, _1n7, _1n7, _0n7);
  const { BASE: G, ZERO: I } = Point2;
  const wnaf = wNAF(Point2, nByteLength * 8);
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function modN_LE(hash3) {
    return modN(bytesToNumberLE(hash3));
  }
  function getExtendedPublicKey(key) {
    const len = nByteLength;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    const point = G.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = new Uint8Array, ...msgs) {
    const msg = concatBytes2(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign7(msg, privKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = G.multiply(r).toRawBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = modN(r + k * scalar);
    assertGE0(s);
    const res = concatBytes2(R, numberToBytesLE(s, Fp2.BYTES));
    return ensureBytes("result", res, nByteLength * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp2.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const s = bytesToNumberLE(sig.slice(len, 2 * len));
    let A, R, SB;
    try {
      A = Point2.fromHex(publicKey, zip215);
      R = Point2.fromHex(sig.slice(0, len), zip215);
      SB = G.multiplyUnsafe(s);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().equals(Point2.ZERO);
  }
  G._setWindowSize(8);
  const utils64 = {
    getExtendedPublicKey,
    randomPrivateKey: () => randomBytes3(Fp2.BYTES),
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey,
    sign: sign7,
    verify,
    ExtendedPoint: Point2,
    utils: utils64
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
var _2n6 = BigInt(2);
var _8n2 = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };

// node_modules/@noble/curves/esm/ed25519.js
var ed25519_pow_2_252_3 = function(x) {
  const P2 = ED25519_P;
  const x2 = x * x % P2;
  const b2 = x2 * x % P2;
  const b4 = pow2(b2, _2n7, P2) * b2 % P2;
  const b5 = pow2(b4, _1n8, P2) * x % P2;
  const b10 = pow2(b5, _5n2, P2) * b5 % P2;
  const b20 = pow2(b10, _10n, P2) * b10 % P2;
  const b40 = pow2(b20, _20n, P2) * b20 % P2;
  const b80 = pow2(b40, _40n, P2) * b40 % P2;
  const b160 = pow2(b80, _80n, P2) * b80 % P2;
  const b240 = pow2(b160, _80n, P2) * b80 % P2;
  const b250 = pow2(b240, _10n, P2) * b10 % P2;
  const pow_p_5_8 = pow2(b250, _2n7, P2) * x % P2;
  return { pow_p_5_8, b2 };
};
var adjustScalarBytes = function(bytes7) {
  bytes7[0] &= 248;
  bytes7[31] &= 127;
  bytes7[31] |= 64;
  return bytes7;
};
var uvRatio = function(u, v) {
  const P2 = ED25519_P;
  const v3 = mod(v * v * v, P2);
  const v7 = mod(v3 * v3 * v, P2);
  const pow4 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v3 * pow4, P2);
  const vx2 = mod(v * x * x, P2);
  const root1 = x;
  const root2 = mod(x * ED25519_SQRT_M1, P2);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P2);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P2);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P2))
    x = mod(-x, P2);
  return { isValid: useRoot1 || useRoot2, value: x };
};
var ed25519_domain = function(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
var _2n7 = BigInt(2);
var _5n2 = BigInt(5);
var _10n = BigInt(10);
var _20n = BigInt(20);
var _40n = BigInt(40);
var _80n = BigInt(80);
var Fp2 = Field(ED25519_P, undefined, true);
var ed25519Defaults = {
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  Fp: Fp2,
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512,
  randomBytes,
  adjustScalarBytes,
  uvRatio
};
var ed25519 = twistedEdwards(ed25519Defaults);
var ed25519ctx = twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain
});
var ed25519ph = twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain,
  prehash: sha512
});
var ELL2_C1 = (Fp2.ORDER + BigInt(3)) / BigInt(8);
var ELL2_C2 = Fp2.pow(_2n7, ELL2_C1);
var ELL2_C3 = Fp2.sqrt(Fp2.neg(Fp2.ONE));
var ELL2_C4 = (Fp2.ORDER - BigInt(5)) / BigInt(8);
var ELL2_J = BigInt(486662);
var ELL2_C1_EDWARDS = FpSqrtEven(Fp2, Fp2.neg(BigInt(486664)));
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@solana/web3.js/lib/index.esm.js
var import_bn = __toESM(require_bn(), 1);
var import_bs58 = __toESM(require_bs58(), 1);
var import_borsh = __toESM(require_lib2(), 1);
var BufferLayout = __toESM(require_Layout(), 1);
var buffer_layout = __toESM(require_Layout(), 1);
var import_bigint_buffer = __toESM(require_node4(), 1);
import require$$0 from "util";
import require$$0$1 from "http";
import require$$0$2, {Agent as Agent$1} from "https";

// node_modules/superstruct/lib/index.es.js
var isIterable2 = function(x) {
  return isObject2(x) && typeof x[Symbol.iterator] === "function";
};
var isObject2 = function(x) {
  return typeof x === "object" && x != null;
};
var print = function(value) {
  return typeof value === "string" ? JSON.stringify(value) : "" + value;
};
var shiftIterator = function(input) {
  const {
    done,
    value
  } = input.next();
  return done ? undefined : value;
};
var toFailure = function(result, context, struct, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = {
      message: result
    };
  }
  const {
    path,
    branch
  } = context;
  const {
    type
  } = struct;
  const {
    refinement,
    message = "Expected a value of type `" + type + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print(value) + "`"
  } = result;
  return {
    value,
    type,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
};
function* toFailures(result, context, struct, value) {
  if (!isIterable2(result)) {
    result = [result];
  }
  for (const r of result) {
    const failure = toFailure(r, context, struct, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct, options = {}) {
  const {
    path = [],
    branch = [value],
    coerce: coerce2 = false,
    mask: mask2 = false
  } = options;
  const ctx = {
    path,
    branch
  };
  if (coerce2) {
    value = struct.coercer(value, ctx);
    if (mask2 && struct.type !== "type" && isObject2(struct.schema) && isObject2(value) && !Array.isArray(value)) {
      for (const key in value) {
        if (struct.schema[key] === undefined) {
          delete value[key];
        }
      }
    }
  }
  let valid = true;
  for (const failure of struct.validator(value, ctx)) {
    valid = false;
    yield [failure, undefined];
  }
  for (let [k, v, s] of struct.entries(value, ctx)) {
    const ts = run(v, s, {
      path: k === undefined ? path : [...path, k],
      branch: k === undefined ? branch : [...branch, v],
      coerce: coerce2,
      mask: mask2
    });
    for (const t of ts) {
      if (t[0]) {
        valid = false;
        yield [t[0], undefined];
      } else if (coerce2) {
        v = t[1];
        if (k === undefined) {
          value = v;
        } else if (value instanceof Map) {
          value.set(k, v);
        } else if (value instanceof Set) {
          value.add(v);
        } else if (isObject2(value)) {
          value[k] = v;
        }
      }
    }
  }
  if (valid) {
    for (const failure of struct.refiner(value, ctx)) {
      valid = false;
      yield [failure, undefined];
    }
  }
  if (valid) {
    yield [undefined, value];
  }
}
var assert2 = function(value, struct) {
  const result = validate(value, struct);
  if (result[0]) {
    throw result[0];
  }
};
var create2 = function(value, struct) {
  const result = validate(value, struct, {
    coerce: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
};
var mask2 = function(value, struct) {
  const result = validate(value, struct, {
    coerce: true,
    mask: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
};
var is = function(value, struct) {
  const result = validate(value, struct);
  return !result[0];
};
var validate = function(value, struct, options = {}) {
  const tuples = run(value, struct, options);
  const tuple3 = shiftIterator(tuples);
  if (tuple3[0]) {
    const error = new StructError(tuple3[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, undefined];
  } else {
    const v = tuple3[1];
    return [undefined, v];
  }
};
var define2 = function(name, validator3) {
  return new Struct({
    type: name,
    schema: null,
    validator: validator3
  });
};
var any = function() {
  return define2("any", () => true);
};
var array2 = function(Element) {
  return new Struct({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i, v] of value.entries()) {
          yield [i, v, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || "Expected an array value, but received: " + print(value);
    }
  });
};
var boolean3 = function() {
  return define2("boolean", (value) => {
    return typeof value === "boolean";
  });
};
var instance = function(Class) {
  return define2("instance", (value) => {
    return value instanceof Class || "Expected a `" + Class.name + "` instance, but received: " + print(value);
  });
};
var literal = function(constant) {
  const description = print(constant);
  const t = typeof constant;
  return new Struct({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
    validator(value) {
      return value === constant || "Expected the literal `" + description + "`, but received: " + print(value);
    }
  });
};
var never = function() {
  return define2("never", () => false);
};
var nullable = function(struct) {
  return new Struct({
    ...struct,
    validator: (value, ctx) => value === null || struct.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)
  });
};
var number8 = function() {
  return define2("number", (value) => {
    return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print(value);
  });
};
var optional = function(struct) {
  return new Struct({
    ...struct,
    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)
  });
};
var record = function(Key, Value) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject2(value)) {
        for (const k in value) {
          const v = value[k];
          yield [k, k, Key];
          yield [k, v, Value];
        }
      }
    },
    validator(value) {
      return isObject2(value) || "Expected an object, but received: " + print(value);
    }
  });
};
var string10 = function() {
  return define2("string", (value) => {
    return typeof value === "string" || "Expected a string, but received: " + print(value);
  });
};
var tuple3 = function(Elements) {
  const Never = never();
  return new Struct({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length = Math.max(Elements.length, value.length);
        for (let i = 0;i < length; i++) {
          yield [i, value[i], Elements[i] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || "Expected an array, but received: " + print(value);
    }
  });
};
var type = function(schema) {
  const keys = Object.keys(schema);
  return new Struct({
    type: "type",
    schema,
    *entries(value) {
      if (isObject2(value)) {
        for (const k of keys) {
          yield [k, value[k], schema[k]];
        }
      }
    },
    validator(value) {
      return isObject2(value) || "Expected an object, but received: " + print(value);
    }
  });
};
var union = function(Structs) {
  const description = Structs.map((s) => s.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    validator(value, ctx) {
      const failures = [];
      for (const S of Structs) {
        const [...tuples] = run(value, S, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value), ...failures];
    }
  });
};
var unknown = function() {
  return define2("unknown", () => true);
};
var coerce2 = function(struct, condition, coercer) {
  return new Struct({
    ...struct,
    coercer: (value, ctx) => {
      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
    }
  });
};
class StructError extends TypeError {
  constructor(failure, failures) {
    let cached;
    const {
      message,
      ...rest
    } = failure;
    const {
      path
    } = failure;
    const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
    super(msg);
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      var _cached;
      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
    };
  }
}

class Struct {
  constructor(props) {
    const {
      type: type2,
      schema,
      validator: validator3,
      refiner,
      coercer = (value) => value,
      entries = function* () {
      }
    } = props;
    this.type = type2;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator3) {
      this.validator = (value, context) => {
        const result = validator3(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  assert(value) {
    return assert2(value, this);
  }
  create(value) {
    return create2(value, this);
  }
  is(value) {
    return is(value, this);
  }
  mask(value) {
    return mask2(value, this);
  }
  validate(value, options = {}) {
    return validate(value, this, options);
  }
}

// node_modules/@solana/web3.js/lib/index.esm.js
var browser = __toESM(require_browser2(), 1);
var client2 = __toESM(require_client3(), 1);
var websocket = __toESM(require_websocket(), 1);
import * as nodeFetch from "node-fetch";
var isOnCurve = function(publicKey) {
  try {
    ed25519.ExtendedPoint.fromHex(publicKey);
    return true;
  } catch {
    return false;
  }
};
var isPublicKeyData = function(value) {
  return value._bn !== undefined;
};
var getAlloc = function(type2, fields) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc({
        layout: item
      }, fields[item.property]);
    }
    return 0;
  };
  let alloc2 = 0;
  type2.layout.fields.forEach((item) => {
    alloc2 += getItemAlloc(item);
  });
  return alloc2;
};
var decodeLength = function(bytes7) {
  let len = 0;
  let size = 0;
  for (;; ) {
    let elem = bytes7.shift();
    len |= (elem & 127) << size * 7;
    size += 1;
    if ((elem & 128) === 0) {
      break;
    }
  }
  return len;
};
var encodeLength = function(bytes7, len) {
  let rem_len = len;
  for (;; ) {
    let elem = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes7.push(elem);
      break;
    } else {
      elem |= 128;
      bytes7.push(elem);
    }
  }
};
var assert3 = function(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
};
async function sendAndConfirmTransaction(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      signature,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature
    }, options && options.commitment)).value;
  } else {
    if (options?.abortSignal != null) {
      console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
    }
    status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
  }
  if (status.err) {
    throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
  }
  return signature;
}
var sleep = function(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
};
var encodeData = function(type2, fields) {
  const allocLength = type2.layout.span >= 0 ? type2.layout.span : getAlloc(type2, fields);
  const data = Buffer2.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type2.index
  }, fields);
  type2.layout.encode(layoutFields, data);
  return data;
};
var parse = function(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type2 = (match[2] || "ms").toLowerCase();
  switch (type2) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return;
  }
};
var fmtShort = function(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + "s";
  }
  return ms + "ms";
};
var fmtLong = function(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, "day");
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, "minute");
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, "second");
  }
  return ms + " ms";
};
var plural = function(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
};
var deprecate = function(message) {
  console.log("[agentkeepalive:deprecated] %s", message);
};
var getSocketTimeout = function(socket) {
  return socket.timeout || socket._idleTimeout;
};
var installListeners = function(agent, socket, options) {
  debug("%s create, timeout %sms", socket[SOCKET_NAME], getSocketTimeout(socket));
  function onFree() {
    if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1)
      return;
    socket[SOCKET_REQUEST_FINISHED_COUNT]++;
    agent.requestCount++;
    debug("%s(requests: %s, finished: %s) free", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
    const name = agent.getName(options);
    if (socket.writable && agent.requests[name] && agent.requests[name].length) {
      socket[SOCKET_REQUEST_COUNT]++;
      debug("%s(requests: %s, finished: %s) will be reuse on agent free event", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
    }
  }
  socket.on("free", onFree);
  function onClose(isError) {
    debug("%s(requests: %s, finished: %s) close, isError: %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);
    agent.closeSocketCount++;
  }
  socket.on("close", onClose);
  function onTimeout() {
    const listenerCount = socket.listeners("timeout").length;
    const timeout = getSocketTimeout(socket);
    const req = socket._httpMessage;
    const reqTimeoutListenerCount = req && req.listeners("timeout").length || 0;
    debug("%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);
    if (debug.enabled) {
      debug("timeout listeners: %s", socket.listeners("timeout").map((f) => f.name).join(", "));
    }
    agent.timeoutSocketCount++;
    const name = agent.getName(options);
    if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {
      socket.destroy();
      agent.removeSocket(socket, options);
      debug("%s is free, destroy quietly", socket[SOCKET_NAME]);
    } else {
      if (reqTimeoutListenerCount === 0) {
        const error = new Error("Socket timeout");
        error.code = "ERR_SOCKET_TIMEOUT";
        error.timeout = timeout;
        socket.destroy(error);
        agent.removeSocket(socket, options);
        debug("%s destroy with timeout error", socket[SOCKET_NAME]);
      }
    }
  }
  socket.on("timeout", onTimeout);
  function onError(err) {
    const listenerCount = socket.listeners("error").length;
    debug("%s(requests: %s, finished: %s) error: %s, listenerCount: %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);
    agent.errorSocketCount++;
    if (listenerCount === 1) {
      debug("%s emit uncaught error event", socket[SOCKET_NAME]);
      socket.removeListener("error", onError);
      socket.emit("error", err);
    }
  }
  socket.on("error", onError);
  function onRemove() {
    debug("%s(requests: %s, finished: %s) agentRemove", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
    socket.removeListener("close", onClose);
    socket.removeListener("error", onError);
    socket.removeListener("free", onFree);
    socket.removeListener("timeout", onTimeout);
    socket.removeListener("agentRemove", onRemove);
  }
  socket.on("agentRemove", onRemove);
};
var inspect = function(obj) {
  const res = {};
  for (const key in obj) {
    res[key] = obj[key].length;
  }
  return res;
};
var createRpcResult = function(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string10(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string10(),
    error: type({
      code: unknown(),
      message: string10(),
      data: optional(any())
    })
  })]);
};
var jsonRpcResult = function(schema) {
  return coerce2(createRpcResult(schema), UnknownRpcResult, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create2(value.result, schema)
      };
    }
  });
};
var jsonRpcResultAndContext = function(value) {
  return jsonRpcResult(type({
    context: type({
      slot: number8()
    }),
    value
  }));
};
var notificationResultAndContext = function(value) {
  return type({
    context: type({
      slot: number8()
    }),
    value
  });
};
var generatePrivateKey = ed25519.utils.randomPrivateKey;
var generateKeypair = () => {
  const privateScalar = ed25519.utils.randomPrivateKey();
  const publicKey = getPublicKey(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey, 32);
  return {
    publicKey,
    secretKey
  };
};
var getPublicKey = ed25519.getPublicKey;
var sign7 = (message, secretKey) => ed25519.sign(message, secretKey.slice(0, 32));
var verify = ed25519.verify;
var toBuffer = (arr) => {
  if (Buffer2.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return Buffer2.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return Buffer2.from(arr);
  }
};

class Struct2 {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return Buffer2.from(import_borsh.serialize(SOLANA_SCHEMA, this));
  }
  static decode(data) {
    return import_borsh.deserialize(SOLANA_SCHEMA, this, data);
  }
  static decodeUnchecked(data) {
    return import_borsh.deserializeUnchecked(SOLANA_SCHEMA, this, data);
  }
}
var SOLANA_SCHEMA = new Map;
var _class;
var _Symbol$toStringTag;
var MAX_SEED_LENGTH = 32;
var PUBLIC_KEY_LENGTH = 32;
var uniquePublicKeyCounter = 1;
_Symbol$toStringTag = Symbol.toStringTag;

class PublicKey extends Struct2 {
  constructor(value) {
    super({});
    this._bn = undefined;
    if (isPublicKeyData(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = import_bs58.default.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new import_bn.default(decoded);
      } else {
        this._bn = new import_bn.default(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  static unique() {
    const key = new PublicKey(uniquePublicKeyCounter);
    uniquePublicKeyCounter += 1;
    return new PublicKey(key.toBuffer());
  }
  equals(publicKey) {
    return this._bn.eq(publicKey._bn);
  }
  toBase58() {
    return import_bs58.default.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  toBuffer() {
    const b = this._bn.toArrayLike(Buffer2);
    if (b.length === PUBLIC_KEY_LENGTH) {
      return b;
    }
    const zeroPad = Buffer2.alloc(32);
    b.copy(zeroPad, 32 - b.length);
    return zeroPad;
  }
  get [_Symbol$toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer = Buffer2.concat([fromPublicKey.toBuffer(), Buffer2.from(seed), programId.toBuffer()]);
    const publicKeyBytes = sha256(buffer);
    return new PublicKey(publicKeyBytes);
  }
  static createProgramAddressSync(seeds, programId) {
    let buffer = Buffer2.alloc(0);
    seeds.forEach(function(seed) {
      if (seed.length > MAX_SEED_LENGTH) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer = Buffer2.concat([buffer, toBuffer(seed)]);
    });
    buffer = Buffer2.concat([buffer, programId.toBuffer(), Buffer2.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha256(buffer);
    if (isOnCurve(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new PublicKey(publicKeyBytes);
  }
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address7;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(Buffer2.from([nonce]));
        address7 = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address7, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  static isOnCurve(pubkeyData) {
    const pubkey = new PublicKey(pubkeyData);
    return isOnCurve(pubkey.toBytes());
  }
}
_class = PublicKey;
PublicKey.default = new _class("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111");
var PACKET_DATA_SIZE = 1280 - 40 - 8;
var VERSION_PREFIX_MASK = 127;
var SIGNATURE_LENGTH_IN_BYTES = 64;

class TransactionExpiredBlockheightExceededError extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: block height exceeded.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});

class TransactionExpiredTimeoutError extends Error {
  constructor(signature, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + "unknown if it succeeded or failed. Check signature " + `${signature} using the Solana Explorer or CLI tools.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});

class TransactionExpiredNonceInvalidError extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: the nonce is no longer valid.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});

class MessageAccountKeys {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = undefined;
    this.accountKeysFromLookups = undefined;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = new Map;
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === undefined)
        throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
}
var publicKey = (property = "publicKey") => {
  return BufferLayout.blob(32, property);
};
var rustString = (property = "string") => {
  const rsl = BufferLayout.struct([BufferLayout.u32("length"), BufferLayout.u32("lengthPadding"), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), "chars")], property);
  const _decode = rsl.decode.bind(rsl);
  const _encode = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b, offset2) => {
    const data = _decode(b, offset2);
    return data["chars"].toString();
  };
  rslShim.encode = (str, b, offset2) => {
    const data = {
      chars: Buffer2.from(str, "utf8")
    };
    return _encode(data, b, offset2);
  };
  rslShim.alloc = (str) => {
    return BufferLayout.u32().span + BufferLayout.u32().span + Buffer2.from(str, "utf8").length;
  };
  return rslShim;
};
var authorized = (property = "authorized") => {
  return BufferLayout.struct([publicKey("staker"), publicKey("withdrawer")], property);
};
var lockup = (property = "lockup") => {
  return BufferLayout.struct([BufferLayout.ns64("unixTimestamp"), BufferLayout.ns64("epoch"), publicKey("custodian")], property);
};
var voteInit = (property = "voteInit") => {
  return BufferLayout.struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), BufferLayout.u8("commission")], property);
};
var voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
  return BufferLayout.struct([BufferLayout.u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], property);
};

class CompiledKeys {
  constructor(payer, keyMetaMap) {
    this.payer = undefined;
    this.keyMetaMap = undefined;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = new Map;
    const getOrInsertDefault = (pubkey) => {
      const address7 = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address7);
      if (keyMeta === undefined) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address7, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner ||= accountMeta.isSigner;
        keyMeta.isWritable ||= accountMeta.isWritable;
      }
    }
    return new CompiledKeys(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert3(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert3(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert3(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address7]) => new PublicKey(address7)), ...readonlySigners.map(([address7]) => new PublicKey(address7)), ...writableNonSigners.map(([address7]) => new PublicKey(address7)), ...readonlyNonSigners.map(([address7]) => new PublicKey(address7))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array;
    const drainedKeys = new Array;
    for (const [address7, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey(address7);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert3(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address7);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
}

class Message {
  constructor(args) {
    this.header = undefined;
    this.accountKeys = undefined;
    this.recentBlockhash = undefined;
    this.instructions = undefined;
    this.indexToProgramIds = new Map;
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account2) => new PublicKey(account2));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: import_bs58.default.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: import_bs58.default.encode(ix.data)
    }));
    return new Message({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts: accounts2,
        programIdIndex
      } = instruction;
      const data = Array.from(import_bs58.default.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength(keyIndicesCount, accounts2.length);
      let dataCount = [];
      encodeLength(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: Buffer2.from(keyIndicesCount),
        keyIndices: accounts2,
        dataLength: Buffer2.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength(instructionCount, instructions.length);
    let instructionBuffer = Buffer2.alloc(PACKET_DATA_SIZE);
    Buffer2.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout.seq(BufferLayout.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout.blob(instruction.dataLength.length, "dataLength"), BufferLayout.seq(BufferLayout.u8("userdatum"), instruction.data.length, "data")]);
      const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length2;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout.struct([BufferLayout.blob(1, "numRequiredSignatures"), BufferLayout.blob(1, "numReadonlySignedAccounts"), BufferLayout.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout.blob(keyCount.length, "keyCount"), BufferLayout.seq(publicKey("key"), numKeys, "keys"), publicKey("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: Buffer2.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: Buffer2.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: Buffer2.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: Buffer2.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
      recentBlockhash: import_bs58.default.decode(this.recentBlockhash)
    };
    let signData = Buffer2.alloc(2048);
    const length = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }
  static from(buffer) {
    let byteArray = [...buffer];
    const numRequiredSignatures = byteArray.shift();
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = byteArray.shift();
    const numReadonlyUnsignedAccounts = byteArray.shift();
    const accountCount = decodeLength(byteArray);
    let accountKeys = [];
    for (let i = 0;i < accountCount; i++) {
      const account2 = byteArray.splice(0, PUBLIC_KEY_LENGTH);
      accountKeys.push(new PublicKey(Buffer2.from(account2)));
    }
    const recentBlockhash = byteArray.splice(0, PUBLIC_KEY_LENGTH);
    const instructionCount = decodeLength(byteArray);
    let instructions = [];
    for (let i = 0;i < instructionCount; i++) {
      const programIdIndex = byteArray.shift();
      const accountCount2 = decodeLength(byteArray);
      const accounts2 = byteArray.splice(0, accountCount2);
      const dataLength = decodeLength(byteArray);
      const dataSlice = byteArray.splice(0, dataLength);
      const data = import_bs58.default.encode(Buffer2.from(dataSlice));
      instructions.push({
        programIdIndex,
        accounts: accounts2,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: import_bs58.default.encode(Buffer2.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new Message(messageArgs);
  }
}
var DEFAULT_SIGNATURE = Buffer2.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);

class TransactionInstruction {
  constructor(opts) {
    this.keys = undefined;
    this.programId = undefined;
    this.data = Buffer2.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}

class Transaction2 {
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  constructor(opts) {
    this.signatures = [];
    this.feePayer = undefined;
    this.instructions = [];
    this.recentBlockhash = undefined;
    this.lastValidBlockHeight = undefined;
    this.nonceInfo = undefined;
    this.minNonceContextSlot = undefined;
    this._message = undefined;
    this._json = undefined;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey2
      }) => {
        return publicKey2.toJSON();
      })
    };
  }
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction(item));
      }
    });
    return this;
  }
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i = 0;i < instructions.length; i++) {
      if (instructions[i].programId === undefined) {
        throw new Error(`Transaction instruction index ${i} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x) => {
        return x.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x, y) {
      if (x.isSigner !== y.isSigner) {
        return x.isSigner ? -1 : 1;
      }
      if (x.isWritable !== y.isWritable) {
        return x.isWritable ? -1 : 1;
      }
      const options = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: false,
        numeric: false,
        caseFirst: "lower"
      };
      return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", options);
    });
    const feePayerIndex = uniqueMetas.findIndex((x) => {
      return x.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x) => {
        return x.pubkey.equals(signature.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: import_bs58.default.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert3(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert3(keyIndex >= 0));
    });
    return new Message({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid)
        return message;
    }
    this.signatures = signedKeys.map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
    return message;
  }
  serializeMessage() {
    return this._compile().serialize();
  }
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    this.signatures = signers.filter((publicKey2) => {
      const key = publicKey2.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
  }
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach((signer) => {
      const signature = sign7(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer(signature));
    });
  }
  addSignature(pubkey, signature) {
    this._compile();
    this._addSignature(pubkey, signature);
  }
  _addSignature(pubkey, signature) {
    assert3(signature.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = Buffer2.from(signature);
  }
  verifySignatures(requireAllSignatures = true) {
    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
    return !signatureErrors;
  }
  _getMessageSignednessErrors(message, requireAllSignatures) {
    const errors5 = {};
    for (const {
      signature,
      publicKey: publicKey2
    } of this.signatures) {
      if (signature === null) {
        if (requireAllSignatures) {
          (errors5.missing ||= []).push(publicKey2);
        }
      } else {
        if (!verify(signature, message, publicKey2.toBytes())) {
          (errors5.invalid ||= []).push(publicKey2);
        }
      }
    }
    return errors5.invalid || errors5.missing ? errors5 : undefined;
  }
  serialize(config7) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config7);
    const signData = this.serializeMessage();
    if (verifySignatures) {
      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
      if (sigErrors) {
        let errorMessage = "Signature verification failed.";
        if (sigErrors.invalid) {
          errorMessage += `\nInvalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        if (sigErrors.missing) {
          errorMessage += `\nMissing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        throw new Error(errorMessage);
      }
    }
    return this._serialize(signData);
  }
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = Buffer2.alloc(transactionLength);
    assert3(signatures.length < 256);
    Buffer2.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature
    }, index) => {
      if (signature !== null) {
        assert3(signature.length === 64, `signature has invalid length`);
        Buffer2.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert3(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
    return wireTransaction;
  }
  get keys() {
    assert3(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  get programId() {
    assert3(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  get data() {
    assert3(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  static from(buffer) {
    let byteArray = [...buffer];
    const signatureCount = decodeLength(byteArray);
    let signatures = [];
    for (let i = 0;i < signatureCount; i++) {
      const signature = byteArray.splice(0, SIGNATURE_LENGTH_IN_BYTES);
      signatures.push(import_bs58.default.encode(Buffer2.from(signature)));
    }
    return Transaction2.populate(Message.from(byteArray), signatures);
  }
  static populate(message, signatures = []) {
    const transaction = new Transaction2;
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature, index) => {
      const sigPubkeyPair = {
        signature: signature == import_bs58.default.encode(DEFAULT_SIGNATURE) ? null : import_bs58.default.decode(signature),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach((instruction) => {
      const keys = instruction.accounts.map((account2) => {
        const pubkey = message.accountKeys[account2];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account2),
          isWritable: message.isAccountWritable(account2)
        };
      });
      transaction.instructions.push(new TransactionInstruction({
        keys,
        programId: message.accountKeys[instruction.programIdIndex],
        data: import_bs58.default.decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }
}
var NUM_TICKS_PER_SECOND = 160;
var DEFAULT_TICKS_PER_SLOT = 64;
var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
var MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;
var SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111");
var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111");
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
var SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
var SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111");
var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111");
var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111");
var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
var FeeCalculatorLayout = BufferLayout.nu64("lamportsPerSignature");
var NonceAccountLayout = BufferLayout.struct([BufferLayout.u32("version"), BufferLayout.u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), BufferLayout.struct([FeeCalculatorLayout], "feeCalculator")]);
var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
var encodeDecode = (layout) => {
  const decode2 = layout.decode.bind(layout);
  const encode3 = layout.encode.bind(layout);
  return {
    decode: decode2,
    encode: encode3
  };
};
var bigInt = (length) => (property) => {
  const layout = buffer_layout.blob(length, property);
  const {
    encode: encode3,
    decode: decode2
  } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset2) => {
    const src = decode2(buffer, offset2);
    return import_bigint_buffer.toBigIntLE(Buffer2.from(src));
  };
  bigIntLayout.encode = (bigInt2, buffer, offset2) => {
    const src = import_bigint_buffer.toBufferLE(bigInt2, length);
    return encode3(src, buffer, offset2);
  };
  return bigIntLayout;
};
var u642 = bigInt(8);
var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("lamports"), rustString("seed"), publicKey("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  }
});

class SystemProgram {
  constructor() {
  }
  static createAccount(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Create;
    const data = encodeData(type2, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  static transfer(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      data = encodeData(type2, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      data = encodeData(type2, {
        lamports: BigInt(params.lamports)
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  static assign(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      data = encodeData(type2, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      data = encodeData(type2, {
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  static createAccountWithSeed(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
    const data = encodeData(type2, {
      base: toBuffer(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    let keys = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (params.basePubkey != params.fromPubkey) {
      keys.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  static createNonceAccount(params) {
    const transaction = new Transaction2;
    if ("basePubkey" in params && "seed" in params) {
      transaction.add(SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    } else {
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  static nonceInitialize(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
    const data = encodeData(type2, {
      authorized: toBuffer(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static nonceAdvance(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
    const data = encodeData(type2);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static nonceWithdraw(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
    const data = encodeData(type2, {
      lamports: params.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static nonceAuthorize(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
    const data = encodeData(type2, {
      authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static allocate(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      data = encodeData(type2, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      data = encodeData(type2, {
        space: params.space
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
}
SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
var CHUNK_SIZE = PACKET_DATA_SIZE - 300;

class Loader {
  constructor() {
  }
  static getMinNumSignatures(dataLength) {
    return 2 * (Math.ceil(dataLength / Loader.chunkSize) + 1 + 1);
  }
  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
      const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
      let transaction = null;
      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error("Program load failed, account is already executable");
          return false;
        }
        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction2;
          transaction.add(SystemProgram.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }
        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction2;
          transaction.add(SystemProgram.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }
        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction2;
          transaction.add(SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction2().add(SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      }
      if (transaction !== null) {
        await sendAndConfirmTransaction(connection, transaction, [payer, program], {
          commitment: "confirmed"
        });
      }
    }
    const dataLayout = BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.u32("offset"), BufferLayout.u32("bytesLength"), BufferLayout.u32("bytesLengthPadding"), BufferLayout.seq(BufferLayout.u8("byte"), BufferLayout.offset(BufferLayout.u32(), -8), "bytes")]);
    const chunkSize = Loader.chunkSize;
    let offset2 = 0;
    let array3 = data;
    let transactions = [];
    while (array3.length > 0) {
      const bytes7 = array3.slice(0, chunkSize);
      const data2 = Buffer2.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        offset: offset2,
        bytes: bytes7,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, data2);
      const transaction = new Transaction2().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data: data2
      });
      transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
        commitment: "confirmed"
      }));
      if (connection._rpcEndpoint.includes("solana.com")) {
        const REQUESTS_PER_SECOND = 4;
        await sleep(1000 / REQUESTS_PER_SECOND);
      }
      offset2 += chunkSize;
      array3 = array3.slice(chunkSize);
    }
    await Promise.all(transactions);
    {
      const dataLayout2 = BufferLayout.struct([BufferLayout.u32("instruction")]);
      const data2 = Buffer2.alloc(dataLayout2.span);
      dataLayout2.encode({
        instruction: 1
      }, data2);
      const transaction = new Transaction2().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data: data2
      });
      const deployCommitment = "processed";
      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
        preflightCommitment: deployCommitment
      });
      const {
        context,
        value
      } = await connection.confirmTransaction({
        signature: finalizeSignature,
        lastValidBlockHeight: transaction.lastValidBlockHeight,
        blockhash: transaction.recentBlockhash
      }, deployCommitment);
      if (value.err) {
        throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
      }
      while (true) {
        try {
          const currentSlot = await connection.getSlot({
            commitment: deployCommitment
          });
          if (currentSlot > context.slot) {
            break;
          }
        } catch {
        }
        await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));
      }
    }
    return true;
  }
}
Loader.chunkSize = CHUNK_SIZE;
var BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
var agentkeepalive = { exports: {} };
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
var ms$2 = function(val, options) {
  options = options || {};
  var type2 = typeof val;
  if (type2 === "string" && val.length > 0) {
    return parse(val);
  } else if (type2 === "number" && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
/*!
 * humanize-ms - index.js
 * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
 * MIT Licensed
 */
var util2 = require$$0;
var ms$1 = ms$2;
var humanizeMs = function(t) {
  if (typeof t === "number")
    return t;
  var r = ms$1(t);
  if (r === undefined) {
    var err = new Error(util2.format("humanize-ms(%j) result undefined", t));
    console.warn(err.stack);
  }
  return r;
};
var constants16 = {
  CURRENT_ID: Symbol("agentkeepalive#currentId"),
  CREATE_ID: Symbol("agentkeepalive#createId"),
  INIT_SOCKET: Symbol("agentkeepalive#initSocket"),
  CREATE_HTTPS_CONNECTION: Symbol("agentkeepalive#createHttpsConnection"),
  SOCKET_CREATED_TIME: Symbol("agentkeepalive#socketCreatedTime"),
  SOCKET_NAME: Symbol("agentkeepalive#socketName"),
  SOCKET_REQUEST_COUNT: Symbol("agentkeepalive#socketRequestCount"),
  SOCKET_REQUEST_FINISHED_COUNT: Symbol("agentkeepalive#socketRequestFinishedCount")
};
var OriginalAgent = require$$0$1.Agent;
var ms = humanizeMs;
var debug = require$$0.debuglog("agentkeepalive");
var {
  INIT_SOCKET: INIT_SOCKET$1,
  CURRENT_ID,
  CREATE_ID,
  SOCKET_CREATED_TIME,
  SOCKET_NAME,
  SOCKET_REQUEST_COUNT,
  SOCKET_REQUEST_FINISHED_COUNT
} = constants16;
var defaultTimeoutListenerCount = 1;
var majorVersion = parseInt(process.version.split(".", 1)[0].substring(1));
if (majorVersion >= 11 && majorVersion <= 12) {
  defaultTimeoutListenerCount = 2;
} else if (majorVersion >= 13) {
  defaultTimeoutListenerCount = 3;
}

class Agent extends OriginalAgent {
  constructor(options) {
    options = options || {};
    options.keepAlive = options.keepAlive !== false;
    if (options.freeSocketTimeout === undefined) {
      options.freeSocketTimeout = 4000;
    }
    if (options.keepAliveTimeout) {
      deprecate("options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
      options.freeSocketTimeout = options.keepAliveTimeout;
      delete options.keepAliveTimeout;
    }
    if (options.freeSocketKeepAliveTimeout) {
      deprecate("options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
      options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;
      delete options.freeSocketKeepAliveTimeout;
    }
    if (options.timeout === undefined) {
      options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);
    }
    options.timeout = ms(options.timeout);
    options.freeSocketTimeout = ms(options.freeSocketTimeout);
    options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;
    super(options);
    this[CURRENT_ID] = 0;
    this.createSocketCount = 0;
    this.createSocketCountLastCheck = 0;
    this.createSocketErrorCount = 0;
    this.createSocketErrorCountLastCheck = 0;
    this.closeSocketCount = 0;
    this.closeSocketCountLastCheck = 0;
    this.errorSocketCount = 0;
    this.errorSocketCountLastCheck = 0;
    this.requestCount = 0;
    this.requestCountLastCheck = 0;
    this.timeoutSocketCount = 0;
    this.timeoutSocketCountLastCheck = 0;
    this.on("free", (socket) => {
      const timeout = this.calcSocketTimeout(socket);
      if (timeout > 0 && socket.timeout !== timeout) {
        socket.setTimeout(timeout);
      }
    });
  }
  get freeSocketKeepAliveTimeout() {
    deprecate("agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead");
    return this.options.freeSocketTimeout;
  }
  get timeout() {
    deprecate("agent.timeout is deprecated, please use agent.options.timeout instead");
    return this.options.timeout;
  }
  get socketActiveTTL() {
    deprecate("agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead");
    return this.options.socketActiveTTL;
  }
  calcSocketTimeout(socket) {
    let freeSocketTimeout = this.options.freeSocketTimeout;
    const socketActiveTTL = this.options.socketActiveTTL;
    if (socketActiveTTL) {
      const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];
      const diff = socketActiveTTL - aliveTime;
      if (diff <= 0) {
        return diff;
      }
      if (freeSocketTimeout && diff < freeSocketTimeout) {
        freeSocketTimeout = diff;
      }
    }
    if (freeSocketTimeout) {
      const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;
      return customFreeSocketTimeout || freeSocketTimeout;
    }
  }
  keepSocketAlive(socket) {
    const result = super.keepSocketAlive(socket);
    if (!result)
      return result;
    const customTimeout = this.calcSocketTimeout(socket);
    if (typeof customTimeout === "undefined") {
      return true;
    }
    if (customTimeout <= 0) {
      debug("%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);
      return false;
    }
    if (socket.timeout !== customTimeout) {
      socket.setTimeout(customTimeout);
    }
    return true;
  }
  reuseSocket(...args) {
    super.reuseSocket(...args);
    const socket = args[0];
    const req = args[1];
    req.reusedSocket = true;
    const agentTimeout = this.options.timeout;
    if (getSocketTimeout(socket) !== agentTimeout) {
      socket.setTimeout(agentTimeout);
      debug("%s reset timeout to %sms", socket[SOCKET_NAME], agentTimeout);
    }
    socket[SOCKET_REQUEST_COUNT]++;
    debug("%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));
  }
  [CREATE_ID]() {
    const id = this[CURRENT_ID]++;
    if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER)
      this[CURRENT_ID] = 0;
    return id;
  }
  [INIT_SOCKET$1](socket, options) {
    if (options.timeout) {
      const timeout = getSocketTimeout(socket);
      if (!timeout) {
        socket.setTimeout(options.timeout);
      }
    }
    if (this.options.keepAlive) {
      socket.setNoDelay(true);
    }
    this.createSocketCount++;
    if (this.options.socketActiveTTL) {
      socket[SOCKET_CREATED_TIME] = Date.now();
    }
    socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split("-----BEGIN", 1)[0];
    socket[SOCKET_REQUEST_COUNT] = 1;
    socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;
    installListeners(this, socket, options);
  }
  createConnection(options, oncreate) {
    let called = false;
    const onNewCreate = (err, socket) => {
      if (called)
        return;
      called = true;
      if (err) {
        this.createSocketErrorCount++;
        return oncreate(err);
      }
      this[INIT_SOCKET$1](socket, options);
      oncreate(err, socket);
    };
    const newSocket = super.createConnection(options, onNewCreate);
    if (newSocket)
      onNewCreate(null, newSocket);
    return newSocket;
  }
  get statusChanged() {
    const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;
    if (changed) {
      this.createSocketCountLastCheck = this.createSocketCount;
      this.createSocketErrorCountLastCheck = this.createSocketErrorCount;
      this.closeSocketCountLastCheck = this.closeSocketCount;
      this.errorSocketCountLastCheck = this.errorSocketCount;
      this.timeoutSocketCountLastCheck = this.timeoutSocketCount;
      this.requestCountLastCheck = this.requestCount;
    }
    return changed;
  }
  getCurrentStatus() {
    return {
      createSocketCount: this.createSocketCount,
      createSocketErrorCount: this.createSocketErrorCount,
      closeSocketCount: this.closeSocketCount,
      errorSocketCount: this.errorSocketCount,
      timeoutSocketCount: this.timeoutSocketCount,
      requestCount: this.requestCount,
      freeSockets: inspect(this.freeSockets),
      sockets: inspect(this.sockets),
      requests: inspect(this.requests)
    };
  }
}
var agent = Agent;
var OriginalHttpsAgent = require$$0$2.Agent;
var HttpAgent = agent;
var {
  INIT_SOCKET,
  CREATE_HTTPS_CONNECTION
} = constants16;
var HttpsAgent$1 = class HttpsAgent extends HttpAgent {
  constructor(options) {
    super(options);
    this.defaultPort = 443;
    this.protocol = "https:";
    this.maxCachedSessions = this.options.maxCachedSessions;
    if (this.maxCachedSessions === undefined) {
      this.maxCachedSessions = 100;
    }
    this._sessionCache = {
      map: {},
      list: []
    };
  }
  createConnection(options, oncreate) {
    const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);
    this[INIT_SOCKET](socket, options);
    return socket;
  }
};
HttpsAgent$1.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;
[
  "getName",
  "_getSession",
  "_cacheSession",
  "_evictSession"
].forEach(function(method) {
  if (typeof OriginalHttpsAgent.prototype[method] === "function") {
    HttpsAgent$1.prototype[method] = OriginalHttpsAgent.prototype[method];
  }
});
var https_agent = HttpsAgent$1;
agentkeepalive.exports = agent;
var HttpsAgent2 = agentkeepalive.exports.HttpsAgent = https_agent;
agentkeepalive.exports.constants = constants16;
var agentkeepaliveExports = agentkeepalive.exports;
var fetchImpl = typeof globalThis.fetch === "function" ? globalThis.fetch : async function(input, init2) {
  const processedInput = typeof input === "string" && input.slice(0, 2) === "//" ? "https:" + input : input;
  return await nodeFetch.default(processedInput, init2);
};
var LookupTableMetaLayout = {
  index: 1,
  layout: BufferLayout.struct([
    BufferLayout.u32("typeIndex"),
    u642("deactivationSlot"),
    BufferLayout.nu64("lastExtendedSlot"),
    BufferLayout.u8("lastExtendedStartIndex"),
    BufferLayout.u8(),
    BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u8(), -1), "authority")
  ])
};
var PublicKeyFromString = coerce2(instance(PublicKey), string10(), (value) => new PublicKey(value));
var RawAccountDataResult = tuple3([string10(), literal("base64")]);
var BufferFromRawAccountData = coerce2(instance(Buffer2), RawAccountDataResult, (value) => Buffer2.from(value[0], "base64"));
var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;
var UnknownRpcResult = createRpcResult(unknown());
var GetInflationGovernorResult = type({
  foundation: number8(),
  foundationTerm: number8(),
  initial: number8(),
  taper: number8(),
  terminal: number8()
});
var GetInflationRewardResult = jsonRpcResult(array2(nullable(type({
  epoch: number8(),
  effectiveSlot: number8(),
  amount: number8(),
  postBalance: number8(),
  commission: optional(nullable(number8()))
}))));
var GetRecentPrioritizationFeesResult = array2(type({
  slot: number8(),
  prioritizationFee: number8()
}));
var GetInflationRateResult = type({
  total: number8(),
  validator: number8(),
  foundation: number8(),
  epoch: number8()
});
var GetEpochInfoResult = type({
  epoch: number8(),
  slotIndex: number8(),
  slotsInEpoch: number8(),
  absoluteSlot: number8(),
  blockHeight: optional(number8()),
  transactionCount: optional(number8())
});
var GetEpochScheduleResult = type({
  slotsPerEpoch: number8(),
  leaderScheduleSlotOffset: number8(),
  warmup: boolean3(),
  firstNormalEpoch: number8(),
  firstNormalSlot: number8()
});
var GetLeaderScheduleResult = record(string10(), array2(number8()));
var TransactionErrorResult = nullable(union([type({}), string10()]));
var SignatureStatusResult = type({
  err: TransactionErrorResult
});
var SignatureReceivedResult = literal("receivedSignature");
var VersionResult = type({
  "solana-core": string10(),
  "feature-set": optional(number8())
});
var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string10()])),
  logs: nullable(array2(string10())),
  accounts: optional(nullable(array2(nullable(type({
    executable: boolean3(),
    owner: string10(),
    lamports: number8(),
    data: array2(string10()),
    rentEpoch: optional(number8())
  }))))),
  unitsConsumed: optional(number8()),
  returnData: optional(nullable(type({
    programId: string10(),
    data: tuple3([string10(), literal("base64")])
  })))
}));
var BlockProductionResponseStruct = jsonRpcResultAndContext(type({
  byIdentity: record(string10(), array2(number8())),
  range: type({
    firstSlot: number8(),
    lastSlot: number8()
  })
}));
var GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
var GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
var GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
var GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
var GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
var GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
var SlotRpcResult = jsonRpcResult(number8());
var GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number8(),
  circulating: number8(),
  nonCirculating: number8(),
  nonCirculatingAccounts: array2(PublicKeyFromString)
}));
var TokenAmountResult = type({
  amount: string10(),
  uiAmount: nullable(number8()),
  decimals: number8(),
  uiAmountString: optional(string10())
});
var GetTokenLargestAccountsResult = jsonRpcResultAndContext(array2(type({
  address: PublicKeyFromString,
  amount: string10(),
  uiAmount: nullable(number8()),
  decimals: number8(),
  uiAmountString: optional(string10())
})));
var GetTokenAccountsByOwner = jsonRpcResultAndContext(array2(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean3(),
    owner: PublicKeyFromString,
    lamports: number8(),
    data: BufferFromRawAccountData,
    rentEpoch: number8()
  })
})));
var ParsedAccountDataResult = type({
  program: string10(),
  parsed: unknown(),
  space: number8()
});
var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array2(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean3(),
    owner: PublicKeyFromString,
    lamports: number8(),
    data: ParsedAccountDataResult,
    rentEpoch: number8()
  })
})));
var GetLargestAccountsRpcResult = jsonRpcResultAndContext(array2(type({
  lamports: number8(),
  address: PublicKeyFromString
})));
var AccountInfoResult = type({
  executable: boolean3(),
  owner: PublicKeyFromString,
  lamports: number8(),
  data: BufferFromRawAccountData,
  rentEpoch: number8()
});
var KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ParsedOrRawAccountData = coerce2(union([instance(Buffer2), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
  if (Array.isArray(value)) {
    return create2(value, BufferFromRawAccountData);
  } else {
    return value;
  }
});
var ParsedAccountInfoResult = type({
  executable: boolean3(),
  owner: PublicKeyFromString,
  lamports: number8(),
  data: ParsedOrRawAccountData,
  rentEpoch: number8()
});
var KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});
var StakeActivationResult = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number8(),
  inactive: number8()
});
var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array2(type({
  signature: string10(),
  slot: number8(),
  err: TransactionErrorResult,
  memo: nullable(string10()),
  blockTime: optional(nullable(number8()))
})));
var GetSignaturesForAddressRpcResult = jsonRpcResult(array2(type({
  signature: string10(),
  slot: number8(),
  err: TransactionErrorResult,
  memo: nullable(string10()),
  blockTime: optional(nullable(number8()))
})));
var AccountNotificationResult = type({
  subscription: number8(),
  result: notificationResultAndContext(AccountInfoResult)
});
var ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ProgramAccountNotificationResult = type({
  subscription: number8(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});
var SlotInfoResult = type({
  parent: number8(),
  slot: number8(),
  root: number8()
});
var SlotNotificationResult = type({
  subscription: number8(),
  result: SlotInfoResult
});
var SlotUpdateResult = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number8(),
  timestamp: number8()
}), type({
  type: literal("createdBank"),
  parent: number8(),
  slot: number8(),
  timestamp: number8()
}), type({
  type: literal("frozen"),
  slot: number8(),
  timestamp: number8(),
  stats: type({
    numTransactionEntries: number8(),
    numSuccessfulTransactions: number8(),
    numFailedTransactions: number8(),
    maxTransactionsPerEntry: number8()
  })
}), type({
  type: literal("dead"),
  slot: number8(),
  timestamp: number8(),
  err: string10()
})]);
var SlotUpdateNotificationResult = type({
  subscription: number8(),
  result: SlotUpdateResult
});
var SignatureNotificationResult = type({
  subscription: number8(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
});
var RootNotificationResult = type({
  subscription: number8(),
  result: number8()
});
var ContactInfoResult = type({
  pubkey: string10(),
  gossip: nullable(string10()),
  tpu: nullable(string10()),
  rpc: nullable(string10()),
  version: nullable(string10())
});
var VoteAccountInfoResult = type({
  votePubkey: string10(),
  nodePubkey: string10(),
  activatedStake: number8(),
  epochVoteAccount: boolean3(),
  epochCredits: array2(tuple3([number8(), number8(), number8()])),
  commission: number8(),
  lastVote: number8(),
  rootSlot: nullable(number8())
});
var GetVoteAccounts = jsonRpcResult(type({
  current: array2(VoteAccountInfoResult),
  delinquent: array2(VoteAccountInfoResult)
}));
var ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]);
var SignatureStatusResponse = type({
  slot: number8(),
  confirmations: nullable(number8()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
});
var GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array2(nullable(SignatureStatusResponse)));
var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number8());
var AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array2(number8()),
  readonlyIndexes: array2(number8())
});
var ConfirmedTransactionResult = type({
  signatures: array2(string10()),
  message: type({
    accountKeys: array2(string10()),
    header: type({
      numRequiredSignatures: number8(),
      numReadonlySignedAccounts: number8(),
      numReadonlyUnsignedAccounts: number8()
    }),
    instructions: array2(type({
      accounts: array2(number8()),
      data: string10(),
      programIdIndex: number8()
    })),
    recentBlockhash: string10(),
    addressTableLookups: optional(array2(AddressTableLookupStruct))
  })
});
var AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean3(),
  writable: boolean3(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
});
var ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array2(AnnotatedAccountKey),
  signatures: array2(string10())
});
var ParsedInstructionResult = type({
  parsed: unknown(),
  program: string10(),
  programId: PublicKeyFromString
});
var RawInstructionResult = type({
  accounts: array2(PublicKeyFromString),
  data: string10(),
  programId: PublicKeyFromString
});
var InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
var UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string10(),
  programId: string10()
}), type({
  accounts: array2(string10()),
  data: string10(),
  programId: string10()
})]);
var ParsedOrRawInstruction = coerce2(InstructionResult, UnknownInstructionResult, (value) => {
  if ("accounts" in value) {
    return create2(value, RawInstructionResult);
  } else {
    return create2(value, ParsedInstructionResult);
  }
});
var ParsedConfirmedTransactionResult = type({
  signatures: array2(string10()),
  message: type({
    accountKeys: array2(AnnotatedAccountKey),
    instructions: array2(ParsedOrRawInstruction),
    recentBlockhash: string10(),
    addressTableLookups: optional(nullable(array2(AddressTableLookupStruct)))
  })
});
var TokenBalanceResult = type({
  accountIndex: number8(),
  mint: string10(),
  owner: optional(string10()),
  uiTokenAmount: TokenAmountResult
});
var LoadedAddressesResult = type({
  writable: array2(PublicKeyFromString),
  readonly: array2(PublicKeyFromString)
});
var ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number8(),
  innerInstructions: optional(nullable(array2(type({
    index: number8(),
    instructions: array2(type({
      accounts: array2(number8()),
      data: string10(),
      programIdIndex: number8()
    }))
  })))),
  preBalances: array2(number8()),
  postBalances: array2(number8()),
  logMessages: optional(nullable(array2(string10()))),
  preTokenBalances: optional(nullable(array2(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array2(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number8())
});
var ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number8(),
  innerInstructions: optional(nullable(array2(type({
    index: number8(),
    instructions: array2(ParsedOrRawInstruction)
  })))),
  preBalances: array2(number8()),
  postBalances: array2(number8()),
  logMessages: optional(nullable(array2(string10()))),
  preTokenBalances: optional(nullable(array2(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array2(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number8())
});
var TransactionVersionStruct = union([literal(0), literal("legacy")]);
var RewardsResult = type({
  pubkey: string10(),
  lamports: number8(),
  postBalance: nullable(number8()),
  rewardType: nullable(string10()),
  commission: optional(nullable(number8()))
});
var GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string10(),
  previousBlockhash: string10(),
  parentSlot: number8(),
  transactions: array2(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array2(RewardsResult)),
  blockTime: nullable(number8()),
  blockHeight: nullable(number8())
})));
var GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string10(),
  previousBlockhash: string10(),
  parentSlot: number8(),
  rewards: optional(array2(RewardsResult)),
  blockTime: nullable(number8()),
  blockHeight: nullable(number8())
})));
var GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string10(),
  previousBlockhash: string10(),
  parentSlot: number8(),
  transactions: array2(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array2(RewardsResult)),
  blockTime: nullable(number8()),
  blockHeight: nullable(number8())
})));
var GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string10(),
  previousBlockhash: string10(),
  parentSlot: number8(),
  transactions: array2(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array2(RewardsResult)),
  blockTime: nullable(number8()),
  blockHeight: nullable(number8())
})));
var GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string10(),
  previousBlockhash: string10(),
  parentSlot: number8(),
  transactions: array2(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array2(RewardsResult)),
  blockTime: nullable(number8()),
  blockHeight: nullable(number8())
})));
var GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string10(),
  previousBlockhash: string10(),
  parentSlot: number8(),
  rewards: optional(array2(RewardsResult)),
  blockTime: nullable(number8()),
  blockHeight: nullable(number8())
})));
var GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string10(),
  previousBlockhash: string10(),
  parentSlot: number8(),
  transactions: array2(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array2(RewardsResult)),
  blockTime: nullable(number8())
})));
var GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string10(),
  previousBlockhash: string10(),
  parentSlot: number8(),
  signatures: array2(string10()),
  blockTime: nullable(number8())
})));
var GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number8(),
  meta: nullable(ConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number8())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
})));
var GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number8(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number8())),
  version: optional(TransactionVersionStruct)
})));
var GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(type({
  blockhash: string10(),
  feeCalculator: type({
    lamportsPerSignature: number8()
  })
}));
var GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string10(),
  lastValidBlockHeight: number8()
}));
var IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean3());
var PerfSampleResult = type({
  slot: number8(),
  numTransactions: number8(),
  numSlots: number8(),
  samplePeriodSecs: number8()
});
var GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array2(PerfSampleResult));
var GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number8()
  })
})));
var RequestAirdropRpcResult = jsonRpcResult(string10());
var SendTransactionRpcResult = jsonRpcResult(string10());
var LogsResult = type({
  err: TransactionErrorResult,
  logs: array2(string10()),
  signature: string10()
});
var LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number8()
});
class Keypair {
  constructor(keypair) {
    this._keypair = undefined;
    this._keypair = keypair ?? generateKeypair();
  }
  static generate() {
    return new Keypair(generateKeypair());
  }
  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error("bad secret key size");
    }
    const publicKey2 = secretKey.slice(32, 64);
    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey(privateScalar);
      for (let ii = 0;ii < 32; ii++) {
        if (publicKey2[ii] !== computedPublicKey[ii]) {
          throw new Error("provided secretKey is invalid");
        }
      }
    }
    return new Keypair({
      publicKey: publicKey2,
      secretKey
    });
  }
  static fromSeed(seed) {
    const publicKey2 = getPublicKey(seed);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey2, 32);
    return new Keypair({
      publicKey: publicKey2,
      secretKey
    });
  }
  get publicKey() {
    return new PublicKey(this._keypair.publicKey);
  }
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("recentSlot"), BufferLayout.u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642(), BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  }
});
class AddressLookupTableProgram {
  constructor() {
  }
  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), import_bigint_buffer.toBufferLE(BigInt(params.recentSlot), 8)], this.programId);
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
    const data = encodeData(type2, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed
    });
    const keys = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    }), lookupTableAddress];
  }
  static freezeLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
    const data = encodeData(type2);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static extendLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
    const data = encodeData(type2, {
      addresses: params.addresses.map((addr) => addr.toBytes())
    });
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    if (params.payer) {
      keys.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static deactivateLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
    const data = encodeData(type2);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static closeLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
    const data = encodeData(type2);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
}
AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units"), BufferLayout.u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), u642("microLamports")])
  }
});

class ComputeBudgetProgram {
  constructor() {
  }
  static requestUnits(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
    const data = encodeData(type2, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static requestHeapFrame(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
    const data = encodeData(type2, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitLimit(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
    const data = encodeData(type2, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitPrice(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
    const data = encodeData(type2, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
}
ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
var PRIVATE_KEY_BYTES$1 = 64;
var PUBLIC_KEY_BYTES$1 = 32;
var SIGNATURE_BYTES = 64;
var ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u8("padding"), BufferLayout.u16("signatureOffset"), BufferLayout.u16("signatureInstructionIndex"), BufferLayout.u16("publicKeyOffset"), BufferLayout.u16("publicKeyInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u16("messageInstructionIndex")]);

class Ed25519Program {
  constructor() {
  }
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey2,
      message,
      signature,
      instructionIndex
    } = params;
    assert3(publicKey2.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey2.length} bytes`);
    assert3(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
    const signatureOffset = publicKeyOffset + publicKey2.length;
    const messageDataOffset = signatureOffset + signature.length;
    const numSignatures = 1;
    const instructionData = Buffer2.alloc(messageDataOffset + message.length);
    const index = instructionIndex == null ? 65535 : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey2, publicKeyOffset);
    instructionData.fill(signature, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction({
      keys: [],
      programId: Ed25519Program.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert3(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair.fromSecretKey(privateKey);
      const publicKey2 = keypair.publicKey.toBytes();
      const signature = sign7(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey2,
        message,
        signature,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
var ecdsaSign = (msgHash, privKey) => {
  const signature = secp256k1.sign(msgHash, privKey);
  return [signature.toCompactRawBytes(), signature.recovery];
};
secp256k1.utils.isValidPrivateKey;
var publicKeyCreate = secp256k1.getPublicKey;
var PRIVATE_KEY_BYTES = 32;
var ETHEREUM_ADDRESS_BYTES = 20;
var PUBLIC_KEY_BYTES = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
var SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u16("signatureOffset"), BufferLayout.u8("signatureInstructionIndex"), BufferLayout.u16("ethAddressOffset"), BufferLayout.u8("ethAddressInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u8("messageInstructionIndex"), BufferLayout.blob(20, "ethAddress"), BufferLayout.blob(64, "signature"), BufferLayout.u8("recoveryId")]);

class Secp256k1Program {
  constructor() {
  }
  static publicKeyToEthAddress(publicKey2) {
    assert3(publicKey2.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey2.length} bytes`);
    try {
      return Buffer2.from(keccak_256(toBuffer(publicKey2))).slice(-ETHEREUM_ADDRESS_BYTES);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey2,
      message,
      signature,
      recoveryId,
      instructionIndex
    } = params;
    return Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey2),
      message,
      signature,
      recoveryId,
      instructionIndex
    });
  }
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress;
    if (typeof rawAddress === "string") {
      if (rawAddress.startsWith("0x")) {
        ethAddress = Buffer2.from(rawAddress.substr(2), "hex");
      } else {
        ethAddress = Buffer2.from(rawAddress, "hex");
      }
    } else {
      ethAddress = rawAddress;
    }
    assert3(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress.length;
    const messageDataOffset = signatureOffset + signature.length + 1;
    const numSignatures = 1;
    const instructionData = Buffer2.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer(signature),
      ethAddress: toBuffer(ethAddress),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
    return new TransactionInstruction({
      keys: [],
      programId: Secp256k1Program.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert3(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer(pkey);
      const publicKey2 = publicKeyCreate(privateKey, false).slice(1);
      const messageHash = Buffer2.from(keccak_256(toBuffer(message)));
      const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey2,
        message,
        signature,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
var _class2;
var STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
class Lockup {
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = undefined;
    this.epoch = undefined;
    this.custodian = undefined;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
}
_class2 = Lockup;
Lockup.default = new _class2(0, 0, PublicKey.default);
var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
});
var StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

class StakeProgram {
  constructor() {
  }
  static initialize(params) {
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: maybeLockup
    } = params;
    const lockup2 = maybeLockup || Lockup.default;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Initialize;
    const data = encodeData(type2, {
      authorized: {
        staker: toBuffer(authorized2.staker.toBuffer()),
        withdrawer: toBuffer(authorized2.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup2.unixTimestamp,
        epoch: lockup2.epoch,
        custodian: toBuffer(lockup2.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static createAccountWithSeed(params) {
    const transaction = new Transaction2;
    transaction.add(SystemProgram.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    }));
  }
  static createAccount(params) {
    const transaction = new Transaction2;
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    }));
  }
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Delegate;
    const data = encodeData(type2);
    return new Transaction2().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed,
      authorityOwner: toBuffer(authorityOwner.toBuffer())
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Split;
    const data = encodeData(type2, {
      lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static split(params, rentExemptReserve) {
    const transaction = new Transaction2;
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: rentExemptReserve,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }
  static splitWithSeed(params, rentExemptReserve) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed,
      lamports
    } = params;
    const transaction = new Transaction2;
    transaction.add(SystemProgram.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed,
      space: this.space,
      programId: this.programId
    }));
    if (rentExemptReserve && rentExemptReserve > 0) {
      transaction.add(SystemProgram.transfer({
        fromPubkey: params.authorizedPubkey,
        toPubkey: splitStakePubkey,
        lamports: rentExemptReserve
      }));
    }
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Merge;
    const data = encodeData(type2);
    return new Transaction2().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type2, {
      lamports
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
    const data = encodeData(type2);
    return new Transaction2().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
}
StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
StakeProgram.space = 200;
var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteAuthorizeWithSeedArgs()])
  }
});
var VoteAuthorizationLayout = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

class VoteProgram {
  constructor() {
  }
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit: voteInit2
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
    const data = encodeData(type2, {
      voteInit: {
        nodePubkey: toBuffer(voteInit2.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer(voteInit2.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer(voteInit2.authorizedWithdrawer.toBuffer()),
        commission: voteInit2.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static createAccount(params) {
    const transaction = new Transaction2;
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type2, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type2, {
      lamports
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error("Withdraw will leave vote account with insufficient funds.");
    }
    return VoteProgram.withdraw(params);
  }
  static updateValidatorIdentity(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      nodePubkey
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;
    const data = encodeData(type2);
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: nodePubkey,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
}
VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
VoteProgram.space = 3762;
var VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111");
var InfoString = type({
  name: string10(),
  website: optional(string10()),
  details: optional(string10()),
  keybaseUsername: optional(string10())
});
var VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111");
var VoteAccountLayout = BufferLayout.struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  BufferLayout.u8("commission"),
  BufferLayout.nu64(),
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.u32("confirmationCount")]), BufferLayout.offset(BufferLayout.u32(), -8), "votes"),
  BufferLayout.u8("rootSlotValid"),
  BufferLayout.nu64("rootSlot"),
  BufferLayout.nu64(),
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), publicKey("authorizedVoter")]), BufferLayout.offset(BufferLayout.u32(), -8), "authorizedVoters"),
  BufferLayout.struct([BufferLayout.seq(BufferLayout.struct([publicKey("authorizedPubkey"), BufferLayout.nu64("epochOfLastAuthorizedSwitch"), BufferLayout.nu64("targetEpoch")]), 32, "buf"), BufferLayout.nu64("idx"), BufferLayout.u8("isEmpty")], "priorVoters"),
  BufferLayout.nu64(),
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), BufferLayout.nu64("credits"), BufferLayout.nu64("prevCredits")]), BufferLayout.offset(BufferLayout.u32(), -8), "epochCredits"),
  BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.nu64("timestamp")], "lastTimestamp")
]);

// src/utils/getToken.ts
var cache = new LRUCache({ max: 64000 });
var getToken_default = async (tokenAddr, chain) => {
  const cacheKey = tokenAddr + chain;
  const cacheVal = cache.get(cacheKey);
  console.log("get token", tokenAddr, chain);
  if (cacheVal)
    return cacheVal;
  let foundChain = chains_default.find((c) => c.chain === chain);
  if (!foundChain) {
    return { symbol: "Unknown", decimals: 0 };
  }
  let val = { symbol: "Unknown", decimals: 0 };
  if (foundChain.chain === client3.Chain.SOL) {
    const conn = foundChain.connection;
    const info = conn.getParsedAccountInfo(new PublicKey(tokenAddr));
    console.log(info);
  } else {
    const web33 = foundChain.web3;
    const contract3 = new web33.eth.Contract(erc20_default, tokenAddr);
    const symbol2 = await contract3.methods.symbol().call();
    const decimals = await contract3.methods.decimals().call();
    val = {
      symbol: symbol2,
      decimals: Number(decimals)
    };
    cache.set(cacheKey, val);
    return val;
  }
  return { symbol: "Unknown", decimals: 0 };
};

// src/notify.ts
var import_telegraf2 = __toESM(require_lib(), 1);
var debugInfo = { user_id: null };
var nativeTransfer = async (from, to, value, hash3, chain) => {
  let listeners = await getDbIds([from, to], chain);
  if (listeners.length === 0)
    return;
  listeners.forEach((listener) => {
    let msg = baseMessage(chain);
    const valString = formatNative(value, chain);
    msg += `<a href="${getAccountUrl(from, chain)}">${listener.address === from ? listener.alias : from}</a> sent ${valString} ${chain} to <a href="${getAccountUrl(to, chain)}">${listener.address === to ? listener.alias : to}</a>\n\n`;
    msg += txHashMessage(hash3);
    const inlineKeyboard = [[txHashButton(hash3, chain)]];
    sendMessage(listener.groupId, msg, inlineKeyboard);
  });
  logger.verbose(`NATIVE(${chain}): from:${from}, value:${value}, to:${to}, hash:${hash3}`);
};
var tokenTransfer = async (from, to, token, value, hash3, chain) => {
  let listeners = await getDbIds([from, to], chain);
  if (listeners.length === 0)
    return;
  const { symbol: symbol2, decimals } = await getToken_default(token, chain);
  listeners.forEach((listener) => {
    let msg = baseMessage(chain);
    msg += `<a href="${getAccountUrl(from, chain)}">${listener.address === from ? listener.alias : from}</a> sent ${formatValue(value, decimals)} <a href="${getTokenUrl(token, chain)}">\$${symbol2}</a> to <a href="${getAccountUrl(to, chain)}">${listener.address === to ? listener.alias : to}</a>\n\n`;
    msg += txHashMessage(hash3);
    msg += `Token Contract: <code>${token}</code>`;
    const inlineKeyboard = [[txHashButton(hash3, chain)]];
    inlineKeyboard.push([chartButton(token)]);
    inlineKeyboard.push([maestroButton(token), maestroProButton(token)]);
    sendMessage(listener.groupId, msg, inlineKeyboard);
  });
  logger.verbose(`TOKEN(${chain}): from:${from}, to:${to}, token:${token}, value:${value}, hash:${hash3}`);
};
var swap = async (address7, inToken, outToken, inValue, outValue, hash3, chain) => {
  let listeners = await getDbIds([address7], chain);
  if (listeners.length === 0)
    return;
  const { symbol: symbolIn, decimals: decimalsIn } = await getToken_default(inToken, chain);
  const { symbol: symbolOut, decimals: decimalsOut } = await getToken_default(outToken, chain);
  listeners.forEach((listener) => {
    let msg = baseMessage(chain);
    msg += `<a href="${getAccountUrl(address7, chain)}">${listener.alias ?? address7}</a>`;
    const inlineKeyboard = [[txHashButton(hash3, chain)]];
    if (WRAPPED_NATIVE.includes(inToken.toLowerCase())) {
      msg += ` bought ${formatValue(outValue, decimalsOut)} <a href="${getTokenUrl(outToken, chain)}">\$${symbolOut}</a> for ${formatNative(inValue, chain)} ${chain}.\n\n`;
      inlineKeyboard.push([chartButton(outToken)]);
      inlineKeyboard.push([maestroButton(outToken), maestroProButton(outToken)]);
      logger.verbose(`SWAP(BUY)(${chain}): address:${address7}, token:${outToken}, amount:${outValue}, value:${inValue}, hash:${hash3}`);
    } else if (WRAPPED_NATIVE.includes(outToken.toLowerCase())) {
      msg += ` sold ${formatValue(inValue, decimalsIn)} <a href="${getTokenUrl(inToken, chain)}">\$${symbolIn}</a> for ${formatNative(outValue, chain)} ${chain}.\n\n`;
      inlineKeyboard.push([chartButton(inToken)]);
      inlineKeyboard.push([maestroButton(inToken), maestroProButton(inToken)]);
      logger.verbose(`SWAP(SELL)(${chain}): address:${address7}, token:${inToken}, amount:${inValue}, value:${outValue}, hash:${hash3}`);
    } else {
      msg += ` swapped ${formatValue(inValue, decimalsIn)} <a href="${getTokenUrl(inToken, chain)}">\$${symbolIn}</a> for ${formatValue(outValue, decimalsOut)} <a href="${getTokenUrl(outToken, chain)}">\$${symbolOut}</a>.\n\n`;
      inlineKeyboard.push([
        chartButton(inToken, symbolIn),
        chartButton(outToken, symbolOut)
      ]);
      inlineKeyboard.push([
        maestroButton(inToken, symbolIn),
        maestroButton(outToken, symbolOut)
      ]);
      inlineKeyboard.push([
        maestroProButton(inToken, symbolIn),
        maestroProButton(outToken, symbolOut)
      ]);
      logger.verbose(`SWAP(SWAP)(${chain}): address:${address7}, in:${inToken}, out:${outToken}, inValue:${inValue}, outValue:${outValue}, hash:${hash3}`);
    }
    msg += txHashMessage(hash3);
    sendMessage(listener.groupId, msg, inlineKeyboard);
  });
};
var sendMessage = async (groupId, msg, inlineKeyboard) => {
  while (true) {
    let retry = false;
    try {
      bot.telegram.sendMessage(groupId, msg, {
        parse_mode: "HTML",
        reply_markup: { inline_keyboard: inlineKeyboard }
      });
    } catch (e) {
      if (e instanceof import_telegraf2.TelegramError) {
        if (e.parameters?.migrate_to_chat_id) {
          await prisma.group.update({
            where: { id: groupId },
            data: { id: e.parameters.migrate_to_chat_id.toString() }
          });
          groupId = e.parameters.migrate_to_chat_id.toString();
          retry = true;
        }
        logger.error(`Failed to send message to ${groupId}: ${e.message}`);
      } else if (e instanceof Error) {
        logger.error(`Failed to send message to ${groupId}: Unknown error ${e.message}`);
      }
    }
    if (!retry)
      break;
  }
};
var getDbIds = async (addrList, chain) => {
  let listeners = await prisma.watchAddress.findMany({
    where: { address: { in: addrList }, chains: { has: chain } }
  });
  if (debugInfo.user_id) {
    listeners = [
      {
        groupId: debugInfo.user_id,
        id: "DEBUG",
        chains: [chain],
        address: addrList[0],
        alias: addrList[0]
      }
    ];
  }
  return listeners;
};
var baseMessage = (chain) => {
  return `Blockchain: ${chain}\n\n`;
};
var txHashMessage = (hash3) => {
  return `Tx Hash: <code>${hash3}</code>\n\n`;
};
var txHashButton = (hash3, chain) => {
  return { text: "View Transaction", url: getTxUrl(hash3, chain) };
};
var chartButton = (token, tokenName = "") => {
  return {
    text: `Chart${tokenName.length > 0 ? ` \$${tokenName}` : ""}`,
    url: `https://www.dextools.io/app/en/ether/pair-explorer/${token}`
  };
};
var maestroButton = (tokenAddress, tokenName = "") => {
  return {
    text: `Trade${tokenName.length > 0 ? ` \$${tokenName}` : ""} with Maestro`,
    url: `https://t.me/MaestroSniperBot?start=${tokenAddress}`
  };
};
var maestroProButton = (tokenAddress, tokenName = "") => {
  return {
    text: `Trade${tokenName.length > 0 ? ` \$${tokenName}` : ""} with Maestro PRO`,
    url: `https://t.me/maestropro?start=${tokenAddress}`
  };
};
var chainExplorers = {
  [client4.Chain.ETH]: "https://etherscan.io",
  [client4.Chain.MATIC]: "https://polygonscan.com",
  [client4.Chain.SOL]: "https://solscan.io",
  [client4.Chain.BNB]: "https://bscscan.com",
  [client4.Chain.AVAX]: "https://subnets.avax.network/c-chain",
  [client4.Chain.ARB]: "https://arbiscan.io"
};
var getTxUrl = (txHash, chain) => {
  return chainExplorers[chain] + `/tx/${txHash}`;
};
var getAccountUrl = (account2, chain) => {
  return chainExplorers[chain] + `/address/${account2}`;
};
var getTokenUrl = (tokenAddress, chain) => {
  return chainExplorers[chain] + `/token/${tokenAddress}`;
};
var formatNative = (amt, chain) => {
  return formatValue(amt, chain === client4.Chain.SOL ? 9 : 18);
};
var formatValue = (amt, decimals) => {
  return new Decimal2(amt.toString()).div(new Decimal2(10).pow(decimals)).toString();
};

// src/utils/sleep.ts
var sleep_default = async (ms2) => new Promise((resolve) => setTimeout(resolve, ms2));

// src/chain/evm.ts
class EVMChain extends BaseChain {
  chain;
  web3;
  running = true;
  backlog = 0;
  constructor(chain2, rpcUrl) {
    super();
    this.chain = chain2;
    this.web3 = new esm_default2(rpcUrl.replace("wss://", "https://").replace("/ws/", "/rpc/"));
    setInterval(() => {
      logger.verbose(`Refreshing web3 instance for ${chain2}`);
      this.web3 = new esm_default2(rpcUrl.replace("wss://", "https://").replace("/ws/", "/rpc/"));
    }, 15000);
  }
  async start() {
    let nextBlock = 0n;
    logger.info(`Started ${this.chain}`);
    while (this.running) {
      const currentBlock = await this.web3.eth.getBlockNumber();
      if (nextBlock === 0n) {
        nextBlock = currentBlock;
      } else {
        for (let blockNum = nextBlock;blockNum <= currentBlock; blockNum++) {
          this.processBlock(blockNum);
        }
        nextBlock = currentBlock + 1n;
      }
      await sleep_default(5000);
    }
  }
  async stop() {
    this.running = false;
  }
  async processBlock(blockNum) {
    this.backlog++;
    let hash3;
    try {
      const block4 = await this.web3.eth.getBlock(blockNum, true);
      hash3 = block4.hash;
      const blockLogs = await this.web3.eth.getPastLogs({ blockHash: hash3 });
      const logMap = {};
      for (const log3 of blockLogs) {
        if (typeof log3 === "string" || !log3.transactionHash)
          continue;
        if (!(log3.transactionHash in logMap)) {
          logMap[log3.transactionHash] = [];
        }
        logMap[log3.transactionHash].push(log3);
      }
      logger.verbose(`${this.chain}: New block ${blockNum} [backlog: ${this.backlog - 1}]`);
      if (!block4.transactions)
        return;
      const txThreads = block4.transactions.map(async (tx2) => {
        if (typeof tx2 === "string")
          return;
        return this.processTx(tx2, tx2.hash, logMap[tx2.hash] || []);
      });
      await Promise.all(txThreads);
    } catch (e) {
      let errorMsg = e instanceof Error ? e.message : e;
      logger.error(`Failed to process block ${hash3 ?? "<unknown>"}(${blockNum}) on chain ${this.chain}: ${errorMsg}`);
    }
    this.backlog--;
  }
  async processTx(tx2, hash3, logs) {
    try {
      if (tx2.to === V3_ROUTER && tx2.input && tx2.input.slice(0, 10) === V3_EXECUTE) {
        await this.processUniswapExecute(tx2, hash3, logs);
        return;
      } else if (V2_ROUTER.includes(tx2.to ?? "")) {
        await this.processUniswapV2(tx2, hash3, logs);
        return;
      }
      await this.processTokenTransfer(tx2, hash3, logs);
      await this.processNativeTransfer(tx2, hash3);
    } catch (e) {
      logger.error(`Failed to process tx ${hash3} on chain ${this.chain}: ${e}`);
    }
  }
  async processUniswapExecute(tx2, hash3, logs) {
    if (!tx2.input || !tx2.from)
      return;
    const executeParams = this.web3.eth.abi.decodeParameters(["bytes", "bytes[]", "uint256"], "0x" + tx2.input.toString().slice(10));
    const commands = executeParams["0"].slice(2);
    const inputs = executeParams["1"];
    for (let idx = 0;idx < commands.length / 2; idx++) {
      const command = commands.slice(2 * idx, 2 * (idx + 1));
      const input = inputs[idx];
      if (["08", "09"].includes(command)) {
        const swapParams = this.web3.eth.abi.decodeParameters(["address", "uint256", "uint256", "address[]", "bool"], input);
        let inAmount = swapParams["1"];
        let outAmount = swapParams["2"];
        const path = swapParams["3"];
        const inToken = path[0];
        const outToken = path[path.length - 1];
        if (command === "08") {
          const actualOutAmount = this.getSwapAmount(outToken, tx2.from, logs, false);
          if (actualOutAmount !== -1n)
            outAmount = actualOutAmount;
        } else {
          const actualInAmount = this.getSwapAmount(inToken, tx2.from, logs, true);
          if (actualInAmount !== -1n)
            inAmount = actualInAmount;
        }
        await swap(tx2.from, inToken, outToken, inAmount, outAmount, hash3, this.chain);
      }
    }
  }
  async processUniswapV2(tx2, hash3, logs) {
    if (!tx2.input || !tx2.from)
      return;
    const funcSig = tx2.input.slice(0, 10).toString();
    if ([
      V2_SWAP_EXACT_TOKENS_FOR_TOKENS,
      V2_SWAP_TOKENS_FOR_EXACT_TOKENS,
      V2_SWAP_TOKENS_FOR_EXACT_ETH,
      V2_SWAP_EXACT_TOKENS_FOR_ETH,
      V2_SWAP_EXACT_TOKENS_FOR_ETH_FEE,
      V2_SWAP_EXACT_TOKENS_FOR_TOKENS_FEE
    ].includes(funcSig)) {
      const swapParams = this.web3.eth.abi.decodeParameters(["uint256", "uint256", "address[]", "address", "uint256"], "0x" + tx2.input.toString().slice(10));
      let inAmount = swapParams["0"];
      let outAmount = swapParams["1"];
      const path = swapParams["2"];
      const toAddress = swapParams["3"];
      const inToken = path[0];
      const outToken = path[path.length - 1];
      if ([
        V2_SWAP_TOKENS_FOR_EXACT_TOKENS,
        V2_SWAP_TOKENS_FOR_EXACT_ETH
      ].includes(funcSig)) {
        [inAmount, outAmount] = [outAmount, inAmount];
        const actualInAmount = this.getSwapAmount(inToken, tx2.from, logs, true);
        if (actualInAmount !== -1n)
          inAmount = actualInAmount;
      } else {
        const actualOutAmount = this.getSwapAmount(outToken, toAddress, logs, false);
        if (actualOutAmount !== -1n)
          outAmount = actualOutAmount;
      }
      await swap(tx2.from, inToken, outToken, inAmount, outAmount, hash3, this.chain);
    } else if ([
      V2_SWAP_EXACT_ETH_FOR_TOKENS,
      V2_SWAP_ETH_FOR_EXACT_TOKENS,
      V2_SWAP_EXACT_ETH_FOR_TOKENS_FEE
    ].includes(funcSig)) {
      const swapParams = this.web3.eth.abi.decodeParameters(["uint256", "address[]", "address", "uint256"], "0x" + tx2.input.toString().slice(10));
      let inAmount = BigInt(tx2.value || 0);
      let outAmount = swapParams["0"];
      const path = swapParams["1"];
      const toAddress = swapParams["2"];
      const outToken = path[path.length - 1];
      if ([V2_SWAP_ETH_FOR_EXACT_TOKENS].includes(funcSig)) {
        const actualInAmount = this.getSwapAmount(path[0], tx2.from, logs, true);
        if (actualInAmount !== -1n)
          inAmount = actualInAmount;
      } else {
        const actualOutAmount = this.getSwapAmount(outToken, toAddress, logs, false);
        if (actualOutAmount !== -1n)
          outAmount = actualOutAmount;
      }
      await swap(tx2.from, path[0], outToken, inAmount, outAmount, hash3, this.chain);
    }
  }
  processTokenTransfer = async (tx2, hash3, logs) => {
    for (const log3 of logs) {
      if (log3.topics && log3.topics.length === 3 && log3.data && log3.address && log3.topics[0] === TOKEN_TRANSFER_HASH) {
        const token = log3.address;
        const [from, to] = log3.topics.slice(1).map((addr) => "0x" + addr.slice(26));
        const value = BigInt(log3.data.toString());
        await tokenTransfer(from, to, token, value, hash3, this.chain);
      }
    }
  };
  async processNativeTransfer(tx2, hash3) {
    if (tx2.from && tx2.to && tx2.value) {
      await nativeTransfer(tx2.from, tx2.to, BigInt(tx2.value), hash3, this.chain);
    }
  }
  getSwapAmount(token, address7, logs, isSender) {
    for (const log3 of logs) {
      if (log3.topics && log3.topics.length === 3 && log3.data && log3.address && log3.topics[0] === TOKEN_TRANSFER_HASH) {
        const logToken = log3.address;
        const [from, to] = log3.topics.slice(1).map((addr) => "0x" + addr.slice(26));
        const value = BigInt(log3.data.toString());
        if (logToken.toLowerCase() === token.toLowerCase() && (isSender && from === address7.toLowerCase() || !isSender && to === address7.toLowerCase())) {
          return value;
        }
      }
    }
    return -1n;
  }
}

// src/chains.ts
var chains2 = [
  new EVMChain(client5.Chain.ETH, "wss://fabled-late-slug.quiknode.pro/80a198a2bf0163c9d20edc586ef714cb51e645da/"),
  new EVMChain(client5.Chain.BNB, "wss://newest-damp-thunder.bsc.quiknode.pro/b05b34233018e372b262dcb612d7c095e7da0187/"),
  new EVMChain(client5.Chain.ARB, "wss://soft-snowy-knowledge.arbitrum-mainnet.quiknode.pro/276a5c9285c54aaab69fde9c2e280733504f38fd/"),
  new EVMChain(client5.Chain.MATIC, "wss://young-fabled-spree.matic.quiknode.pro/216eba4c817c2a5273d53d1de0ebd93ff635892c/"),
  new EVMChain(client5.Chain.AVAX, "wss://responsive-falling-breeze.avalanche-mainnet.quiknode.pro/5ef9491b9f8e5c8772fbbbb5fead494ed7172acd/ext/bc/C/ws/")
];
var chains_default = chains2;

// src/index.ts
var main = async () => {
  process.on("SIGINT", async () => {
    await Promise.all(chains_default.map((chain2) => chain2.stop()));
    logger.info("Ended gracefully");
    process.exit(0);
  });
  await Promise.all(chains_default.map((chain2) => chain2.start()));
};
await main();
